describe("treeControl", function() {
    function a(b, c) {
        for (var d = [], f = 0; f < c && b > 0; f++) d.push({
            label: "node " + e++,
            children: a(b - 1, c)
        });
        return d;
    }
    var b, c, d, e;
    beforeEach(function() {
        module("treeControl"), inject(function(a) {
            b = a.get("$compile"), c = a.get("$rootScope");
        }), e = 1;
    }), describe("rendering", function() {
        beforeEach(function() {
            c.treedata = a(2, 2), c.treedata.push({}), d = b('<treecontrol tree-model="treedata" selected-node="selected">{{node.label}}</treecontrol>')(c), 
            c.$digest();
        }), it("should render only first level of the tree thanks to ng-if", function() {
            expect(d.find("ul").length).toBe(1);
        }), it("should render all the children of the first level", function() {
            expect(d.find("li").length).toBe(3);
        }), it("should display first level parents as collapsed", function() {
            expect(d.find("li.tree-collapsed").length).toBe(2);
        }), it("should display elements with 0 children as leafs", function() {
            expect(d.find("li.tree-leaf").length).toBe(1);
        }), it("should render sub tree once an item is expanded thanks to ng-if", function() {
            d.find("li:eq(0) .tree-branch-head").click(), expect(d.find("li:eq(0) li").length).toBe(2);
        }), it("should display expanded items as expanded", function() {
            d.find("li:eq(0) .tree-branch-head").click(), expect(d.find("li:eq(0)").hasClass("tree-expanded")).toBeTruthy();
        }), it("should not have any nodes selected initially", function() {
            expect(d.find(".tree-selected").length).toBe(0), expect(c.selected).toBeUndefined();
        }), it("should select node when clicked", function() {
            d.find("li:eq(0) div").click(), expect(d.find("li:eq(0) div").hasClass("tree-selected")).toBeTruthy(), 
            expect(c.selected).toBeDefined();
        }), it("should transclude tree labels", function() {
            expect(d.find("li:eq(0) span").text()).toBe("node 1"), expect(d.find("li:eq(1) span").text()).toBe("node 4");
        }), it("should update tree rendering once model changes", function() {
            c.treedata[2].children = [ {} ], c.$digest(), expect(d.find("li.tree-leaf").length).toBe(0);
        });
    }), describe("customising using options.isLeaf", function() {
        it("should display first level parents as collapsed nodes, including the leaf", function() {
            c.treedata = a(2, 2), c.treedata.push({}), c.treeOptions = {
                isLeaf: function(a) {
                    return !1;
                }
            }, d = b('<treecontrol tree-model="treedata" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li.tree-collapsed").length).toBe(3), expect(d.find("li.tree-leaf").length).toBe(0);
        }), it("should display first level parents as leafs, including the actual branches", function() {
            c.treedata = a(2, 2), c.treedata.push({}), c.treeOptions = {
                isLeaf: function(a) {
                    return !0;
                }
            }, d = b('<treecontrol tree-model="treedata" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li.tree-collapsed").length).toBe(0), expect(d.find("li.tree-leaf").length).toBe(3);
        });
    }), describe("rendering using external scope data", function() {
        beforeEach(function() {
            c.label = "exLabel", c.treedata = a(2, 2), d = b('<treecontrol tree-model="treedata">{{label}} - {{node.label}}</treecontrol>')(c), 
            c.$digest();
        }), it("should transclude tree labels", function() {
            expect(d.find("li:eq(0) span").text()).toBe("exLabel - node 1"), expect(d.find("li:eq(1) span").text()).toBe("exLabel - node 4");
        });
    }), describe("support special members in label scope", function() {
        beforeEach(function() {
            c.label = "exLabel", c.treedata = a(2, 4);
        }), it("should render $parentNode for a tree with multiple roots", function() {
            d = b('<treecontrol tree-model="treedata">{{node.label}} parent:{{$parentNode?$parentNode.label:"N/A"}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0) span").text()).toBe("node 1 parent:N/A"), expect(d.find("li:eq(1) span").text()).toBe("node 6 parent:N/A"), 
            expect(d.find("li:eq(2) span").text()).toBe("node 11 parent:N/A"), expect(d.find("li:eq(3) span").text()).toBe("node 16 parent:N/A"), 
            d.find("li:eq(0) .tree-branch-head").click(), expect(d.find("li:eq(0) li:eq(0) span").text()).toBe("node 2 parent:node 1");
        }), it("should render $parentNode for a tree with a single root", function() {
            e = 1, c.treedata = a(2, 1), d = b('<treecontrol tree-model="treedata">{{node.label}} parent:{{$parentNode?$parentNode.label:"N/A"}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0) span").text()).toBe("node 1 parent:N/A"), d.find("li:eq(0) .tree-branch-head").click(), 
            expect(d.find("li:eq(0) li:eq(0) span").text()).toBe("node 2 parent:node 1");
        }), it("should render $index", function() {
            d = b('<treecontrol tree-model="treedata">{{node.label}} index:{{$index}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0) span").text()).toBe("node 1 index:0"), expect(d.find("li:eq(1) span").text()).toBe("node 6 index:1"), 
            expect(d.find("li:eq(2) span").text()).toBe("node 11 index:2"), expect(d.find("li:eq(3) span").text()).toBe("node 16 index:3");
        }), it("should render $first", function() {
            d = b('<treecontrol tree-model="treedata">{{node.label}} first:{{$first}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0) span").text()).toBe("node 1 first:true"), expect(d.find("li:eq(1) span").text()).toBe("node 6 first:false"), 
            expect(d.find("li:eq(2) span").text()).toBe("node 11 first:false"), expect(d.find("li:eq(3) span").text()).toBe("node 16 first:false");
        }), it("should render $middle", function() {
            d = b('<treecontrol tree-model="treedata">{{node.label}} middle:{{$middle}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0) span").text()).toBe("node 1 middle:false"), 
            expect(d.find("li:eq(1) span").text()).toBe("node 6 middle:true"), expect(d.find("li:eq(2) span").text()).toBe("node 11 middle:true"), 
            expect(d.find("li:eq(3) span").text()).toBe("node 16 middle:false");
        }), it("should render $last", function() {
            d = b('<treecontrol tree-model="treedata">{{node.label}} last:{{$last}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0) span").text()).toBe("node 1 last:false"), expect(d.find("li:eq(1) span").text()).toBe("node 6 last:false"), 
            expect(d.find("li:eq(2) span").text()).toBe("node 11 last:false"), expect(d.find("li:eq(3) span").text()).toBe("node 16 last:true");
        }), it("should render $even", function() {
            d = b('<treecontrol tree-model="treedata">{{node.label}} even:{{$even}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0) span").text()).toBe("node 1 even:true"), expect(d.find("li:eq(1) span").text()).toBe("node 6 even:false"), 
            expect(d.find("li:eq(2) span").text()).toBe("node 11 even:true"), expect(d.find("li:eq(3) span").text()).toBe("node 16 even:false");
        }), it("should render $odd", function() {
            d = b('<treecontrol tree-model="treedata">{{node.label}} odd:{{$odd}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0) span").text()).toBe("node 1 odd:false"), expect(d.find("li:eq(1) span").text()).toBe("node 6 odd:true"), 
            expect(d.find("li:eq(2) span").text()).toBe("node 11 odd:false"), expect(d.find("li:eq(3) span").text()).toBe("node 16 odd:true");
        });
    }), describe("selection", function() {
        it("should publish the currently selected node on scope", function() {
            c.treedata = a(2, 2), d = b('<treecontrol tree-model="treedata" selected-node="selectedItem">{{node.label}}</treecontrol>')(c), 
            c.$digest(), d.find("li:eq(0) div").click(), expect(c.selectedItem.label).toBe("node 1");
        }), it("should update the tree selection if the external scope selected-node changes", function() {
            c.treedata = a(2, 2), d = b('<treecontrol tree-model="treedata" selected-node="selectedItem">{{node.label}}</treecontrol>')(c), 
            c.selectedItem = c.treedata[1], c.$digest(), expect(d.find("li:eq(1) div.tree-selected").length).toBe(1);
        }), it("should invoke on-selection callback when item is selected and selected==true", function() {
            c.treedata = a(2, 2), d = b('<treecontrol tree-model="treedata" on-selection="itemSelected(node.label, selected)">{{node.label}}</treecontrol>')(c), 
            c.$digest(), c.itemSelected = jasmine.createSpy("itemSelected"), d.find("li:eq(0) div").click(), 
            expect(c.itemSelected).toHaveBeenCalledWith(c.treedata[0].label, !0);
        }), it("should call on-selection callback on item unselection with the node and selected==false", function() {
            c.treedata = a(2, 2), d = b('<treecontrol tree-model="treedata" on-selection="itemSelected(node.label, selected)">{{node.label}}</treecontrol>')(c), 
            c.$digest(), c.itemSelected = jasmine.createSpy("itemSelected"), d.find("li:eq(0) div").click(), 
            d.find("li:eq(0) div").click(), expect(c.itemSelected).toHaveBeenCalledWith(c.treedata[0].label, !0), 
            expect(c.itemSelected).toHaveBeenCalledWith(c.treedata[0].label, !1), expect(c.itemSelected.calls.length).toBe(2);
        }), it("should invoke on-selection callback with all the scope variables ($parentNode, $index, $first, $middle, $last, $odd, $even)", function() {
            c.treedata = a(2, 2), d = b('<treecontrol tree-model="treedata" on-selection="itemSelected(node.label, ($parentNode?$parentNode.label:null), $index, $first, $middle, $last, $odd, $even)">{{node.label}}</treecontrol>')(c), 
            c.$digest(), c.itemSelected = jasmine.createSpy("itemSelected"), d.find("li:eq(1) .tree-branch-head").click(), 
            d.find("li:eq(1) li:eq(0) div").click(), expect(c.itemSelected).toHaveBeenCalledWith(c.treedata[1].children[0].label, c.treedata[1].label, 0, !0, !1, !1, !1, !0);
        }), it("should un-select a node after second click", function() {
            c.treedata = a(2, 2), c.selectedItem = c.treedata[0], d = b('<treecontrol tree-model="treedata" selected-node="selectedItem">{{node.label}}</treecontrol>')(c), 
            c.$digest(), d.find("li:eq(0) div").click(), expect(c.selectedItem).toBeUndefined();
        }), it("should not un-select a node after second click when allowDeselect==false", function() {
            c.treeOptions = {
                allowDeselect: !1
            }, c.treedata = a(2, 2), d = b('<treecontrol tree-model="treedata" options="treeOptions" on-selection="itemSelected(node.label, selected)">{{node.label}}</treecontrol>')(c), 
            c.$digest(), c.itemSelected = jasmine.createSpy("itemSelected"), d.find("li:eq(0) div").click(), 
            d.find("li:eq(0) div").click(), expect(c.itemSelected).toHaveBeenCalledWith(c.treedata[0].label, !0), 
            expect(c.itemSelected).not.toHaveBeenCalledWith(c.treedata[0].label, !1), expect(c.itemSelected.calls.length).toBe(2);
        }), it("should retain selection after full model refresh", function() {
            var e = a(2, 2);
            c.treedata = angular.copy(e), d = b('<treecontrol tree-model="treedata">{{node.label}}</treecontrol>')(c), 
            c.$digest(), d.find("li:eq(0) div").click(), expect(d.find(".tree-selected").length).toBe(1), 
            c.treedata = angular.copy(e), c.$digest(), expect(d.find(".tree-selected").length).toBe(1);
        });
    }), describe("toggle", function() {
        it("should call on-node-toggle when node head is clicked with the expanding node and expanding indication", function() {
            c.treedata = a(2, 2), d = b('<treecontrol tree-model="treedata" on-node-toggle="nodeToggle(node.label, expanded)">{{node.label}}</treecontrol>')(c), 
            c.$digest(), c.nodeToggle = jasmine.createSpy("nodeToggle"), d.find("li:eq(1) .tree-branch-head").click(), 
            d.find("li:eq(1) .tree-branch-head").click(), expect(c.nodeToggle).toHaveBeenCalledWith(c.treedata[1].label, !0), 
            expect(c.nodeToggle).toHaveBeenCalledWith(c.treedata[1].label, !1);
        }), it("should call toggle for a child node", function() {
            c.treedata = a(3, 2), d = b('<treecontrol tree-model="treedata" on-node-toggle="nodeToggle(node.label, expanded)">{{node.label}}</treecontrol>')(c), 
            c.$digest(), c.nodeToggle = jasmine.createSpy("nodeToggle"), d.find("li:eq(1) .tree-branch-head").click(), 
            d.find("li:eq(1) li:eq(0) .tree-branch-head").click(), d.find("li:eq(1) li:eq(0) .tree-branch-head").click(), 
            expect(c.nodeToggle).toHaveBeenCalledWith(c.treedata[1].label, !0), expect(c.nodeToggle).toHaveBeenCalledWith(c.treedata[1].children[0].label, !1), 
            expect(c.nodeToggle).toHaveBeenCalledWith(c.treedata[1].children[0].label, !1);
        }), it("should support $parentNode, $first, $last, $middle, $index, $odd, $even", function() {
            c.treedata = a(2, 2), d = b('<treecontrol tree-model="treedata" on-node-toggle="nodeToggle(node.label, ($parentNode?$parentNode.label:null), $index, $first, $middle, $last, $odd, $even)">{{node.label}}</treecontrol>')(c), 
            c.$digest(), c.nodeToggle = jasmine.createSpy("nodeToggle"), d.find("li:eq(1) .tree-branch-head").click(), 
            d.find("li:eq(1) li:eq(0) .tree-branch-head").click(), d.find("li:eq(1) li:eq(0) .tree-branch-head").click(), 
            expect(c.nodeToggle).toHaveBeenCalledWith(c.treedata[1].label, null, 1, !1, !1, !0, !0, !1), 
            expect(c.nodeToggle).toHaveBeenCalledWith(c.treedata[1].children[0].label, c.treedata[1].label, 0, !0, !1, !1, !1, !0), 
            expect(c.nodeToggle).toHaveBeenCalledWith(c.treedata[1].children[0].label, c.treedata[1].label, 0, !0, !1, !1, !1, !0);
        });
    }), describe("multi-selection", function() {
        it("should publish the currently selected nodes on scope", function() {
            c.treeOptions = {
                multiSelection: !0
            }, c.treedata = a(2, 2), d = b('<treecontrol tree-model="treedata" selected-nodes="selectedItems" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest(), d.find("li:eq(0) div").click(), expect(c.selectedItems.length).toBe(1), 
            expect(c.selectedItems[0].label).toBe("node 1"), d.find("li:eq(1) div").click(), 
            expect(c.selectedItems.length).toBe(2);
        }), it("should update the tree selection if the external scope selected-node changes", function() {
            c.treeOptions = {
                multiSelection: !0
            }, c.treedata = a(2, 2), d = b('<treecontrol tree-model="treedata" selected-nodes="selectedItems" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.selectedItems = [ c.treedata[0], c.treedata[1].children[0] ], c.$digest(), expect(d.find("li:eq(0) div.tree-selected").length).toBe(1), 
            d.find("li:eq(1) .tree-branch-head").click(), expect(d.find("li:eq(1) li:eq(0) div.tree-selected").length).toBe(1);
        }), it("should invoke on-selection callback when item is selected and selected==true", function() {
            c.treeOptions = {
                multiSelection: !0
            }, c.treedata = a(2, 2), d = b('<treecontrol tree-model="treedata" on-selection="itemSelected(node.label, selected)" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest(), c.itemSelected = jasmine.createSpy("itemSelected"), d.find("li:eq(0) div").click(), 
            expect(c.itemSelected).toHaveBeenCalledWith(c.treedata[0].label, !0);
        }), it("should call on-selection callback on item unselection with the node and selected==false", function() {
            c.treeOptions = {
                multiSelection: !0
            }, c.treedata = a(2, 2), d = b('<treecontrol tree-model="treedata" on-selection="itemSelected(node.label, selected)" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest(), c.itemSelected = jasmine.createSpy("itemSelected"), d.find("li:eq(0) div").click(), 
            d.find("li:eq(0) div").click(), expect(c.itemSelected).toHaveBeenCalledWith(c.treedata[0].label, !0), 
            expect(c.itemSelected).toHaveBeenCalledWith(c.treedata[0].label, !1), expect(c.itemSelected.calls.length).toBe(2);
        }), it("should un-select a node after second click", function() {
            c.treeOptions = {
                multiSelection: !0
            }, c.treedata = a(2, 2), c.selectedItems = [ c.treedata[0] ], d = b('<treecontrol tree-model="treedata" selected-nodes="selectedItems" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest(), d.find("li:eq(0) div").click(), expect(c.selectedItems.length).toBe(0);
        }), it("should retain selection after full model refresh", function() {
            c.treeOptions = {
                multiSelection: !0
            };
            var e = a(2, 2);
            c.treedata = angular.copy(e), d = b('<treecontrol tree-model="treedata" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest(), d.find("li:eq(0) div").click(), d.find("li:eq(1) .tree-branch-head").click(), 
            d.find("li:eq(1) li:eq(0) div").click(), expect(d.find(".tree-selected").length).toBe(2), 
            c.treedata = angular.copy(e), c.$digest(), expect(d.find(".tree-selected").length).toBe(2);
        });
    }), describe("options usage", function() {
        it("should not reorder nodes if no order-by is provided", function() {
            c.treedata = [ {
                label: "a",
                children: []
            }, {
                label: "c",
                children: []
            }, {
                label: "b",
                children: []
            } ], d = b('<treecontrol tree-model="treedata" reverse-order="{{reverse}}">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0)").text()).toBe("a"), expect(d.find("li:eq(1)").text()).toBe("c"), 
            expect(d.find("li:eq(2)").text()).toBe("b");
        }), it("should order sibling nodes in normal order", function() {
            c.treedata = [ {
                label: "a",
                children: []
            }, {
                label: "c",
                children: []
            }, {
                label: "b",
                children: []
            } ], c.predicate = "label", c.reverse = !1, d = b('<treecontrol tree-model="treedata" order-by="{{predicate}}" reverse-order="{{reverse}}">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0)").text()).toBe("a"), expect(d.find("li:eq(1)").text()).toBe("b"), 
            expect(d.find("li:eq(2)").text()).toBe("c");
        }), it("should order sibling nodes in reverse order", function() {
            c.treedata = [ {
                label: "a",
                children: []
            }, {
                label: "c",
                children: []
            }, {
                label: "b",
                children: []
            } ], c.predicate = "label", c.reverse = !0, d = b('<treecontrol tree-model="treedata" order-by="{{predicate}}" reverse-order="{{reverse}}">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0)").text()).toBe("c"), expect(d.find("li:eq(1)").text()).toBe("b"), 
            expect(d.find("li:eq(2)").text()).toBe("a");
        }), it("should be able to accept alternative children variable name", function() {
            c.treedata = a(2, 2), c.treedata.push({
                kinder: [ {} ]
            }), c.treeOptions = {
                nodeChildren: "kinder"
            }, d = b('<treecontrol tree-model="treedata" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li.tree-collapsed").length).toBe(1);
        }), it("should be able to make directories not selectable", function() {
            c.treedata = a(2, 2), c.treeOptions = {
                dirSelectable: !1
            }, d = b('<treecontrol tree-model="treedata" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest(), d.find("li:eq(0) div").click(), expect(d.find("li:eq(0)").hasClass("tree-expanded")).toBeTruthy(), 
            expect(d.find(".tree-selected").length).toBe(0), d.find("li:eq(0) li:eq(0) div").click(), 
            expect(d.find(".tree-selected").length).toBe(1);
        }), it("should style unselectable nodes", function() {
            c.treedata = a(2, 2), c.treeOptions = {
                isSelectable: function(a) {
                    return !1;
                }
            }, d = b('<treecontrol tree-model="treedata" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(d.find(".tree-unselectable").length).toBe(2), d.find("li:eq(0) div").click(), 
            expect(d.find(".tree-unselectable").length).toBe(4), d.find("li:eq(0) li:eq(0) div").click(), 
            expect(d.find(".tree-unselectable").length).toBe(4);
        }), it("should not allow selection of unselectable nodes", function() {
            c.treedata = a(2, 2, ""), c.treeOptions = {
                isSelectable: function(a) {
                    return "node 1" !== a.label;
                }
            }, d = b('<treecontrol tree-model="treedata" options="treeOptions" selected-node="selected">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(c.selected).toBeUndefined("No selection initially"), d.find("li:eq(0) div").click(), 
            expect(c.selected).toBeUndefined('Clicking "node 1" should NOT change selection'), 
            d.find("li:eq(1) div").click(), expect(c.selected).toBeDefined('Clicking "node 2" should change selection');
        }), it("should be able to accept alternative equality function", function() {
            c.treedata = a(2, 2), c.treedata[0].id = "id0", c.treeOptions = {
                equality: function(a, b) {
                    return void 0 !== a && void 0 !== b && void 0 !== a.id && void 0 !== b.id && angular.equals(a.id, b.id);
                }
            }, d = b('<treecontrol tree-model="treedata" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest(), d.find("li:eq(0) .tree-branch-head").click(), expect(d.find("li:eq(0)").hasClass("tree-expanded")).toBeTruthy(), 
            c.treedata = a(2, 2), c.treedata[0].id = "id0", c.$digest(), expect(d.find("li:eq(0)").hasClass("tree-expanded")).toBeTruthy();
        }), it("should be able to accept additional class names", function() {
            c.treedata = a(2, 2), c.treeOptions = {
                injectClasses: {
                    ul: "ulcls",
                    li: "licls",
                    iExpanded: "expandcls",
                    iCollapsed: "collapsecls",
                    iLeaf: "leafcls",
                    label: "labelcls"
                }
            }, d = b('<treecontrol tree-model="treedata" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("ul.ulcls").length).toBe(1), expect(d.find("li.licls").length).toBe(2), 
            expect(d.find("li .tree-leaf-head.leafcls").length).toBe(2), expect(d.find("div.tree-label.labelcls").length).toBe(2), 
            d.find("li:eq(0) .tree-branch-head").click(), expect(d.find("li:eq(0) .tree-branch-head").hasClass("expandcls")).toBeTruthy(), 
            expect(d.find("li:eq(1) .tree-branch-head").hasClass("collapsecls")).toBeTruthy();
        }), it("should filter sibling nodes based on filter expression which is a string", function() {
            c.treedata = [ {
                label: "a",
                children: []
            }, {
                label: "c",
                children: []
            }, {
                label: "b",
                children: []
            } ], c.predicate = "b", d = b('<treecontrol tree-model="treedata" filter-expression="predicate">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0)").text()).toBe("b"), expect(d.find("li").length).toBe(1);
        }), it("should filter sibling nodes based on filter expression which is an object", function() {
            c.treedata = [ {
                label: "a",
                age: 12,
                children: []
            }, {
                label: "c",
                age: 12,
                children: []
            }, {
                label: "b",
                age: 14,
                children: []
            } ], c.predicate = {
                age: 12
            }, d = b('<treecontrol tree-model="treedata" filter-expression="predicate">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0)").text()).toBe("a"), expect(d.find("li:eq(1)").text()).toBe("c"), 
            expect(d.find("li").length).toBe(2);
        }), it("should filter sibling nodes based on filter expression which is a function", function() {
            c.treedata = [ {
                label: "a",
                age: 12,
                children: []
            }, {
                label: "c",
                age: 12,
                children: []
            }, {
                label: "b",
                age: 14,
                children: []
            } ], c.predicate = function(a) {
                return 12 == a.age;
            }, d = b('<treecontrol tree-model="treedata" filter-expression="predicate">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0)").text()).toBe("a"), expect(d.find("li:eq(1)").text()).toBe("c"), 
            expect(d.find("li").length).toBe(2);
        }), it("should filter sibling nodes based on filter expression in non prefix match", function() {
            c.treedata = [ {
                label: "abcd",
                age: 12,
                children: []
            }, {
                label: "abef",
                age: 12,
                children: []
            }, {
                label: "bcde",
                age: 14,
                children: []
            } ], c.predicate = "ab", c.comparator = !1, d = b('<treecontrol tree-model="treedata" filter-expression="predicate" filter-comparator="comparator">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li:eq(0)").text()).toBe("abcd"), expect(d.find("li:eq(1)").text()).toBe("abef"), 
            expect(d.find("li").length).toBe(2);
        }), it("should filter sibling nodes based on filter expression in non prefix match", function() {
            c.treedata = [ {
                label: "abcd",
                age: 12,
                children: []
            }, {
                label: "abef",
                age: 12,
                children: []
            }, {
                label: "bcde",
                age: 14,
                children: []
            } ], c.predicate = "ab", c.comparator = !0, d = b('<treecontrol tree-model="treedata" filter-expression="predicate" filter-comparator="comparator">{{node.label}}</treecontrol>')(c), 
            c.$digest(), expect(d.find("li").length).toBe(0), c.predicate = "abcd", c.$digest(), 
            expect(d.find("li:eq(0)").text()).toBe("abcd"), expect(d.find("li").length).toBe(1);
        });
    }), describe("customizations", function() {
        beforeEach(function() {
            c.treedata = a(2, 2), c.treedata.push({}), c.treeOptions = {
                injectClasses: {
                    ul: "ulClass",
                    li: "liClass",
                    liSelected: "liSelectedClass",
                    iExpanded: "iExpandClass",
                    iCollapsed: "iCollapsedClass",
                    iLeaf: "iLeafClass",
                    label: "labelClass",
                    labelSelected: "labelSelectedClass"
                }
            }, d = b('<treecontrol tree-model="treedata" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest();
        }), it("should render the ulClass on the ul Element", function() {
            expect(d.find("ul").hasClass("ulClass")).toBeTruthy();
        }), it("should render the liClass on the li Element", function() {
            expect(d.find("li").hasClass("liClass")).toBeTruthy();
        }), it("should not render the liSelectedClass initially on the li Element", function() {
            expect(d.find("li:eq(0)").hasClass("liSelectedClass")).toBeFalsy();
        }), it("should render the liSelectedClass on the a selected li Element", function() {
            d.find("li:eq(0) div").click(), expect(d.find("li:eq(0)").hasClass("liSelectedClass")).toBeTruthy();
        }), it("should render the iCollapsedClass on the i head element when collapsed", function() {
            expect(d.find("li:eq(0) i:eq(0)").hasClass("iCollapsedClass")).toBeTruthy();
        }), it("should render the iLeafClass on leafs", function() {
            expect(d.find("li:eq(2) i:eq(1)").hasClass("iLeafClass")).toBeTruthy();
        }), it("should render the iExpandClass on expanded nodes", function() {
            d.find("li:eq(0) .tree-branch-head").click(), expect(d.find("li:eq(0) i:eq(0)").hasClass("iExpandClass")).toBeTruthy();
        }), it("should render the labelClass on the label div element", function() {
            expect(d.find("li:eq(0) div").hasClass("labelClass")).toBeTruthy();
        }), it("should not render the labelSelectedClass on the label div element when it is not selected", function() {
            expect(d.find("li:eq(0) div").hasClass("labelSelectedClass")).toBeFalsy();
        }), it("should render the labelSelectedClass on the label div element when it is selected", function() {
            d.find("li:eq(0) div").click(), expect(d.find("li:eq(0) div").hasClass("labelSelectedClass")).toBeTruthy();
        });
    }), describe("expanded-nodes binding", function() {
        beforeEach(function() {
            c.treedata = a(3, 2), c.expandedNodes = [ c.treedata[1], c.treedata[1].children[1] ], 
            d = b('<treecontrol tree-model="treedata" expanded-nodes="expandedNodes" options="treeOptions">{{node.label}}</treecontrol>')(c), 
            c.$digest();
        }), it("should be used for default expansion of nodes", function() {
            expect(d.find("li:eq(0)").hasClass("tree-collapsed")).toBeTruthy(), expect(d.find("li:eq(1)").hasClass("tree-expanded")).toBeTruthy(), 
            expect(d.find("li:eq(1) li:eq(0)").hasClass("tree-collapsed")).toBeTruthy(), expect(d.find("li:eq(1) li:eq(1)").hasClass("tree-expanded")).toBeTruthy();
        }), it("should update the tree as expandedNodes changes", function() {
            c.expandedNodes = [ c.treedata[0] ], c.$digest(), expect(d.find("li:eq(0)").hasClass("tree-expanded")).toBeTruthy(), 
            expect(d.find("li:eq(1)").hasClass("tree-collapsed")).toBeTruthy();
        }), it("should add to expandedNodes expanding node", function() {
            d.find("li:eq(0) .tree-branch-head").click(), expect(c.expandedNodes).toContain(c.treedata[0]);
        }), it("should remove from expandedNodes collapsing node", function() {
            d.find("li:eq(1) .tree-branch-head").click(), expect(c.expandedNodes).not.toContain(c.treedata[1]);
        }), it("should retain expansions after full model refresh", function() {
            var e = a(2, 2);
            c.treedata = angular.copy(e), d = b('<treecontrol tree-model="treedata">{{node.label}}</treecontrol>')(c), 
            c.$digest(), d.find("li:eq(0) .tree-branch-head").click(), expect(d.find("li:eq(0)").hasClass("tree-expanded")).toBeTruthy(), 
            c.treedata = angular.copy(e), c.$digest(), expect(d.find("li:eq(0)").hasClass("tree-expanded")).toBeTruthy();
        });
    });
});
//# sourceMappingURL=angular-tree-control-test.min.js.map
/*! 康美网络医院 最后修改于： 2016-10-20 */