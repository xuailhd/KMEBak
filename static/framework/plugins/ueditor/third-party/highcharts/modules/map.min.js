!function(a) {
    function b(a, b, c) {
        for (var d = 4, e = []; d--; ) e[d] = Math.round(b.rgba[d] + (a.rgba[d] - b.rgba[d]) * (1 - c));
        return "rgba(" + e.join(",") + ")";
    }
    var c = a.Axis, d = a.Chart, e = a.Point, f = a.Pointer, g = a.each, h = a.extend, i = a.merge, j = a.pick, k = a.numberFormat, l = a.getOptions(), m = a.seriesTypes, n = l.plotOptions, o = a.wrap, p = a.Color, q = function() {};
    l.mapNavigation = {
        buttonOptions: {
            align: "right",
            verticalAlign: "bottom",
            x: 0,
            width: 18,
            height: 18,
            style: {
                fontSize: "15px",
                fontWeight: "bold",
                textAlign: "center"
            }
        },
        buttons: {
            zoomIn: {
                onclick: function() {
                    this.mapZoom(.5);
                },
                text: "+",
                y: -32
            },
            zoomOut: {
                onclick: function() {
                    this.mapZoom(2);
                },
                text: "-",
                y: 0
            }
        }
    }, a.splitPath = function(a) {
        var b, a = a.replace(/([A-Za-z])/g, " $1 "), a = a.replace(/^\s*/, "").replace(/\s*$/, ""), a = a.split(/[ ,]+/);
        for (b = 0; b < a.length; b++) /[a-zA-Z]/.test(a[b]) || (a[b] = parseFloat(a[b]));
        return a;
    }, a.maps = {}, o(c.prototype, "getSeriesExtremes", function(a) {
        var b, c, d = this.isXAxis, e = [];
        g(this.series, function(a, b) {
            a.useMapGeometry && (e[b] = a.xData, a.xData = []);
        }), a.call(this), b = j(this.dataMin, Number.MAX_VALUE), c = j(this.dataMax, Number.MIN_VALUE), 
        g(this.series, function(a, f) {
            a.useMapGeometry && (b = Math.min(b, a[d ? "minX" : "minY"]), c = Math.max(c, a[d ? "maxX" : "maxY"]), 
            a.xData = e[f]);
        }), this.dataMin = b, this.dataMax = c;
    }), o(c.prototype, "setAxisTranslation", function(a) {
        var b = this.chart, c = b.plotWidth / b.plotHeight, d = this.isXAxis, e = b.xAxis[0];
        a.call(this), "map" !== b.options.chart.type || d || void 0 === e.transA || (this.transA = e.transA = Math.min(this.transA, e.transA), 
        a = (e.max - e.min) / (this.max - this.min), e = a > c ? this : e, c = (e.max - e.min) * e.transA, 
        e.minPixelPadding = (e.len - c) / 2);
    }), o(d.prototype, "render", function(b) {
        var c = this, d = c.options.mapNavigation;
        b.call(c), c.renderMapNavigation(), d.zoomOnDoubleClick && a.addEvent(c.container, "dblclick", function(a) {
            c.pointer.onContainerDblClick(a);
        }), d.zoomOnMouseWheel && a.addEvent(c.container, void 0 === document.onmousewheel ? "DOMMouseScroll" : "mousewheel", function(a) {
            c.pointer.onContainerMouseWheel(a);
        });
    }), h(f.prototype, {
        onContainerDblClick: function(a) {
            var b = this.chart, a = this.normalize(a);
            b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) && b.mapZoom(.5, b.xAxis[0].toValue(a.chartX), b.yAxis[0].toValue(a.chartY));
        },
        onContainerMouseWheel: function(a) {
            var b, c = this.chart, a = this.normalize(a);
            b = a.detail || -(a.wheelDelta / 120), c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop) && c.mapZoom(b > 0 ? 2 : .5, c.xAxis[0].toValue(a.chartX), c.yAxis[0].toValue(a.chartY));
        }
    }), o(f.prototype, "init", function(a, b, c) {
        a.call(this, b, c), c.mapNavigation.enableTouchZoom && (this.pinchX = this.pinchHor = this.pinchY = this.pinchVert = !0);
    }), h(d.prototype, {
        renderMapNavigation: function() {
            var a, b, c, d = this, e = this.options.mapNavigation, f = e.buttons, g = function() {
                this.handler.call(d);
            };
            if (e.enableButtons) for (a in f) f.hasOwnProperty(a) && (c = i(e.buttonOptions, f[a]), 
            b = d.renderer.button(c.text, 0, 0, g).attr({
                width: c.width,
                height: c.height
            }).css(c.style).add(), b.handler = c.onclick, b.align(h(c, {
                width: b.width,
                height: b.height
            }), null, "spacingBox"));
        },
        fitToBox: function(a, b) {
            return g([ [ "x", "width" ], [ "y", "height" ] ], function(c) {
                var d = c[0], c = c[1];
                a[d] + a[c] > b[d] + b[c] && (a[c] > b[c] ? (a[c] = b[c], a[d] = b[d]) : a[d] = b[d] + b[c] - a[c]), 
                a[c] > b[c] && (a[c] = b[c]), a[d] < b[d] && (a[d] = b[d]);
            }), a;
        },
        mapZoom: function(a, b, c) {
            if (!this.isMapZooming) {
                var d = this, e = d.xAxis[0], f = e.max - e.min, g = j(b, e.min + f / 2), b = f * a, f = d.yAxis[0], h = f.max - f.min, c = j(c, f.min + h / 2);
                a *= h, g -= b / 2, h = c - a / 2, c = j(d.options.chart.animation, !0), b = d.fitToBox({
                    x: g,
                    y: h,
                    width: b,
                    height: a
                }, {
                    x: e.dataMin,
                    y: f.dataMin,
                    width: e.dataMax - e.dataMin,
                    height: f.dataMax - f.dataMin
                }), e.setExtremes(b.x, b.x + b.width, !1), f.setExtremes(b.y, b.y + b.height, !1), 
                (e = c ? c.duration || 500 : 0) && (d.isMapZooming = !0, setTimeout(function() {
                    d.isMapZooming = !1;
                }, e)), d.redraw();
            }
        }
    }), n.map = i(n.scatter, {
        animation: !1,
        nullColor: "#F8F8F8",
        borderColor: "silver",
        borderWidth: 1,
        marker: null,
        stickyTracking: !1,
        dataLabels: {
            verticalAlign: "middle"
        },
        turboThreshold: 0,
        tooltip: {
            followPointer: !0,
            pointFormat: "{point.name}: {point.y}<br/>"
        },
        states: {
            normal: {
                animation: !0
            }
        }
    }), c = a.extendClass(e, {
        applyOptions: function(b, c) {
            var d = e.prototype.applyOptions.call(this, b, c);
            return d.path && "string" == typeof d.path && (d.path = d.options.path = a.splitPath(d.path)), 
            d;
        },
        onMouseOver: function() {
            clearTimeout(this.colorInterval), e.prototype.onMouseOver.call(this);
        },
        onMouseOut: function() {
            var a = this, c = +new Date(), d = p(a.options.color), f = p(a.pointAttr.hover.fill), g = a.series.options.states.normal.animation, h = g && (g.duration || 500);
            h && 4 === d.rgba.length && 4 === f.rgba.length && (delete a.pointAttr[""].fill, 
            clearTimeout(a.colorInterval), a.colorInterval = setInterval(function() {
                var e = (new Date() - c) / h, g = a.graphic;
                e > 1 && (e = 1), g && g.attr("fill", b(f, d, e)), e >= 1 && clearTimeout(a.colorInterval);
            }, 13)), e.prototype.onMouseOut.call(a);
        }
    }), m.map = a.extendClass(m.scatter, {
        type: "map",
        pointAttrToOptions: {
            stroke: "borderColor",
            "stroke-width": "borderWidth",
            fill: "color"
        },
        colorKey: "y",
        pointClass: c,
        trackerGroups: [ "group", "markerGroup", "dataLabelsGroup" ],
        getSymbol: q,
        supportsDrilldown: !0,
        getExtremesFromAll: !0,
        useMapGeometry: !0,
        init: function(b) {
            var c, d, e, f, h, i, j, l = this, n = b.options.legend.valueDecimals, o = [];
            i = "horizontal" === b.options.legend.layout, a.Series.prototype.init.apply(this, arguments), 
            h = l.options.colorRange, (f = l.options.valueRanges) ? (g(f, function(b) {
                d = b.from, e = b.to, c = "", void 0 === d ? c = "< " : void 0 === e && (c = "> "), 
                void 0 !== d && (c += k(d, n)), void 0 !== d && void 0 !== e && (c += " - "), void 0 !== e && (c += k(e, n)), 
                o.push(a.extend({
                    chart: l.chart,
                    name: c,
                    options: {},
                    drawLegendSymbol: m.area.prototype.drawLegendSymbol,
                    visible: !0,
                    setState: function() {},
                    setVisible: function() {}
                }, b));
            }), l.legendItems = o) : h && (d = h.from, e = h.to, f = h.fromLabel, h = h.toLabel, 
            j = i ? [ 0, 0, 1, 0 ] : [ 0, 1, 0, 0 ], i || (i = f, f = h, h = i), i = {
                linearGradient: {
                    x1: j[0],
                    y1: j[1],
                    x2: j[2],
                    y2: j[3]
                },
                stops: [ [ 0, d ], [ 1, e ] ]
            }, o = [ {
                chart: l.chart,
                options: {},
                fromLabel: f,
                toLabel: h,
                color: i,
                drawLegendSymbol: this.drawLegendSymbolGradient,
                visible: !0,
                setState: function() {},
                setVisible: function() {}
            } ], l.legendItems = o);
        },
        drawLegendSymbol: m.area.prototype.drawLegendSymbol,
        drawLegendSymbolGradient: function(a, b) {
            var c, d, e, f = a.options.symbolPadding, g = j(a.options.padding, 8), h = this.chart.renderer.fontMetrics(a.options.itemStyle.fontSize).h, i = "horizontal" === a.options.layout;
            e = j(a.options.rectangleLength, 200), i ? (c = -(f / 2), d = 0) : (c = -e + a.baseline - f / 2, 
            d = g + h), b.fromText = this.chart.renderer.text(b.fromLabel, d, c).attr({
                zIndex: 2
            }).add(b.legendGroup), d = b.fromText.getBBox(), b.legendSymbol = this.chart.renderer.rect(i ? d.x + d.width + f : d.x - h - f, d.y, i ? e : h, i ? h : e, 2).attr({
                zIndex: 1
            }).add(b.legendGroup), e = b.legendSymbol.getBBox(), b.toText = this.chart.renderer.text(b.toLabel, e.x + e.width + f, i ? c : e.y + e.height - f).attr({
                zIndex: 2
            }).add(b.legendGroup), c = b.toText.getBBox(), i ? (a.offsetWidth = d.width + e.width + c.width + 2 * f + g, 
            a.itemY = h + g) : (a.offsetWidth = Math.max(d.width, c.width) + f + e.width + g, 
            a.itemY = e.height + g, a.itemX = f);
        },
        getBox: function(a) {
            var b = Number.MIN_VALUE, c = Number.MAX_VALUE, d = Number.MIN_VALUE, e = Number.MAX_VALUE;
            g(a || this.options.data, function(a) {
                for (var f = a.path, g = f.length, h = !1, i = Number.MIN_VALUE, j = Number.MAX_VALUE, k = Number.MIN_VALUE, l = Number.MAX_VALUE; g--; ) "number" == typeof f[g] && !isNaN(f[g]) && (h ? (i = Math.max(i, f[g]), 
                j = Math.min(j, f[g])) : (k = Math.max(k, f[g]), l = Math.min(l, f[g])), h = !h);
                a._maxX = i, a._minX = j, a._maxY = k, a._minY = l, b = Math.max(b, i), c = Math.min(c, j), 
                d = Math.max(d, k), e = Math.min(e, l);
            }), this.minY = e, this.maxY = d, this.minX = c, this.maxX = b;
        },
        translatePath: function(a) {
            var b, c = !1, d = this.xAxis, e = this.yAxis, a = [].concat(a);
            for (b = a.length; b--; ) "number" == typeof a[b] && (a[b] = c ? Math.round(d.translate(a[b])) : Math.round(e.len - e.translate(a[b])), 
            c = !c);
            return a;
        },
        setData: function() {
            a.Series.prototype.setData.apply(this, arguments), this.getBox();
        },
        translate: function() {
            var a = this, b = Number.MAX_VALUE, c = Number.MIN_VALUE;
            a.generatePoints(), g(a.data, function(d) {
                d.shapeType = "path", d.shapeArgs = {
                    d: a.translatePath(d.path)
                }, "number" == typeof d.y && (d.y > c ? c = d.y : d.y < b && (b = d.y));
            }), a.translateColors(b, c);
        },
        translateColors: function(a, c) {
            var d, e, f = this.options, h = f.valueRanges, i = f.colorRange, j = this.colorKey;
            i && (d = p(i.from), e = p(i.to)), g(this.data, function(g) {
                var k, l, m, n = g[j];
                if (h) {
                    for (m = h.length; m--; ) if (k = h[m], d = k.from, e = k.to, (void 0 === d || n >= d) && (void 0 === e || n <= e)) {
                        l = k.color;
                        break;
                    }
                } else i && void 0 !== n && (k = 1 - (c - n) / (c - a), l = null === n ? f.nullColor : b(d, e, k));
                l && (g.color = null, g.options.color = l);
            });
        },
        drawGraph: q,
        drawDataLabels: q,
        drawPoints: function() {
            var b = this.xAxis, c = this.yAxis, d = this.colorKey;
            g(this.data, function(a) {
                a.plotY = 1, null === a[d] && (a[d] = 0, a.isNull = !0);
            }), m.column.prototype.drawPoints.apply(this), g(this.data, function(a) {
                var e = a.dataLabels, f = b.toPixels(a._minX, !0), g = b.toPixels(a._maxX, !0), h = c.toPixels(a._minY, !0), i = c.toPixels(a._maxY, !0);
                a.plotX = Math.round(f + (g - f) * j(e && e.anchorX, .5)), a.plotY = Math.round(h + (i - h) * j(e && e.anchorY, .5)), 
                a.isNull && (a[d] = null);
            }), a.Series.prototype.drawDataLabels.call(this);
        },
        animateDrilldown: function(a) {
            var b = this.chart.plotBox, c = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1], d = c.bBox, e = this.chart.options.drilldown.animation;
            a || (a = Math.min(d.width / b.width, d.height / b.height), c.shapeArgs = {
                scaleX: a,
                scaleY: a,
                translateX: d.x,
                translateY: d.y
            }, g(this.points, function(a) {
                a.graphic.attr(c.shapeArgs).animate({
                    scaleX: 1,
                    scaleY: 1,
                    translateX: 0,
                    translateY: 0
                }, e);
            }), delete this.animate);
        },
        animateDrillupFrom: function(a) {
            m.column.prototype.animateDrillupFrom.call(this, a);
        },
        animateDrillupTo: function(a) {
            m.column.prototype.animateDrillupTo.call(this, a);
        }
    }), n.mapline = i(n.map, {
        lineWidth: 1,
        backgroundColor: "none"
    }), m.mapline = a.extendClass(m.map, {
        type: "mapline",
        pointAttrToOptions: {
            stroke: "color",
            "stroke-width": "lineWidth",
            fill: "backgroundColor"
        },
        drawLegendSymbol: m.line.prototype.drawLegendSymbol
    }), n.mappoint = i(n.scatter, {
        dataLabels: {
            enabled: !0,
            format: "{point.name}",
            color: "black",
            style: {
                textShadow: "0 0 5px white"
            }
        }
    }), m.mappoint = a.extendClass(m.scatter, {
        type: "mappoint"
    }), a.Map = function(b, c) {
        var d, e = {
            endOnTick: !1,
            gridLineWidth: 0,
            labels: {
                enabled: !1
            },
            lineWidth: 0,
            minPadding: 0,
            maxPadding: 0,
            startOnTick: !1,
            tickWidth: 0,
            title: null
        };
        return d = b.series, b.series = null, b = i({
            chart: {
                type: "map",
                panning: "xy"
            },
            xAxis: e,
            yAxis: i(e, {
                reversed: !0
            })
        }, b, {
            chart: {
                inverted: !1
            }
        }), b.series = d, new a.Chart(b, c);
    };
}(Highcharts), function(a) {
    function b(a, b, c) {
        for (var d = 4, e = []; d--; ) e[d] = Math.round(b.rgba[d] + (a.rgba[d] - b.rgba[d]) * (1 - c));
        return "rgba(" + e.join(",") + ")";
    }
    var c, d = a.Axis, e = a.Chart, f = a.Point, g = a.Pointer, h = a.each, i = a.extend, j = a.merge, k = a.pick, l = a.numberFormat, m = a.getOptions(), n = a.seriesTypes, o = m.plotOptions, p = a.wrap, q = a.Color, r = function() {};
    m.mapNavigation = {
        buttonOptions: {
            align: "right",
            verticalAlign: "bottom",
            x: 0,
            width: 18,
            height: 18,
            style: {
                fontSize: "15px",
                fontWeight: "bold",
                textAlign: "center"
            }
        },
        buttons: {
            zoomIn: {
                onclick: function() {
                    this.mapZoom(.5);
                },
                text: "+",
                y: -32
            },
            zoomOut: {
                onclick: function() {
                    this.mapZoom(2);
                },
                text: "-",
                y: 0
            }
        }
    }, a.splitPath = function(a) {
        var b;
        for (a = a.replace(/([A-Za-z])/g, " $1 "), a = a.replace(/^\s*/, "").replace(/\s*$/, ""), 
        a = a.split(/[ ,]+/), b = 0; b < a.length; b++) /[a-zA-Z]/.test(a[b]) || (a[b] = parseFloat(a[b]));
        return a;
    }, a.maps = {}, p(d.prototype, "getSeriesExtremes", function(a) {
        var b, c, d = this.isXAxis, e = [];
        h(this.series, function(a, b) {
            a.useMapGeometry && (e[b] = a.xData, a.xData = []);
        }), a.call(this), b = k(this.dataMin, Number.MAX_VALUE), c = k(this.dataMax, Number.MIN_VALUE), 
        h(this.series, function(a, f) {
            a.useMapGeometry && (b = Math.min(b, a[d ? "minX" : "minY"]), c = Math.max(c, a[d ? "maxX" : "maxY"]), 
            a.xData = e[f]);
        }), this.dataMin = b, this.dataMax = c;
    }), p(d.prototype, "setAxisTranslation", function(a) {
        var b, d, e, f = this.chart, g = f.plotWidth / f.plotHeight, h = this.isXAxis, i = f.xAxis[0];
        a.call(this), "map" !== f.options.chart.type || h || i.transA === c || (this.transA = i.transA = Math.min(this.transA, i.transA), 
        b = (i.max - i.min) / (this.max - this.min), e = b > g ? this : i, d = (e.max - e.min) * e.transA, 
        e.minPixelPadding = (e.len - d) / 2);
    }), p(e.prototype, "render", function(b) {
        var c = this, d = c.options.mapNavigation;
        b.call(c), c.renderMapNavigation(), d.zoomOnDoubleClick && a.addEvent(c.container, "dblclick", function(a) {
            c.pointer.onContainerDblClick(a);
        }), d.zoomOnMouseWheel && a.addEvent(c.container, void 0 === document.onmousewheel ? "DOMMouseScroll" : "mousewheel", function(a) {
            c.pointer.onContainerMouseWheel(a);
        });
    }), i(g.prototype, {
        onContainerDblClick: function(a) {
            var b = this.chart;
            a = this.normalize(a), b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) && b.mapZoom(.5, b.xAxis[0].toValue(a.chartX), b.yAxis[0].toValue(a.chartY));
        },
        onContainerMouseWheel: function(a) {
            var b, c = this.chart;
            a = this.normalize(a), b = a.detail || -(a.wheelDelta / 120), c.isInsidePlot(a.chartX - c.plotLeft, a.chartY - c.plotTop) && c.mapZoom(b > 0 ? 2 : .5, c.xAxis[0].toValue(a.chartX), c.yAxis[0].toValue(a.chartY));
        }
    }), p(g.prototype, "init", function(a, b, c) {
        a.call(this, b, c), c.mapNavigation.enableTouchZoom && (this.pinchX = this.pinchHor = this.pinchY = this.pinchVert = !0);
    }), i(e.prototype, {
        renderMapNavigation: function() {
            var a, b, c, d = this, e = this.options.mapNavigation, f = e.buttons, g = function() {
                this.handler.call(d);
            };
            if (e.enableButtons) for (a in f) f.hasOwnProperty(a) && (c = j(e.buttonOptions, f[a]), 
            b = d.renderer.button(c.text, 0, 0, g).attr({
                width: c.width,
                height: c.height
            }).css(c.style).add(), b.handler = c.onclick, b.align(i(c, {
                width: b.width,
                height: b.height
            }), null, "spacingBox"));
        },
        fitToBox: function(a, b) {
            return h([ [ "x", "width" ], [ "y", "height" ] ], function(c) {
                var d = c[0], e = c[1];
                a[d] + a[e] > b[d] + b[e] && (a[e] > b[e] ? (a[e] = b[e], a[d] = b[d]) : a[d] = b[d] + b[e] - a[e]), 
                a[e] > b[e] && (a[e] = b[e]), a[d] < b[d] && (a[d] = b[d]);
            }), a;
        },
        mapZoom: function(a, b, c) {
            if (!this.isMapZooming) {
                var d, e = this, f = e.xAxis[0], g = f.max - f.min, h = k(b, f.min + g / 2), i = g * a, j = e.yAxis[0], l = j.max - j.min, m = k(c, j.min + l / 2), n = l * a, o = h - i / 2, p = m - n / 2, q = k(e.options.chart.animation, !0), r = e.fitToBox({
                    x: o,
                    y: p,
                    width: i,
                    height: n
                }, {
                    x: f.dataMin,
                    y: j.dataMin,
                    width: f.dataMax - f.dataMin,
                    height: j.dataMax - j.dataMin
                });
                f.setExtremes(r.x, r.x + r.width, !1), j.setExtremes(r.y, r.y + r.height, !1), d = q ? q.duration || 500 : 0, 
                d && (e.isMapZooming = !0, setTimeout(function() {
                    e.isMapZooming = !1;
                }, d)), e.redraw();
            }
        }
    }), o.map = j(o.scatter, {
        animation: !1,
        nullColor: "#F8F8F8",
        borderColor: "silver",
        borderWidth: 1,
        marker: null,
        stickyTracking: !1,
        dataLabels: {
            verticalAlign: "middle"
        },
        turboThreshold: 0,
        tooltip: {
            followPointer: !0,
            pointFormat: "{point.name}: {point.y}<br/>"
        },
        states: {
            normal: {
                animation: !0
            }
        }
    });
    var s = a.extendClass(f, {
        applyOptions: function(b, c) {
            var d = f.prototype.applyOptions.call(this, b, c);
            return d.path && "string" == typeof d.path && (d.path = d.options.path = a.splitPath(d.path)), 
            d;
        },
        onMouseOver: function() {
            clearTimeout(this.colorInterval), f.prototype.onMouseOver.call(this);
        },
        onMouseOut: function() {
            var a = this, c = +new Date(), d = q(a.options.color), e = q(a.pointAttr.hover.fill), g = a.series.options.states.normal.animation, h = g && (g.duration || 500);
            h && 4 === d.rgba.length && 4 === e.rgba.length && (delete a.pointAttr[""].fill, 
            clearTimeout(a.colorInterval), a.colorInterval = setInterval(function() {
                var f = (new Date() - c) / h, g = a.graphic;
                f > 1 && (f = 1), g && g.attr("fill", b(e, d, f)), f >= 1 && clearTimeout(a.colorInterval);
            }, 13)), f.prototype.onMouseOut.call(a);
        }
    });
    n.map = a.extendClass(n.scatter, {
        type: "map",
        pointAttrToOptions: {
            stroke: "borderColor",
            "stroke-width": "borderWidth",
            fill: "color"
        },
        colorKey: "y",
        pointClass: s,
        trackerGroups: [ "group", "markerGroup", "dataLabelsGroup" ],
        getSymbol: r,
        supportsDrilldown: !0,
        getExtremesFromAll: !0,
        useMapGeometry: !0,
        init: function(b) {
            var d, e, f, g, i, j, k, m, o, p, q = this, r = b.options.legend.valueDecimals, s = [], t = "horizontal" === b.options.legend.layout;
            a.Series.prototype.init.apply(this, arguments), j = q.options.colorRange, k = q.options.valueRanges, 
            k ? (h(k, function(b) {
                e = b.from, f = b.to, d = "", e === c ? d = "< " : f === c && (d = "> "), e !== c && (d += l(e, r)), 
                e !== c && f !== c && (d += " - "), f !== c && (d += l(f, r)), s.push(a.extend({
                    chart: q.chart,
                    name: d,
                    options: {},
                    drawLegendSymbol: n.area.prototype.drawLegendSymbol,
                    visible: !0,
                    setState: function() {},
                    setVisible: function() {}
                }, b));
            }), q.legendItems = s) : j && (e = j.from, f = j.to, g = j.fromLabel, i = j.toLabel, 
            o = t ? [ 0, 0, 1, 0 ] : [ 0, 1, 0, 0 ], t || (p = g, g = i, i = p), m = {
                linearGradient: {
                    x1: o[0],
                    y1: o[1],
                    x2: o[2],
                    y2: o[3]
                },
                stops: [ [ 0, e ], [ 1, f ] ]
            }, s = [ {
                chart: q.chart,
                options: {},
                fromLabel: g,
                toLabel: i,
                color: m,
                drawLegendSymbol: this.drawLegendSymbolGradient,
                visible: !0,
                setState: function() {},
                setVisible: function() {}
            } ], q.legendItems = s);
        },
        drawLegendSymbol: n.area.prototype.drawLegendSymbol,
        drawLegendSymbolGradient: function(a, b) {
            var c, d, e, f, g, h = a.options.symbolPadding, i = k(a.options.padding, 8), j = this.chart.renderer.fontMetrics(a.options.itemStyle.fontSize).h, l = "horizontal" === a.options.layout, m = k(a.options.rectangleLength, 200);
            l ? (c = -(h / 2), d = 0) : (c = -m + a.baseline - h / 2, d = i + j), b.fromText = this.chart.renderer.text(b.fromLabel, d, c).attr({
                zIndex: 2
            }).add(b.legendGroup), e = b.fromText.getBBox(), b.legendSymbol = this.chart.renderer.rect(l ? e.x + e.width + h : e.x - j - h, e.y, l ? m : j, l ? j : m, 2).attr({
                zIndex: 1
            }).add(b.legendGroup), f = b.legendSymbol.getBBox(), b.toText = this.chart.renderer.text(b.toLabel, f.x + f.width + h, l ? c : f.y + f.height - h).attr({
                zIndex: 2
            }).add(b.legendGroup), g = b.toText.getBBox(), l ? (a.offsetWidth = e.width + f.width + g.width + 2 * h + i, 
            a.itemY = j + i) : (a.offsetWidth = Math.max(e.width, g.width) + h + f.width + i, 
            a.itemY = f.height + i, a.itemX = h);
        },
        getBox: function(a) {
            var b = Number.MIN_VALUE, c = Number.MAX_VALUE, d = Number.MIN_VALUE, e = Number.MAX_VALUE;
            h(a || this.options.data, function(a) {
                for (var f = a.path, g = f.length, h = !1, i = Number.MIN_VALUE, j = Number.MAX_VALUE, k = Number.MIN_VALUE, l = Number.MAX_VALUE; g--; ) "number" != typeof f[g] || isNaN(f[g]) || (h ? (i = Math.max(i, f[g]), 
                j = Math.min(j, f[g])) : (k = Math.max(k, f[g]), l = Math.min(l, f[g])), h = !h);
                a._maxX = i, a._minX = j, a._maxY = k, a._minY = l, b = Math.max(b, i), c = Math.min(c, j), 
                d = Math.max(d, k), e = Math.min(e, l);
            }), this.minY = e, this.maxY = d, this.minX = c, this.maxX = b;
        },
        translatePath: function(a) {
            var b, c = this, d = !1, e = c.xAxis, f = c.yAxis;
            for (a = [].concat(a), b = a.length; b--; ) "number" == typeof a[b] && (d ? a[b] = Math.round(e.translate(a[b])) : a[b] = Math.round(f.len - f.translate(a[b])), 
            d = !d);
            return a;
        },
        setData: function() {
            a.Series.prototype.setData.apply(this, arguments), this.getBox();
        },
        translate: function() {
            var a = this, b = Number.MAX_VALUE, c = Number.MIN_VALUE;
            a.generatePoints(), h(a.data, function(d) {
                d.shapeType = "path", d.shapeArgs = {
                    d: a.translatePath(d.path)
                }, "number" == typeof d.y && (d.y > c ? c = d.y : d.y < b && (b = d.y));
            }), a.translateColors(b, c);
        },
        translateColors: function(a, d) {
            var e, f, g = this.options, i = g.valueRanges, j = g.colorRange, k = this.colorKey;
            j && (e = q(j.from), f = q(j.to)), h(this.data, function(h) {
                var l, m, n, o, p = h[k];
                if (i) {
                    for (n = i.length; n--; ) if (l = i[n], e = l.from, f = l.to, (e === c || p >= e) && (f === c || p <= f)) {
                        m = l.color;
                        break;
                    }
                } else j && void 0 !== p && (o = 1 - (d - p) / (d - a), m = null === p ? g.nullColor : b(e, f, o));
                m && (h.color = null, h.options.color = m);
            });
        },
        drawGraph: r,
        drawDataLabels: r,
        drawPoints: function() {
            var b = this, c = b.xAxis, d = b.yAxis, e = b.colorKey;
            h(b.data, function(a) {
                a.plotY = 1, null === a[e] && (a[e] = 0, a.isNull = !0);
            }), n.column.prototype.drawPoints.apply(b), h(b.data, function(a) {
                var b = a.dataLabels, f = c.toPixels(a._minX, !0), g = c.toPixels(a._maxX, !0), h = d.toPixels(a._minY, !0), i = d.toPixels(a._maxY, !0);
                a.plotX = Math.round(f + (g - f) * k(b && b.anchorX, .5)), a.plotY = Math.round(h + (i - h) * k(b && b.anchorY, .5)), 
                a.isNull && (a[e] = null);
            }), a.Series.prototype.drawDataLabels.call(b);
        },
        animateDrilldown: function(a) {
            var b, c = this.chart.plotBox, d = this.chart.drilldownLevels[this.chart.drilldownLevels.length - 1], e = d.bBox, f = this.chart.options.drilldown.animation;
            a || (b = Math.min(e.width / c.width, e.height / c.height), d.shapeArgs = {
                scaleX: b,
                scaleY: b,
                translateX: e.x,
                translateY: e.y
            }, h(this.points, function(a) {
                a.graphic.attr(d.shapeArgs).animate({
                    scaleX: 1,
                    scaleY: 1,
                    translateX: 0,
                    translateY: 0
                }, f);
            }), delete this.animate);
        },
        animateDrillupFrom: function(a) {
            n.column.prototype.animateDrillupFrom.call(this, a);
        },
        animateDrillupTo: function(a) {
            n.column.prototype.animateDrillupTo.call(this, a);
        }
    }), o.mapline = j(o.map, {
        lineWidth: 1,
        backgroundColor: "none"
    }), n.mapline = a.extendClass(n.map, {
        type: "mapline",
        pointAttrToOptions: {
            stroke: "color",
            "stroke-width": "lineWidth",
            fill: "backgroundColor"
        },
        drawLegendSymbol: n.line.prototype.drawLegendSymbol
    }), o.mappoint = j(o.scatter, {
        dataLabels: {
            enabled: !0,
            format: "{point.name}",
            color: "black",
            style: {
                textShadow: "0 0 5px white"
            }
        }
    }), n.mappoint = a.extendClass(n.scatter, {
        type: "mappoint"
    }), a.Map = function(b, c) {
        var d, e = {
            endOnTick: !1,
            gridLineWidth: 0,
            labels: {
                enabled: !1
            },
            lineWidth: 0,
            minPadding: 0,
            maxPadding: 0,
            startOnTick: !1,
            tickWidth: 0,
            title: null
        };
        return d = b.series, b.series = null, b = j({
            chart: {
                type: "map",
                panning: "xy"
            },
            xAxis: e,
            yAxis: j(e, {
                reversed: !0
            })
        }, b, {
            chart: {
                inverted: !1
            }
        }), b.series = d, new a.Chart(b, c);
    };
}(Highcharts);
//# sourceMappingURL=map.min.js.map
/*! 康美网络医院 最后修改于： 2016-10-20 */