!function() {
    function a(a, b) {
        var c;
        a || (a = {});
        for (c in b) a[c] = b[c];
        return a;
    }
    function b() {
        var a, b = arguments.length, c = {}, d = function(a, b) {
            var c, e;
            "object" != typeof a && (a = {});
            for (e in b) b.hasOwnProperty(e) && (c = b[e], a[e] = c && "object" == typeof c && "[object Array]" !== Object.prototype.toString.call(c) && "number" != typeof c.nodeType ? d(a[e] || {}, c) : b[e]);
            return a;
        };
        for (a = 0; a < b; a++) c = d(c, arguments[a]);
        return c;
    }
    function c(a, b) {
        return parseInt(a, b || 10);
    }
    function d(a) {
        return "string" == typeof a;
    }
    function e(a) {
        return "object" == typeof a;
    }
    function f(a) {
        return "[object Array]" === Object.prototype.toString.call(a);
    }
    function g(a) {
        return "number" == typeof a;
    }
    function h(a) {
        return ma.log(a) / ma.LN10;
    }
    function i(a) {
        return ma.pow(10, a);
    }
    function j(a, b) {
        for (var c = a.length; c--; ) if (a[c] === b) {
            a.splice(c, 1);
            break;
        }
    }
    function k(a) {
        return a !== S && null !== a;
    }
    function l(a, b, c) {
        var f, g;
        if (d(b)) k(c) ? a.setAttribute(b, c) : a && a.getAttribute && (g = a.getAttribute(b)); else if (k(b) && e(b)) for (f in b) a.setAttribute(f, b[f]);
        return g;
    }
    function m(a) {
        return f(a) ? a : [ a ];
    }
    function n() {
        var a, b, c = arguments, d = c.length;
        for (a = 0; a < d; a++) if (b = c[a], "undefined" != typeof b && null !== b) return b;
    }
    function o(b, c) {
        za && c && c.opacity !== S && (c.filter = "alpha(opacity=" + 100 * c.opacity + ")"), 
        a(b.style, c);
    }
    function p(b, c, d, e, f) {
        return b = ka.createElement(b), c && a(b, c), f && o(b, {
            padding: 0,
            border: Oa,
            margin: 0
        }), d && o(b, d), e && e.appendChild(b), b;
    }
    function q(b, c) {
        var d = function() {};
        return d.prototype = new b(), a(d.prototype, c), d;
    }
    function r(a, b, d, e) {
        var f = V.lang, a = +a || 0, g = b === -1 ? (a.toString().split(".")[1] || "").length : isNaN(b = sa(b)) ? 2 : b, b = void 0 === d ? f.decimalPoint : d, e = void 0 === e ? f.thousandsSep : e, f = a < 0 ? "-" : "", d = String(c(a = sa(a).toFixed(g))), h = d.length > 3 ? d.length % 3 : 0;
        return f + (h ? d.substr(0, h) + e : "") + d.substr(h).replace(/(\d{3})(?=\d)/g, "$1" + e) + (g ? b + sa(a - d).toFixed(g).slice(2) : "");
    }
    function s(a, b) {
        return Array((b || 2) + 1 - String(a).length).join(0) + a;
    }
    function t(a, b, c) {
        var d = a[b];
        a[b] = function() {
            var a = Array.prototype.slice.call(arguments);
            return a.unshift(d), c.apply(this, a);
        };
    }
    function u(a, b) {
        for (var c, d, e, f, g, h = "{", i = !1, j = []; (h = a.indexOf(h)) !== -1; ) {
            if (c = a.slice(0, h), i) {
                for (d = c.split(":"), e = d.shift().split("."), g = e.length, c = b, f = 0; f < g; f++) c = c[e[f]];
                d.length && (d = d.join(":"), e = /\.([0-9])/, f = V.lang, g = void 0, /f$/.test(d) ? (g = (g = d.match(e)) ? g[1] : -1, 
                c = r(c, g, f.decimalPoint, d.indexOf(",") > -1 ? f.thousandsSep : "")) : c = W(d, c));
            }
            j.push(c), a = a.slice(h + 1), h = (i = !i) ? "}" : "{";
        }
        return j.push(a), j.join("");
    }
    function v(a) {
        return ma.pow(10, oa(ma.log(a) / ma.LN10));
    }
    function w(a, b, c, d) {
        var e, c = n(c, 1);
        for (e = a / c, b || (b = [ 1, 2, 2.5, 5, 10 ], d && d.allowDecimals === !1 && (1 === c ? b = [ 1, 2, 5, 10 ] : c <= .1 && (b = [ 1 / c ]))), 
        d = 0; d < b.length && (a = b[d], !(e <= (b[d] + (b[d + 1] || b[d])) / 2)); d++) ;
        return a *= c;
    }
    function x(a, b) {
        var c, d = b || [ [ Qa, [ 1, 2, 5, 10, 20, 25, 50, 100, 200, 500 ] ], [ Ra, [ 1, 2, 5, 10, 15, 30 ] ], [ Sa, [ 1, 2, 5, 10, 15, 30 ] ], [ Ta, [ 1, 2, 3, 4, 6, 8, 12 ] ], [ Ua, [ 1, 2 ] ], [ Va, [ 1, 2 ] ], [ Wa, [ 1, 2, 3, 4, 6 ] ], [ Xa, null ] ], e = d[d.length - 1], f = Z[e[0]], g = e[1];
        for (c = 0; c < d.length && (e = d[c], f = Z[e[0]], g = e[1], !(d[c + 1] && a <= (f * g[g.length - 1] + Z[d[c + 1][0]]) / 2)); c++) ;
        return f === Z[Xa] && a < 5 * f && (g = [ 1, 2, 5 ]), d = w(a / f, g, e[0] === Xa ? v(a / f) : 1), 
        {
            unitRange: f,
            count: d,
            unitName: e[0]
        };
    }
    function y(b, c, d, e) {
        var f, g = [], h = {}, i = V.global.useUTC, j = new Date(c), l = b.unitRange, m = b.count;
        if (k(c)) {
            l >= Z[Ra] && (j.setMilliseconds(0), j.setSeconds(l >= Z[Sa] ? 0 : m * oa(j.getSeconds() / m))), 
            l >= Z[Sa] && j[fa](l >= Z[Ta] ? 0 : m * oa(j[_]() / m)), l >= Z[Ta] && j[ga](l >= Z[Ua] ? 0 : m * oa(j[aa]() / m)), 
            l >= Z[Ua] && j[ha](l >= Z[Wa] ? 1 : m * oa(j[ca]() / m)), l >= Z[Wa] && (j[ia](l >= Z[Xa] ? 0 : m * oa(j[da]() / m)), 
            f = j[ea]()), l >= Z[Xa] && (f -= f % m, j[ja](f)), l === Z[Va] && j[ha](j[ca]() - j[ba]() + n(e, 1)), 
            c = 1, f = j[ea]();
            for (var e = j.getTime(), o = j[da](), p = j[ca](), q = i ? 0 : (864e5 + 6e4 * j.getTimezoneOffset()) % 864e5; e < d; ) g.push(e), 
            l === Z[Xa] ? e = $(f + c * m, 0) : l === Z[Wa] ? e = $(f, o + c * m) : i || l !== Z[Ua] && l !== Z[Va] ? e += l * m : e = $(f, o, p + c * m * (l === Z[Ua] ? 1 : 7)), 
            c++;
            g.push(e), db(eb(g, function(a) {
                return l <= Z[Ta] && a % Z[Ua] === q;
            }), function(a) {
                h[a] = Ua;
            });
        }
        return g.info = a(b, {
            higherRanks: h,
            totalRange: l * m
        }), g;
    }
    function z() {
        this.symbol = this.color = 0;
    }
    function A(a, b) {
        var c, d, e = a.length;
        for (d = 0; d < e; d++) a[d].ss_i = d;
        for (a.sort(function(a, d) {
            return c = b(a, d), 0 === c ? a.ss_i - d.ss_i : c;
        }), d = 0; d < e; d++) delete a[d].ss_i;
    }
    function B(a) {
        for (var b = a.length, c = a[0]; b--; ) a[b] < c && (c = a[b]);
        return c;
    }
    function C(a) {
        for (var b = a.length, c = a[0]; b--; ) a[b] > c && (c = a[b]);
        return c;
    }
    function D(a, b) {
        for (var c in a) a[c] && a[c] !== b && a[c].destroy && a[c].destroy(), delete a[c];
    }
    function E(a) {
        U || (U = p(Na)), a && U.appendChild(a), U.innerHTML = "";
    }
    function F(a, b) {
        var c = "Highcharts error #" + a + ": www.highcharts.com/errors/" + a;
        if (b) throw c;
        la.console && console.log(c);
    }
    function G(a) {
        return parseFloat(a.toPrecision(14));
    }
    function H(a, b) {
        X = n(a, b.animation);
    }
    function I() {
        var a = V.global.useUTC, b = a ? "getUTC" : "get", c = a ? "setUTC" : "set";
        $ = a ? Date.UTC : function(a, b, c, d, e, f) {
            return new Date(a, b, n(c, 1), n(d, 0), n(e, 0), n(f, 0)).getTime();
        }, _ = b + "Minutes", aa = b + "Hours", ba = b + "Day", ca = b + "Date", da = b + "Month", 
        ea = b + "FullYear", fa = c + "Minutes", ga = c + "Hours", ha = c + "Date", ia = c + "Month", 
        ja = c + "FullYear";
    }
    function J() {}
    function K(a, b, c, d) {
        this.axis = a, this.pos = b, this.type = c || "", this.isNew = !0, !c && !d && this.addLabel();
    }
    function L(a, b) {
        this.axis = a, b && (this.options = b, this.id = b.id);
    }
    function M(a, b, c, d, e, f) {
        var g = a.chart.inverted;
        this.axis = a, this.isNegative = c, this.options = b, this.x = d, this.total = null, 
        this.points = {}, this.stack = e, this.percent = "percent" === f, this.alignOptions = {
            align: b.align || (g ? c ? "left" : "right" : "center"),
            verticalAlign: b.verticalAlign || (g ? "middle" : c ? "bottom" : "top"),
            y: n(b.y, g ? 4 : c ? 14 : -6),
            x: n(b.x, g ? c ? -6 : 6 : 0)
        }, this.textAlign = b.textAlign || (g ? c ? "right" : "left" : "center");
    }
    function N() {
        this.init.apply(this, arguments);
    }
    function O() {
        this.init.apply(this, arguments);
    }
    function P(a, b) {
        this.init(a, b);
    }
    function Q(a, b) {
        this.init(a, b);
    }
    function R() {
        this.init.apply(this, arguments);
    }
    var S, T, U, V, W, X, Y, Z, $, _, aa, ba, ca, da, ea, fa, ga, ha, ia, ja, ka = document, la = window, ma = Math, na = ma.round, oa = ma.floor, pa = ma.ceil, qa = ma.max, ra = ma.min, sa = ma.abs, ta = ma.cos, ua = ma.sin, va = ma.PI, wa = 2 * va / 360, xa = navigator.userAgent, ya = la.opera, za = /msie/i.test(xa) && !ya, Aa = 8 === ka.documentMode, Ba = /AppleWebKit/.test(xa), Ca = /Firefox/.test(xa), Da = /(Mobile|Android|Windows Phone)/.test(xa), Ea = "http://www.w3.org/2000/svg", Fa = !!ka.createElementNS && !!ka.createElementNS(Ea, "svg").createSVGRect, Ga = Ca && parseInt(xa.split("Firefox/")[1], 10) < 4, Ha = !Fa && !za && !!ka.createElement("canvas").getContext, Ia = ka.documentElement.ontouchstart !== S, Ja = {}, Ka = 0, La = function() {}, Ma = [], Na = "div", Oa = "none", Pa = "rgba(192,192,192," + (Fa ? 1e-4 : .002) + ")", Qa = "millisecond", Ra = "second", Sa = "minute", Ta = "hour", Ua = "day", Va = "week", Wa = "month", Xa = "year", Ya = "stroke-width", Za = {};
    la.Highcharts = la.Highcharts ? F(16, !0) : {}, W = function(b, c, d) {
        if (!k(c) || isNaN(c)) return "Invalid date";
        var e, b = n(b, "%Y-%m-%d %H:%M:%S"), f = new Date(c), g = f[aa](), h = f[ba](), i = f[ca](), j = f[da](), l = f[ea](), m = V.lang, o = m.weekdays, f = a({
            a: o[h].substr(0, 3),
            A: o[h],
            d: s(i),
            e: i,
            b: m.shortMonths[j],
            B: m.months[j],
            m: s(j + 1),
            y: l.toString().substr(2, 2),
            Y: l,
            H: s(g),
            I: s(g % 12 || 12),
            l: g % 12 || 12,
            M: s(f[_]()),
            p: g < 12 ? "AM" : "PM",
            P: g < 12 ? "am" : "pm",
            S: s(f.getSeconds()),
            L: s(na(c % 1e3), 3)
        }, Highcharts.dateFormats);
        for (e in f) for (;b.indexOf("%" + e) !== -1; ) b = b.replace("%" + e, "function" == typeof f[e] ? f[e](c) : f[e]);
        return d ? b.substr(0, 1).toUpperCase() + b.substr(1) : b;
    }, z.prototype = {
        wrapColor: function(a) {
            this.color >= a && (this.color = 0);
        },
        wrapSymbol: function(a) {
            this.symbol >= a && (this.symbol = 0);
        }
    }, Z = function() {
        for (var a = 0, b = arguments, c = b.length, d = {}; a < c; a++) d[b[a++]] = b[a];
        return d;
    }(Qa, 1, Ra, 1e3, Sa, 6e4, Ta, 36e5, Ua, 864e5, Va, 6048e5, Wa, 26784e5, Xa, 31556952e3), 
    Y = {
        init: function(a, b, c) {
            var d, e, f, b = b || "", g = a.shift, h = b.indexOf("C") > -1, i = h ? 7 : 3, b = b.split(" "), c = [].concat(c), j = function(a) {
                for (d = a.length; d--; ) "M" === a[d] && a.splice(d + 1, 0, a[d + 1], a[d + 2], a[d + 1], a[d + 2]);
            };
            if (h && (j(b), j(c)), a.isArea && (e = b.splice(b.length - 6, 6), f = c.splice(c.length - 6, 6)), 
            g <= c.length / i && b.length === c.length) for (;g--; ) c = [].concat(c).splice(0, i).concat(c);
            if (a.shift = 0, b.length) for (a = c.length; b.length < a; ) g = [].concat(b).splice(b.length - i, i), 
            h && (g[i - 6] = g[i - 2], g[i - 5] = g[i - 1]), b = b.concat(g);
            return e && (b = b.concat(e), c = c.concat(f)), [ b, c ];
        },
        step: function(a, b, c, d) {
            var e = [], f = a.length;
            if (1 === c) e = d; else if (f === b.length && c < 1) for (;f--; ) d = parseFloat(a[f]), 
            e[f] = isNaN(d) ? a[f] : c * parseFloat(b[f] - d) + d; else e = b;
            return e;
        }
    }, function(b) {
        la.HighchartsAdapter = la.HighchartsAdapter || b && {
            init: function(a) {
                var c, e = b.fx, f = e.step, g = b.Tween, h = g && g.propHooks;
                c = b.cssHooks.opacity, b.extend(b.easing, {
                    easeOutQuad: function(a, b, c, d, e) {
                        return -d * (b /= e) * (b - 2) + c;
                    }
                }), b.each([ "cur", "_default", "width", "height", "opacity" ], function(a, b) {
                    var c, d, i = f;
                    "cur" === b ? i = e.prototype : "_default" === b && g && (i = h[b], b = "set"), 
                    (c = i[b]) && (i[b] = function(e) {
                        if (e = a ? e : this, "align" !== e.prop) return d = e.elem, d.attr ? d.attr(e.prop, "cur" === b ? S : e.now) : c.apply(this, arguments);
                    });
                }), t(c, "get", function(a, b, c) {
                    return b.attr ? b.opacity || 0 : a.call(this, b, c);
                }), c = function(b) {
                    var c, d = b.elem;
                    b.started || (c = a.init(d, d.d, d.toD), b.start = c[0], b.end = c[1], b.started = !0), 
                    d.attr("d", a.step(b.start, b.end, b.pos, d.toD));
                }, g ? h.d = {
                    set: c
                } : f.d = c, this.each = Array.prototype.forEach ? function(a, b) {
                    return Array.prototype.forEach.call(a, b);
                } : function(a, b) {
                    for (var c = 0, d = a.length; c < d; c++) if (b.call(a[c], a[c], c, a) === !1) return c;
                }, b.fn.highcharts = function() {
                    var a, b, c = "Chart", e = arguments;
                    return d(e[0]) && (c = e[0], e = Array.prototype.slice.call(e, 1)), a = e[0], a !== S && (a.chart = a.chart || {}, 
                    a.chart.renderTo = this[0], new Highcharts[c](a, e[1]), b = this), a === S && (b = Ma[l(this[0], "data-highcharts-chart")]), 
                    b;
                };
            },
            getScript: b.getScript,
            inArray: b.inArray,
            adapterRun: function(a, c) {
                return b(a)[c]();
            },
            grep: b.grep,
            map: function(a, b) {
                for (var c = [], d = 0, e = a.length; d < e; d++) c[d] = b.call(a[d], a[d], d, a);
                return c;
            },
            offset: function(a) {
                return b(a).offset();
            },
            addEvent: function(a, c, d) {
                b(a).bind(c, d);
            },
            removeEvent: function(a, c, d) {
                var e = ka.removeEventListener ? "removeEventListener" : "detachEvent";
                ka[e] && a && !a[e] && (a[e] = function() {}), b(a).unbind(c, d);
            },
            fireEvent: function(c, d, e, f) {
                var g, h = b.Event(d), i = "detached" + d;
                !za && e && (delete e.layerX, delete e.layerY), a(h, e), c[d] && (c[i] = c[d], c[d] = null), 
                b.each([ "preventDefault", "stopPropagation" ], function(a, b) {
                    var c = h[b];
                    h[b] = function() {
                        try {
                            c.call(h);
                        } catch (a) {
                            "preventDefault" === b && (g = !0);
                        }
                    };
                }), b(c).trigger(h), c[i] && (c[d] = c[i], c[i] = null), f && !h.isDefaultPrevented() && !g && f(h);
            },
            washMouseEvent: function(a) {
                var b = a.originalEvent || a;
                return b.pageX === S && (b.pageX = a.pageX, b.pageY = a.pageY), b;
            },
            animate: function(a, c, d) {
                var e = b(a);
                a.style || (a.style = {}), c.d && (a.toD = c.d, c.d = 1), e.stop(), c.opacity !== S && a.attr && (c.opacity += "px"), 
                e.animate(c, d);
            },
            stop: function(a) {
                b(a).stop();
            }
        };
    }(la.jQuery);
    var $a = la.HighchartsAdapter, _a = $a || {};
    $a && $a.init.call($a, Y);
    var ab = _a.adapterRun, bb = _a.getScript, cb = _a.inArray, db = _a.each, eb = _a.grep, fb = _a.offset, gb = _a.map, hb = _a.addEvent, ib = _a.removeEvent, jb = _a.fireEvent, kb = _a.washMouseEvent, lb = _a.animate, mb = _a.stop, _a = {
        enabled: !0,
        x: 0,
        y: 15,
        style: {
            color: "#666",
            cursor: "default",
            fontSize: "11px",
            lineHeight: "14px"
        }
    };
    V = {
        colors: "#2f7ed8,#0d233a,#8bbc21,#910000,#1aadce,#492970,#f28f43,#77a1e5,#c42525,#a6c96a".split(","),
        symbols: [ "circle", "diamond", "square", "triangle", "triangle-down" ],
        lang: {
            loading: "Loading...",
            months: "January,February,March,April,May,June,July,August,September,October,November,December".split(","),
            shortMonths: "Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec".split(","),
            weekdays: "Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday".split(","),
            decimalPoint: ".",
            numericSymbols: "k,M,G,T,P,E".split(","),
            resetZoom: "Reset zoom",
            resetZoomTitle: "Reset zoom level 1:1",
            thousandsSep: ","
        },
        global: {
            useUTC: !0,
            canvasToolsURL: "http://code.highcharts.com/3.0.6/modules/canvas-tools.js",
            VMLRadialGradientURL: "http://code.highcharts.com/3.0.6/gfx/vml-radial-gradient.png"
        },
        chart: {
            borderColor: "#4572A7",
            borderRadius: 5,
            defaultSeriesType: "line",
            ignoreHiddenSeries: !0,
            spacing: [ 10, 10, 15, 10 ],
            style: {
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif',
                fontSize: "12px"
            },
            backgroundColor: "#FFFFFF",
            plotBorderColor: "#C0C0C0",
            resetZoomButton: {
                theme: {
                    zIndex: 20
                },
                position: {
                    align: "right",
                    x: -10,
                    y: 10
                }
            }
        },
        title: {
            text: "Chart title",
            align: "center",
            margin: 15,
            style: {
                color: "#274b6d",
                fontSize: "16px"
            }
        },
        subtitle: {
            text: "",
            align: "center",
            style: {
                color: "#4d759e"
            }
        },
        plotOptions: {
            line: {
                allowPointSelect: !1,
                showCheckbox: !1,
                animation: {
                    duration: 1e3
                },
                events: {},
                lineWidth: 2,
                marker: {
                    enabled: !0,
                    lineWidth: 0,
                    radius: 4,
                    lineColor: "#FFFFFF",
                    states: {
                        hover: {
                            enabled: !0
                        },
                        select: {
                            fillColor: "#FFFFFF",
                            lineColor: "#000000",
                            lineWidth: 2
                        }
                    }
                },
                point: {
                    events: {}
                },
                dataLabels: b(_a, {
                    align: "center",
                    enabled: !1,
                    formatter: function() {
                        return null === this.y ? "" : r(this.y, -1);
                    },
                    verticalAlign: "bottom",
                    y: 0
                }),
                cropThreshold: 300,
                pointRange: 0,
                showInLegend: !0,
                states: {
                    hover: {
                        marker: {}
                    },
                    select: {
                        marker: {}
                    }
                },
                stickyTracking: !0
            }
        },
        labels: {
            style: {
                position: "absolute",
                color: "#3E576F"
            }
        },
        legend: {
            enabled: !0,
            align: "center",
            layout: "horizontal",
            labelFormatter: function() {
                return this.name;
            },
            borderWidth: 1,
            borderColor: "#909090",
            borderRadius: 5,
            navigation: {
                activeColor: "#274b6d",
                inactiveColor: "#CCC"
            },
            shadow: !1,
            itemStyle: {
                cursor: "pointer",
                color: "#274b6d",
                fontSize: "12px"
            },
            itemHoverStyle: {
                color: "#000"
            },
            itemHiddenStyle: {
                color: "#CCC"
            },
            itemCheckboxStyle: {
                position: "absolute",
                width: "13px",
                height: "13px"
            },
            symbolWidth: 16,
            symbolPadding: 5,
            verticalAlign: "bottom",
            x: 0,
            y: 0,
            title: {
                style: {
                    fontWeight: "bold"
                }
            }
        },
        loading: {
            labelStyle: {
                fontWeight: "bold",
                position: "relative",
                top: "1em"
            },
            style: {
                position: "absolute",
                backgroundColor: "white",
                opacity: .5,
                textAlign: "center"
            }
        },
        tooltip: {
            enabled: !0,
            animation: Fa,
            backgroundColor: "rgba(255, 255, 255, .85)",
            borderWidth: 1,
            borderRadius: 3,
            dateTimeLabelFormats: {
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                second: "%A, %b %e, %H:%M:%S",
                minute: "%A, %b %e, %H:%M",
                hour: "%A, %b %e, %H:%M",
                day: "%A, %b %e, %Y",
                week: "Week from %A, %b %e, %Y",
                month: "%B %Y",
                year: "%Y"
            },
            headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
            pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b><br/>',
            shadow: !0,
            snap: Da ? 25 : 10,
            style: {
                color: "#333333",
                cursor: "default",
                fontSize: "12px",
                padding: "8px",
                whiteSpace: "nowrap"
            }
        },
        credits: {
            enabled: !0,
            text: "Highcharts.com",
            href: "http://www.highcharts.com",
            position: {
                align: "right",
                x: -10,
                verticalAlign: "bottom",
                y: -5
            },
            style: {
                cursor: "pointer",
                color: "#909090",
                fontSize: "9px"
            }
        }
    };
    var nb = V.plotOptions, $a = nb.line;
    I();
    var ob = function(a) {
        var d, e, f = [];
        return function(a) {
            a && a.stops ? e = gb(a.stops, function(a) {
                return ob(a[1]);
            }) : (d = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(a)) ? f = [ c(d[1]), c(d[2]), c(d[3]), parseFloat(d[4], 10) ] : (d = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(a)) ? f = [ c(d[1], 16), c(d[2], 16), c(d[3], 16), 1 ] : (d = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(a)) && (f = [ c(d[1]), c(d[2]), c(d[3]), 1 ]);
        }(a), {
            get: function(c) {
                var d;
                return e ? (d = b(a), d.stops = [].concat(d.stops), db(e, function(a, b) {
                    d.stops[b] = [ d.stops[b][0], a.get(c) ];
                })) : d = f && !isNaN(f[0]) ? "rgb" === c ? "rgb(" + f[0] + "," + f[1] + "," + f[2] + ")" : "a" === c ? f[3] : "rgba(" + f.join(",") + ")" : a, 
                d;
            },
            brighten: function(a) {
                if (e) db(e, function(b) {
                    b.brighten(a);
                }); else if (g(a) && 0 !== a) {
                    var b;
                    for (b = 0; b < 3; b++) f[b] += c(255 * a), f[b] < 0 && (f[b] = 0), f[b] > 255 && (f[b] = 255);
                }
                return this;
            },
            rgba: f,
            setOpacity: function(a) {
                return f[3] = a, this;
            }
        };
    };
    J.prototype = {
        init: function(a, b) {
            this.element = "span" === b ? p(b) : ka.createElementNS(Ea, b), this.renderer = a, 
            this.attrSetters = {};
        },
        opacity: 1,
        animate: function(a, c, d) {
            c = n(c, X, !0), mb(this), c ? (c = b(c), d && (c.complete = d), lb(this, a, c)) : (this.attr(a), 
            d && d());
        },
        attr: function(a, b) {
            var e, f, g, h, i, j, m, o = this.element, p = o.nodeName.toLowerCase(), q = this.renderer, r = this.attrSetters, s = this.shadows, t = this;
            if (d(a) && k(b) && (e = a, a = {}, a[e] = b), d(a)) e = a, "circle" === p ? e = {
                x: "cx",
                y: "cy"
            }[e] || e : "strokeWidth" === e && (e = "stroke-width"), t = l(o, e) || this[e] || 0, 
            "d" !== e && "visibility" !== e && "fill" !== e && (t = parseFloat(t)); else {
                for (e in a) if (i = !1, f = a[e], g = r[e] && r[e].call(this, f, e), g !== !1) {
                    if (g !== S && (f = g), "d" === e) f && f.join && (f = f.join(" ")), /(NaN| {2}|^$)/.test(f) && (f = "M 0 0"); else if ("x" === e && "text" === p) for (g = 0; g < o.childNodes.length; g++) h = o.childNodes[g], 
                    l(h, "x") === l(o, "x") && l(h, "x", f); else if (!this.rotation || "x" !== e && "y" !== e) if ("fill" === e) f = q.color(f, o, e); else if ("circle" !== p || "x" !== e && "y" !== e) if ("rect" === p && "r" === e) l(o, {
                        rx: f,
                        ry: f
                    }), i = !0; else if ("translateX" === e || "translateY" === e || "rotation" === e || "verticalAlign" === e || "scaleX" === e || "scaleY" === e) i = m = !0; else if ("stroke" === e) f = q.color(f, o, e); else if ("dashstyle" === e) {
                        if (e = "stroke-dasharray", f = f && f.toLowerCase(), "solid" === f) f = Oa; else if (f) {
                            for (f = f.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(","), 
                            g = f.length; g--; ) f[g] = c(f[g]) * n(a["stroke-width"], this["stroke-width"]);
                            f = f.join(",");
                        }
                    } else "width" === e ? f = c(f) : "align" === e ? (e = "text-anchor", f = {
                        left: "start",
                        center: "middle",
                        right: "end"
                    }[f]) : "title" === e && (g = o.getElementsByTagName("title")[0], g || (g = ka.createElementNS(Ea, "title"), 
                    o.appendChild(g)), g.textContent = f); else e = {
                        x: "cx",
                        y: "cy"
                    }[e] || e; else m = !0;
                    if ("strokeWidth" === e && (e = "stroke-width"), "stroke-width" !== e && "stroke" !== e || (this[e] = f, 
                    this.stroke && this["stroke-width"] ? (l(o, "stroke", this.stroke), l(o, "stroke-width", this["stroke-width"]), 
                    this.hasStroke = !0) : "stroke-width" === e && 0 === f && this.hasStroke && (o.removeAttribute("stroke"), 
                    this.hasStroke = !1), i = !0), this.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(e) && (j || (this.symbolAttr(a), 
                    j = !0), i = !0), s && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(e)) for (g = s.length; g--; ) l(s[g], e, "height" === e ? qa(f - (s[g].cutHeight || 0), 0) : f);
                    ("width" === e || "height" === e) && "rect" === p && f < 0 && (f = 0), this[e] = f, 
                    "text" === e ? (f !== this.textStr && delete this.bBox, this.textStr = f, this.added && q.buildText(this)) : i || l(o, e, f);
                }
                m && this.updateTransform();
            }
            return t;
        },
        addClass: function(a) {
            var b = this.element, c = l(b, "class") || "";
            return c.indexOf(a) === -1 && l(b, "class", c + " " + a), this;
        },
        symbolAttr: function(a) {
            var b = this;
            db("x,y,r,start,end,width,height,innerR,anchorX,anchorY".split(","), function(c) {
                b[c] = n(a[c], b[c]);
            }), b.attr({
                d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)
            });
        },
        clip: function(a) {
            return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : Oa);
        },
        crisp: function(a, b, c, d, e) {
            var f, g, h = {}, i = {}, a = a || this.strokeWidth || this.attr && this.attr("stroke-width") || 0;
            g = na(a) % 2 / 2, i.x = oa(b || this.x || 0) + g, i.y = oa(c || this.y || 0) + g, 
            i.width = oa((d || this.width || 0) - 2 * g), i.height = oa((e || this.height || 0) - 2 * g), 
            i.strokeWidth = a;
            for (f in i) this[f] !== i[f] && (this[f] = h[f] = i[f]);
            return h;
        },
        css: function(b) {
            var c, d = this.element, e = b && b.width && "text" === d.nodeName.toLowerCase(), f = "", g = function(a, b) {
                return "-" + b.toLowerCase();
            };
            if (b && b.color && (b.fill = b.color), this.styles = b = a(this.styles, b), Ha && e && delete b.width, 
            za && !Fa) e && delete b.width, o(this.element, b); else {
                for (c in b) f += c.replace(/([A-Z])/g, g) + ":" + b[c] + ";";
                l(d, "style", f);
            }
            return e && this.added && this.renderer.buildText(this), this;
        },
        on: function(a, b) {
            var c = this, d = c.element;
            return Ia && "click" === a ? (d.ontouchstart = function(a) {
                c.touchEventFired = Date.now(), a.preventDefault(), b.call(d, a);
            }, d.onclick = function(a) {
                (xa.indexOf("Android") === -1 || Date.now() - (c.touchEventFired || 0) > 1100) && b.call(d, a);
            }) : d["on" + a] = b, this;
        },
        setRadialReference: function(a) {
            return this.element.radialReference = a, this;
        },
        translate: function(a, b) {
            return this.attr({
                translateX: a,
                translateY: b
            });
        },
        invert: function() {
            return this.inverted = !0, this.updateTransform(), this;
        },
        htmlCss: function(b) {
            var c = this.element;
            return (c = b && "SPAN" === c.tagName && b.width) && (delete b.width, this.textWidth = c, 
            this.updateTransform()), this.styles = a(this.styles, b), o(this.element, b), this;
        },
        htmlGetBBox: function() {
            var a = this.element, b = this.bBox;
            return b || ("text" === a.nodeName && (a.style.position = "absolute"), b = this.bBox = {
                x: a.offsetLeft,
                y: a.offsetTop,
                width: a.offsetWidth,
                height: a.offsetHeight
            }), b;
        },
        htmlUpdateTransform: function() {
            if (this.added) {
                var a = this.renderer, b = this.element, d = this.translateX || 0, e = this.translateY || 0, f = this.x || 0, g = this.y || 0, h = this.textAlign || "left", i = {
                    left: 0,
                    center: .5,
                    right: 1
                }[h], j = h && "left" !== h, l = this.shadows;
                if (o(b, {
                    marginLeft: d,
                    marginTop: e
                }), l && db(l, function(a) {
                    o(a, {
                        marginLeft: d + 1,
                        marginTop: e + 1
                    });
                }), this.inverted && db(b.childNodes, function(c) {
                    a.invertChild(c, b);
                }), "SPAN" === b.tagName) {
                    var m, p, q, l = this.rotation;
                    m = 0;
                    var r, s = 1, t = 0;
                    q = c(this.textWidth);
                    var u = this.xCorr || 0, v = this.yCorr || 0, w = [ l, h, b.innerHTML, this.textWidth ].join(",");
                    w !== this.cTT && (k(l) && (m = l * wa, s = ta(m), t = ua(m), this.setSpanRotation(l, t, s)), 
                    m = n(this.elemWidth, b.offsetWidth), p = n(this.elemHeight, b.offsetHeight), m > q && /[ \-]/.test(b.textContent || b.innerText) && (o(b, {
                        width: q + "px",
                        display: "block",
                        whiteSpace: "normal"
                    }), m = q), q = a.fontMetrics(b.style.fontSize).b, u = s < 0 && -m, v = t < 0 && -p, 
                    r = s * t < 0, u += t * q * (r ? 1 - i : i), v -= s * q * (l ? r ? i : 1 - i : 1), 
                    j && (u -= m * i * (s < 0 ? -1 : 1), l && (v -= p * i * (t < 0 ? -1 : 1)), o(b, {
                        textAlign: h
                    })), this.xCorr = u, this.yCorr = v), o(b, {
                        left: f + u + "px",
                        top: g + v + "px"
                    }), Ba && (p = b.offsetHeight), this.cTT = w;
                }
            } else this.alignOnAdd = !0;
        },
        setSpanRotation: function(a) {
            var b = {};
            b[za ? "-ms-transform" : Ba ? "-webkit-transform" : Ca ? "MozTransform" : ya ? "-o-transform" : ""] = b.transform = "rotate(" + a + "deg)", 
            o(this.element, b);
        },
        updateTransform: function() {
            var a = this.translateX || 0, b = this.translateY || 0, c = this.scaleX, d = this.scaleY, e = this.inverted, f = this.rotation;
            e && (a += this.attr("width"), b += this.attr("height")), a = [ "translate(" + a + "," + b + ")" ], 
            e ? a.push("rotate(90) scale(-1,1)") : f && a.push("rotate(" + f + " " + (this.x || 0) + " " + (this.y || 0) + ")"), 
            (k(c) || k(d)) && a.push("scale(" + n(c, 1) + " " + n(d, 1) + ")"), a.length && l(this.element, "transform", a.join(" "));
        },
        toFront: function() {
            var a = this.element;
            return a.parentNode.appendChild(a), this;
        },
        align: function(a, b, c) {
            var e, f, g, h, i = {};
            return f = this.renderer, g = f.alignedObjects, a ? (this.alignOptions = a, this.alignByTranslate = b, 
            (!c || d(c)) && (this.alignTo = e = c || "renderer", j(g, this), g.push(this), c = null)) : (a = this.alignOptions, 
            b = this.alignByTranslate, e = this.alignTo), c = n(c, f[e], f), e = a.align, f = a.verticalAlign, 
            g = (c.x || 0) + (a.x || 0), h = (c.y || 0) + (a.y || 0), "right" !== e && "center" !== e || (g += (c.width - (a.width || 0)) / {
                right: 1,
                center: 2
            }[e]), i[b ? "translateX" : "x"] = na(g), "bottom" !== f && "middle" !== f || (h += (c.height - (a.height || 0)) / ({
                bottom: 1,
                middle: 2
            }[f] || 1)), i[b ? "translateY" : "y"] = na(h), this[this.placed ? "animate" : "attr"](i), 
            this.placed = !0, this.alignAttr = i, this;
        },
        getBBox: function() {
            var b, c = this.bBox, d = this.renderer, e = this.rotation;
            b = this.element;
            var f = this.styles, g = e * wa;
            if (!c) {
                if (b.namespaceURI === Ea || d.forExport) {
                    try {
                        c = b.getBBox ? a({}, b.getBBox()) : {
                            width: b.offsetWidth,
                            height: b.offsetHeight
                        };
                    } catch (h) {}
                    (!c || c.width < 0) && (c = {
                        width: 0,
                        height: 0
                    });
                } else c = this.htmlGetBBox();
                d.isSVG && (d = c.width, b = c.height, za && f && "11px" === f.fontSize && "22.7" === b.toPrecision(3) && (c.height = b = 14), 
                e && (c.width = sa(b * ua(g)) + sa(d * ta(g)), c.height = sa(b * ta(g)) + sa(d * ua(g)))), 
                this.bBox = c;
            }
            return c;
        },
        show: function() {
            return this.attr({
                visibility: "visible"
            });
        },
        hide: function() {
            return this.attr({
                visibility: "hidden"
            });
        },
        fadeOut: function(a) {
            var b = this;
            b.animate({
                opacity: 0
            }, {
                duration: a || 150,
                complete: function() {
                    b.hide();
                }
            });
        },
        add: function(a) {
            var b, d = this.renderer, e = a || d, f = e.element || d.box, g = f.childNodes, h = this.element, i = l(h, "zIndex");
            if (a && (this.parentGroup = a), this.parentInverted = a && a.inverted, void 0 !== this.textStr && d.buildText(this), 
            i && (e.handleZ = !0, i = c(i)), e.handleZ) for (e = 0; e < g.length; e++) if (a = g[e], 
            d = l(a, "zIndex"), a !== h && (c(d) > i || !k(i) && k(d))) {
                f.insertBefore(h, a), b = !0;
                break;
            }
            return b || f.appendChild(h), this.added = !0, jb(this, "add"), this;
        },
        safeRemoveChild: function(a) {
            var b = a.parentNode;
            b && b.removeChild(a);
        },
        destroy: function() {
            var a, b, c = this, d = c.element || {}, e = c.shadows, f = c.renderer.isSVG && "SPAN" === d.nodeName && d.parentNode;
            if (d.onclick = d.onmouseout = d.onmouseover = d.onmousemove = d.point = null, mb(c), 
            c.clipPath && (c.clipPath = c.clipPath.destroy()), c.stops) {
                for (b = 0; b < c.stops.length; b++) c.stops[b] = c.stops[b].destroy();
                c.stops = null;
            }
            for (c.safeRemoveChild(d), e && db(e, function(a) {
                c.safeRemoveChild(a);
            }); f && 0 === f.childNodes.length; ) d = f.parentNode, c.safeRemoveChild(f), f = d;
            c.alignTo && j(c.renderer.alignedObjects, c);
            for (a in c) delete c[a];
            return null;
        },
        shadow: function(a, b, c) {
            var d, e, f, g, h, i, j = [], k = this.element;
            if (a) {
                for (g = n(a.width, 3), h = (a.opacity || .15) / g, i = this.parentInverted ? "(-1,-1)" : "(" + n(a.offsetX, 1) + ", " + n(a.offsetY, 1) + ")", 
                d = 1; d <= g; d++) e = k.cloneNode(0), f = 2 * g + 1 - 2 * d, l(e, {
                    isShadow: "true",
                    stroke: a.color || "black",
                    "stroke-opacity": h * d,
                    "stroke-width": f,
                    transform: "translate" + i,
                    fill: Oa
                }), c && (l(e, "height", qa(l(e, "height") - f, 0)), e.cutHeight = f), b ? b.element.appendChild(e) : k.parentNode.insertBefore(e, k), 
                j.push(e);
                this.shadows = j;
            }
            return this;
        }
    };
    var pb = function() {
        this.init.apply(this, arguments);
    };
    pb.prototype = {
        Element: J,
        init: function(a, b, c, d) {
            var e, f, g = location;
            e = this.createElement("svg").attr({
                version: "1.1"
            }), f = e.element, a.appendChild(f), a.innerHTML.indexOf("xmlns") === -1 && l(f, "xmlns", Ea), 
            this.isSVG = !0, this.box = f, this.boxWrapper = e, this.alignedObjects = [], this.url = (Ca || Ba) && ka.getElementsByTagName("base").length ? g.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "", 
            this.createElement("desc").add().element.appendChild(ka.createTextNode("Created with Highcharts 3.0.6")), 
            this.defs = this.createElement("defs").add(), this.forExport = d, this.gradients = {}, 
            this.setSize(b, c, !1);
            var h;
            Ca && a.getBoundingClientRect && (this.subPixelFix = b = function() {
                o(a, {
                    left: 0,
                    top: 0
                }), h = a.getBoundingClientRect(), o(a, {
                    left: pa(h.left) - h.left + "px",
                    top: pa(h.top) - h.top + "px"
                });
            }, b(), hb(la, "resize", b));
        },
        isHidden: function() {
            return !this.boxWrapper.getBBox().width;
        },
        destroy: function() {
            var a = this.defs;
            return this.box = null, this.boxWrapper = this.boxWrapper.destroy(), D(this.gradients || {}), 
            this.gradients = null, a && (this.defs = a.destroy()), this.subPixelFix && ib(la, "resize", this.subPixelFix), 
            this.alignedObjects = null;
        },
        createElement: function(a) {
            var b = new this.Element();
            return b.init(this, a), b;
        },
        draw: function() {},
        buildText: function(a) {
            for (var b = a.element, d = this, e = d.forExport, f = n(a.textStr, "").toString().replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g), g = b.childNodes, h = /style="([^"]+)"/, i = /href="(http[^"]+)"/, j = l(b, "x"), k = a.styles, m = k && k.width && c(k.width), p = k && k.lineHeight, q = g.length; q--; ) b.removeChild(g[q]);
            m && !a.added && this.box.appendChild(b), "" === f[f.length - 1] && f.pop(), db(f, function(f, g) {
                var n, q = 0, f = f.replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||");
                n = f.split("|||"), db(n, function(f) {
                    if ("" !== f || 1 === n.length) {
                        var r, s = {}, t = ka.createElementNS(Ea, "tspan");
                        if (h.test(f) && (r = f.match(h)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), l(t, "style", r)), 
                        i.test(f) && !e && (l(t, "onclick", 'location.href="' + f.match(i)[1] + '"'), o(t, {
                            cursor: "pointer"
                        })), f = (f.replace(/<(.|\n)*?>/g, "") || " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">"), 
                        " " !== f && (t.appendChild(ka.createTextNode(f)), q ? s.dx = 0 : s.x = j, l(t, s), 
                        !q && g && (!Fa && e && o(t, {
                            display: "block"
                        }), l(t, "dy", p || d.fontMetrics(/px$/.test(t.style.fontSize) ? t.style.fontSize : k.fontSize).h, Ba && t.offsetHeight)), 
                        b.appendChild(t), q++, m)) for (var u, v, f = f.replace(/([^\^])-/g, "$1- ").split(" "), s = a._clipHeight, w = [], x = c(p || 16), y = 1; f.length || w.length; ) delete a.bBox, 
                        u = a.getBBox(), v = u.width, u = v > m, u && 1 !== f.length ? (t.removeChild(t.firstChild), 
                        w.unshift(f.pop())) : (f = w, w = [], f.length && (y++, s && y * x > s ? (f = [ "..." ], 
                        a.attr("title", a.textStr)) : (t = ka.createElementNS(Ea, "tspan"), l(t, {
                            dy: x,
                            x: j
                        }), r && l(t, "style", r), b.appendChild(t), v > m && (m = v)))), f.length && t.appendChild(ka.createTextNode(f.join(" ").replace(/- /g, "-")));
                    }
                });
            });
        },
        button: function(c, d, e, f, g, h, i, j) {
            var k, l, m, n, o, p, q = this.label(c, d, e, null, null, null, null, null, "button"), r = 0, c = {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 1
            }, g = b({
                "stroke-width": 1,
                stroke: "#CCCCCC",
                fill: {
                    linearGradient: c,
                    stops: [ [ 0, "#FEFEFE" ], [ 1, "#F6F6F6" ] ]
                },
                r: 2,
                padding: 5,
                style: {
                    color: "black"
                }
            }, g);
            return m = g.style, delete g.style, h = b(g, {
                stroke: "#68A",
                fill: {
                    linearGradient: c,
                    stops: [ [ 0, "#FFF" ], [ 1, "#ACF" ] ]
                }
            }, h), n = h.style, delete h.style, i = b(g, {
                stroke: "#68A",
                fill: {
                    linearGradient: c,
                    stops: [ [ 0, "#9BD" ], [ 1, "#CDF" ] ]
                }
            }, i), o = i.style, delete i.style, j = b(g, {
                style: {
                    color: "#CCC"
                }
            }, j), p = j.style, delete j.style, hb(q.element, za ? "mouseover" : "mouseenter", function() {
                3 !== r && q.attr(h).css(n);
            }), hb(q.element, za ? "mouseout" : "mouseleave", function() {
                3 !== r && (k = [ g, h, i ][r], l = [ m, n, o ][r], q.attr(k).css(l));
            }), q.setState = function(a) {
                (q.state = r = a) ? 2 === a ? q.attr(i).css(o) : 3 === a && q.attr(j).css(p) : q.attr(g).css(m);
            }, q.on("click", function() {
                3 !== r && f.call(q);
            }).attr(g).css(a({
                cursor: "default"
            }, m));
        },
        crispLine: function(a, b) {
            return a[1] === a[4] && (a[1] = a[4] = na(a[1]) - b % 2 / 2), a[2] === a[5] && (a[2] = a[5] = na(a[2]) + b % 2 / 2), 
            a;
        },
        path: function(b) {
            var c = {
                fill: Oa
            };
            return f(b) ? c.d = b : e(b) && a(c, b), this.createElement("path").attr(c);
        },
        circle: function(a, b, c) {
            return a = e(a) ? a : {
                x: a,
                y: b,
                r: c
            }, this.createElement("circle").attr(a);
        },
        arc: function(a, b, c, d, f, g) {
            return e(a) && (b = a.y, c = a.r, d = a.innerR, f = a.start, g = a.end, a = a.x), 
            a = this.symbol("arc", a || 0, b || 0, c || 0, c || 0, {
                innerR: d || 0,
                start: f || 0,
                end: g || 0
            }), a.r = c, a;
        },
        rect: function(a, b, c, d, f, g) {
            return f = e(a) ? a.r : f, f = this.createElement("rect").attr({
                rx: f,
                ry: f,
                fill: Oa
            }), f.attr(e(a) ? a : f.crisp(g, a, b, qa(c, 0), qa(d, 0)));
        },
        setSize: function(a, b, c) {
            var d = this.alignedObjects, e = d.length;
            for (this.width = a, this.height = b, this.boxWrapper[n(c, !0) ? "animate" : "attr"]({
                width: a,
                height: b
            }); e--; ) d[e].align();
        },
        g: function(a) {
            var b = this.createElement("g");
            return k(a) ? b.attr({
                class: "highcharts-" + a
            }) : b;
        },
        image: function(b, c, d, e, f) {
            var g = {
                preserveAspectRatio: Oa
            };
            return arguments.length > 1 && a(g, {
                x: c,
                y: d,
                width: e,
                height: f
            }), g = this.createElement("image").attr(g), g.element.setAttributeNS ? g.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", b) : g.element.setAttribute("hc-svg-href", b), 
            g;
        },
        symbol: function(b, c, d, e, f, g) {
            var h, i, j, k = this.symbols[b], k = k && k(na(c), na(d), e, f, g), l = /^url\((.*?)\)$/;
            return k ? (h = this.path(k), a(h, {
                symbolName: b,
                x: c,
                y: d,
                width: e,
                height: f
            }), g && a(h, g)) : l.test(b) && (j = function(a, b) {
                a.element && (a.attr({
                    width: b[0],
                    height: b[1]
                }), a.alignByTranslate || a.translate(na((e - b[0]) / 2), na((f - b[1]) / 2)));
            }, i = b.match(l)[1], b = Ja[i], h = this.image(i).attr({
                x: c,
                y: d
            }), h.isImg = !0, b ? j(h, b) : (h.attr({
                width: 0,
                height: 0
            }), p("img", {
                onload: function() {
                    j(h, Ja[i] = [ this.width, this.height ]);
                },
                src: i
            }))), h;
        },
        symbols: {
            circle: function(a, b, c, d) {
                var e = .166 * c;
                return [ "M", a + c / 2, b, "C", a + c + e, b, a + c + e, b + d, a + c / 2, b + d, "C", a - e, b + d, a - e, b, a + c / 2, b, "Z" ];
            },
            square: function(a, b, c, d) {
                return [ "M", a, b, "L", a + c, b, a + c, b + d, a, b + d, "Z" ];
            },
            triangle: function(a, b, c, d) {
                return [ "M", a + c / 2, b, "L", a + c, b + d, a, b + d, "Z" ];
            },
            "triangle-down": function(a, b, c, d) {
                return [ "M", a, b, "L", a + c, b, a + c / 2, b + d, "Z" ];
            },
            diamond: function(a, b, c, d) {
                return [ "M", a + c / 2, b, "L", a + c, b + d / 2, a + c / 2, b + d, a, b + d / 2, "Z" ];
            },
            arc: function(a, b, c, d, e) {
                var f = e.start, c = e.r || c || d, g = e.end - .001, d = e.innerR, h = e.open, i = ta(f), j = ua(f), k = ta(g), g = ua(g), e = e.end - f < va ? 0 : 1;
                return [ "M", a + c * i, b + c * j, "A", c, c, 0, e, 1, a + c * k, b + c * g, h ? "M" : "L", a + d * k, b + d * g, "A", d, d, 0, e, 0, a + d * i, b + d * j, h ? "" : "Z" ];
            }
        },
        clipRect: function(a, b, c, d) {
            var e = "highcharts-" + Ka++, f = this.createElement("clipPath").attr({
                id: e
            }).add(this.defs), a = this.rect(a, b, c, d, 0).add(f);
            return a.id = e, a.clipPath = f, a;
        },
        color: function(a, c, d) {
            var e, g, h, i, j, m, n, o, p = this, q = /^rgba/, r = [];
            if (a && a.linearGradient ? g = "linearGradient" : a && a.radialGradient && (g = "radialGradient"), 
            g) {
                d = a[g], h = p.gradients, j = a.stops, c = c.radialReference, f(d) && (a[g] = d = {
                    x1: d[0],
                    y1: d[1],
                    x2: d[2],
                    y2: d[3],
                    gradientUnits: "userSpaceOnUse"
                }), "radialGradient" === g && c && !k(d.gradientUnits) && (d = b(d, {
                    cx: c[0] - c[2] / 2 + d.cx * c[2],
                    cy: c[1] - c[2] / 2 + d.cy * c[2],
                    r: d.r * c[2],
                    gradientUnits: "userSpaceOnUse"
                }));
                for (o in d) "id" !== o && r.push(o, d[o]);
                for (o in j) r.push(j[o]);
                return r = r.join(","), h[r] ? a = h[r].id : (d.id = a = "highcharts-" + Ka++, h[r] = i = p.createElement(g).attr(d).add(p.defs), 
                i.stops = [], db(j, function(a) {
                    q.test(a[1]) ? (e = ob(a[1]), m = e.get("rgb"), n = e.get("a")) : (m = a[1], n = 1), 
                    a = p.createElement("stop").attr({
                        offset: a[0],
                        "stop-color": m,
                        "stop-opacity": n
                    }).add(i), i.stops.push(a);
                })), "url(" + p.url + "#" + a + ")";
            }
            return q.test(a) ? (e = ob(a), l(c, d + "-opacity", e.get("a")), e.get("rgb")) : (c.removeAttribute(d + "-opacity"), 
            a);
        },
        text: function(a, b, c, d) {
            var e = V.chart.style, f = Ha || !Fa && this.forExport;
            return d && !this.forExport ? this.html(a, b, c) : (b = na(n(b, 0)), c = na(n(c, 0)), 
            a = this.createElement("text").attr({
                x: b,
                y: c,
                text: a
            }).css({
                fontFamily: e.fontFamily,
                fontSize: e.fontSize
            }), f && a.css({
                position: "absolute"
            }), a.x = b, a.y = c, a);
        },
        html: function(b, c, d) {
            var e = V.chart.style, f = this.createElement("span"), g = f.attrSetters, h = f.element, i = f.renderer;
            return g.text = function(a) {
                return a !== h.innerHTML && delete this.bBox, h.innerHTML = a, !1;
            }, g.x = g.y = g.align = function(a, b) {
                return "align" === b && (b = "textAlign"), f[b] = a, f.htmlUpdateTransform(), !1;
            }, f.attr({
                text: b,
                x: na(c),
                y: na(d)
            }).css({
                position: "absolute",
                whiteSpace: "nowrap",
                fontFamily: e.fontFamily,
                fontSize: e.fontSize
            }), f.css = f.htmlCss, i.isSVG && (f.add = function(b) {
                var c, d = i.box.parentNode, e = [];
                if (b) {
                    if (c = b.div, !c) {
                        for (;b; ) e.push(b), b = b.parentGroup;
                        db(e.reverse(), function(b) {
                            var e;
                            c = b.div = b.div || p(Na, {
                                className: l(b.element, "class")
                            }, {
                                position: "absolute",
                                left: (b.translateX || 0) + "px",
                                top: (b.translateY || 0) + "px"
                            }, c || d), e = c.style, a(b.attrSetters, {
                                translateX: function(a) {
                                    e.left = a + "px";
                                },
                                translateY: function(a) {
                                    e.top = a + "px";
                                },
                                visibility: function(a, b) {
                                    e[b] = a;
                                }
                            });
                        });
                    }
                } else c = d;
                return c.appendChild(h), f.added = !0, f.alignOnAdd && f.htmlUpdateTransform(), 
                f;
            }), f;
        },
        fontMetrics: function(a) {
            var a = c(a || 11), a = a < 24 ? a + 4 : na(1.2 * a), b = na(.8 * a);
            return {
                h: a,
                b: b
            };
        },
        label: function(c, d, e, f, g, h, i, j, l) {
            function m() {
                var a, c;
                a = A.element.style, r = (void 0 === s || void 0 === t || z.styles.textAlign) && A.getBBox(), 
                z.width = (s || r.width || 0) + 2 * C + D, z.height = (t || r.height || 0) + 2 * C, 
                w = C + y.fontMetrics(a && a.fontSize).b, x && (q || (a = na(-B * C), c = j ? -w : 0, 
                z.box = q = f ? y.symbol(f, a, c, z.width, z.height) : y.rect(a, c, z.width, z.height, 0, F[Ya]), 
                q.add(z)), q.isImg || q.attr(b({
                    width: z.width,
                    height: z.height
                }, F)), F = null);
            }
            function n() {
                var a, b = z.styles, b = b && b.textAlign, c = D + C * (1 - B);
                a = j ? 0 : w, !k(s) || "center" !== b && "right" !== b || (c += {
                    center: .5,
                    right: 1
                }[b] * (s - r.width)), (c !== A.x || a !== A.y) && A.attr({
                    x: c,
                    y: a
                }), A.x = c, A.y = a;
            }
            function o(a, b) {
                q ? q.attr(a, b) : F[a] = b;
            }
            function p() {
                A.add(z), z.attr({
                    text: c,
                    x: d,
                    y: e
                }), q && k(g) && z.attr({
                    anchorX: g,
                    anchorY: h
                });
            }
            var q, r, s, t, u, v, w, x, y = this, z = y.g(l), A = y.text("", 0, 0, i).attr({
                zIndex: 1
            }), B = 0, C = 3, D = 0, E = 0, F = {}, i = z.attrSetters;
            hb(z, "add", p), i.width = function(a) {
                return s = a, !1;
            }, i.height = function(a) {
                return t = a, !1;
            }, i.padding = function(a) {
                return k(a) && a !== C && (C = a, n()), !1;
            }, i.paddingLeft = function(a) {
                return k(a) && a !== D && (D = a, n()), !1;
            }, i.align = function(a) {
                return B = {
                    left: 0,
                    center: .5,
                    right: 1
                }[a], !1;
            }, i.text = function(a, b) {
                return A.attr(b, a), m(), n(), !1;
            }, i[Ya] = function(a, b) {
                return x = !0, E = a % 2 / 2, o(b, a), !1;
            }, i.stroke = i.fill = i.r = function(a, b) {
                return "fill" === b && (x = !0), o(b, a), !1;
            }, i.anchorX = function(a, b) {
                return g = a, o(b, a + E - u), !1;
            }, i.anchorY = function(a, b) {
                return h = a, o(b, a - v), !1;
            }, i.x = function(a) {
                return z.x = a, a -= B * ((s || r.width) + C), u = na(a), z.attr("translateX", u), 
                !1;
            }, i.y = function(a) {
                return v = z.y = na(a), z.attr("translateY", v), !1;
            };
            var G = z.css;
            return a(z, {
                css: function(a) {
                    if (a) {
                        var c = {}, a = b(a);
                        db("fontSize,fontWeight,fontFamily,color,lineHeight,width,textDecoration,textShadow".split(","), function(b) {
                            a[b] !== S && (c[b] = a[b], delete a[b]);
                        }), A.css(c);
                    }
                    return G.call(z, a);
                },
                getBBox: function() {
                    return {
                        width: r.width + 2 * C,
                        height: r.height + 2 * C,
                        x: r.x - C,
                        y: r.y - C
                    };
                },
                shadow: function(a) {
                    return q && q.shadow(a), z;
                },
                destroy: function() {
                    ib(z, "add", p), ib(z.element, "mouseenter"), ib(z.element, "mouseleave"), A && (A = A.destroy()), 
                    q && (q = q.destroy()), J.prototype.destroy.call(z), z = y = m = n = o = p = null;
                }
            });
        }
    }, T = pb;
    var qb;
    if (!Fa && !Ha) {
        Highcharts.VMLElement = qb = {
            init: function(a, b) {
                var c = [ "<", b, ' filled="f" stroked="f"' ], d = [ "position: ", "absolute", ";" ], e = b === Na;
                ("shape" === b || e) && d.push("left:0;top:0;width:1px;height:1px;"), d.push("visibility: ", e ? "hidden" : "visible"), 
                c.push(' style="', d.join(""), '"/>'), b && (c = e || "span" === b || "img" === b ? c.join("") : a.prepVML(c), 
                this.element = p(c)), this.renderer = a, this.attrSetters = {};
            },
            add: function(a) {
                var b = this.renderer, c = this.element, d = b.box, d = a ? a.element || a : d;
                return a && a.inverted && b.invertChild(c, d), d.appendChild(c), this.added = !0, 
                this.alignOnAdd && !this.deferUpdateTransform && this.updateTransform(), jb(this, "add"), 
                this;
            },
            updateTransform: J.prototype.htmlUpdateTransform,
            setSpanRotation: function(a, b, c) {
                o(this.element, {
                    filter: a ? [ "progid:DXImageTransform.Microsoft.Matrix(M11=", c, ", M12=", -b, ", M21=", b, ", M22=", c, ", sizingMethod='auto expand')" ].join("") : Oa
                });
            },
            pathToVML: function(a) {
                for (var b, c = a.length, d = []; c--; ) g(a[c]) ? d[c] = na(10 * a[c]) - 5 : "Z" === a[c] ? d[c] = "x" : (d[c] = a[c], 
                !a.isArc || "wa" !== a[c] && "at" !== a[c] || (b = "wa" === a[c] ? 1 : -1, d[c + 5] === d[c + 7] && (d[c + 7] -= b), 
                d[c + 6] === d[c + 8] && (d[c + 8] -= b)));
                return d.join(" ") || "x";
            },
            attr: function(a, b) {
                var c, e, f, h, i, j = this.element || {}, m = j.style, n = j.nodeName, o = this.renderer, q = this.symbolName, r = this.shadows, s = this.attrSetters, t = this;
                if (d(a) && k(b) && (c = a, a = {}, a[c] = b), d(a)) c = a, t = "strokeWidth" === c || "stroke-width" === c ? this.strokeweight : this[c]; else for (c in a) if (e = a[c], 
                i = !1, f = s[c] && s[c].call(this, e, c), f !== !1 && null !== e) {
                    if (f !== S && (e = f), q && /^(x|y|r|start|end|width|height|innerR|anchorX|anchorY)/.test(c)) h || (this.symbolAttr(a), 
                    h = !0), i = !0; else if ("d" === c) {
                        if (e = e || [], this.d = e.join(" "), j.path = e = this.pathToVML(e), r) for (f = r.length; f--; ) r[f].path = r[f].cutOff ? this.cutOffPath(e, r[f].cutOff) : e;
                        i = !0;
                    } else if ("visibility" === c) {
                        if (r) for (f = r.length; f--; ) r[f].style[c] = e;
                        "DIV" === n && (e = "hidden" === e ? "-999em" : 0, Aa || (m[c] = e ? "visible" : "hidden"), 
                        c = "top"), m[c] = e, i = !0;
                    } else "zIndex" === c ? (e && (m[c] = e), i = !0) : cb(c, [ "x", "y", "width", "height" ]) !== -1 ? (this[c] = e, 
                    "x" === c || "y" === c ? c = {
                        x: "left",
                        y: "top"
                    }[c] : e = qa(0, e), this.updateClipping ? (this[c] = e, this.updateClipping()) : m[c] = e, 
                    i = !0) : "class" === c && "DIV" === n ? j.className = e : "stroke" === c ? (e = o.color(e, j, c), 
                    c = "strokecolor") : "stroke-width" === c || "strokeWidth" === c ? (j.stroked = !!e, 
                    c = "strokeweight", this[c] = e, g(e) && (e += "px")) : "dashstyle" === c ? ((j.getElementsByTagName("stroke")[0] || p(o.prepVML([ "<stroke/>" ]), null, null, j))[c] = e || "solid", 
                    this.dashstyle = e, i = !0) : "fill" === c ? "SPAN" === n ? m.color = e : "IMG" !== n && (j.filled = e !== Oa, 
                    e = o.color(e, j, c, this), c = "fillcolor") : "opacity" === c ? i = !0 : "shape" === n && "rotation" === c ? (this[c] = j.style[c] = e, 
                    j.style.left = -na(ua(e * wa) + 1) + "px", j.style.top = na(ta(e * wa)) + "px") : "translateX" === c || "translateY" === c || "rotation" === c ? (this[c] = e, 
                    this.updateTransform(), i = !0) : "text" === c && (this.bBox = null, j.innerHTML = e, 
                    i = !0);
                    i || (Aa ? j[c] = e : l(j, c, e));
                }
                return t;
            },
            clip: function(a) {
                var b, c = this;
                return a ? (b = a.members, j(b, c), b.push(c), c.destroyClip = function() {
                    j(b, c);
                }, a = a.getCSS(c)) : (c.destroyClip && c.destroyClip(), a = {
                    clip: Aa ? "inherit" : "rect(auto)"
                }), c.css(a);
            },
            css: J.prototype.htmlCss,
            safeRemoveChild: function(a) {
                a.parentNode && E(a);
            },
            destroy: function() {
                return this.destroyClip && this.destroyClip(), J.prototype.destroy.apply(this);
            },
            on: function(a, b) {
                return this.element["on" + a] = function() {
                    var a = la.event;
                    a.target = a.srcElement, b(a);
                }, this;
            },
            cutOffPath: function(a, b) {
                var d, a = a.split(/[ ,]/);
                return d = a.length, 9 !== d && 11 !== d || (a[d - 4] = a[d - 2] = c(a[d - 2]) - 10 * b), 
                a.join(" ");
            },
            shadow: function(a, b, d) {
                var e, f, g, h, i, j, k, l = [], m = this.element, o = this.renderer, q = m.style, r = m.path;
                if (r && "string" != typeof r.value && (r = "x"), i = r, a) {
                    for (j = n(a.width, 3), k = (a.opacity || .15) / j, e = 1; e <= 3; e++) h = 2 * j + 1 - 2 * e, 
                    d && (i = this.cutOffPath(r.value, h + .5)), g = [ '<shape isShadow="true" strokeweight="', h, '" filled="false" path="', i, '" coordsize="10 10" style="', m.style.cssText, '" />' ], 
                    f = p(o.prepVML(g), null, {
                        left: c(q.left) + n(a.offsetX, 1),
                        top: c(q.top) + n(a.offsetY, 1)
                    }), d && (f.cutOff = h + 1), g = [ '<stroke color="', a.color || "black", '" opacity="', k * e, '"/>' ], 
                    p(o.prepVML(g), null, null, f), b ? b.element.appendChild(f) : m.parentNode.insertBefore(f, m), 
                    l.push(f);
                    this.shadows = l;
                }
                return this;
            }
        }, qb = q(J, qb);
        var rb = {
            Element: qb,
            isIE8: xa.indexOf("MSIE 8.0") > -1,
            init: function(a, b, c) {
                var d, e;
                this.alignedObjects = [], d = this.createElement(Na), e = d.element, e.style.position = "relative", 
                a.appendChild(d.element), this.isVML = !0, this.box = e, this.boxWrapper = d, this.setSize(b, c, !1), 
                ka.namespaces.hcv || (ka.namespaces.add("hcv", "urn:schemas-microsoft-com:vml"), 
                (ka.styleSheets.length ? ka.styleSheets[0] : ka.createStyleSheet()).cssText += "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } ");
            },
            isHidden: function() {
                return !this.box.offsetWidth;
            },
            clipRect: function(b, c, d, f) {
                var g = this.createElement(), h = e(b);
                return a(g, {
                    members: [],
                    left: (h ? b.x : b) + 1,
                    top: (h ? b.y : c) + 1,
                    width: (h ? b.width : d) - 1,
                    height: (h ? b.height : f) - 1,
                    getCSS: function(b) {
                        var c = b.element, d = c.nodeName, b = b.inverted, e = this.top - ("shape" === d ? c.offsetTop : 0), f = this.left, c = f + this.width, g = e + this.height, e = {
                            clip: "rect(" + na(b ? f : e) + "px," + na(b ? g : c) + "px," + na(b ? c : g) + "px," + na(b ? e : f) + "px)"
                        };
                        return !b && Aa && "DIV" === d && a(e, {
                            width: c + "px",
                            height: g + "px"
                        }), e;
                    },
                    updateClipping: function() {
                        db(g.members, function(a) {
                            a.css(g.getCSS(a));
                        });
                    }
                });
            },
            color: function(a, b, c, d) {
                var e, f, g, h = this, i = /^rgba/, j = Oa;
                if (a && a.linearGradient ? g = "gradient" : a && a.radialGradient && (g = "pattern"), 
                g) {
                    var k, l, m, n, o, q, r, s, t = a.linearGradient || a.radialGradient, u = "", a = a.stops, v = [], w = function() {
                        f = [ '<fill colors="' + v.join(",") + '" opacity="', o, '" o:opacity2="', n, '" type="', g, '" ', u, 'focus="100%" method="any" />' ], 
                        p(h.prepVML(f), null, null, b);
                    };
                    if (m = a[0], s = a[a.length - 1], m[0] > 0 && a.unshift([ 0, m[1] ]), s[0] < 1 && a.push([ 1, s[1] ]), 
                    db(a, function(a, b) {
                        i.test(a[1]) ? (e = ob(a[1]), k = e.get("rgb"), l = e.get("a")) : (k = a[1], l = 1), 
                        v.push(100 * a[0] + "% " + k), b ? (o = l, q = k) : (n = l, r = k);
                    }), "fill" === c) if ("gradient" === g) c = t.x1 || t[0] || 0, a = t.y1 || t[1] || 0, 
                    m = t.x2 || t[2] || 0, t = t.y2 || t[3] || 0, u = 'angle="' + (90 - 180 * ma.atan((t - a) / (m - c)) / va) + '"', 
                    w(); else {
                        var x, j = t.r, y = 2 * j, z = 2 * j, A = t.cx, B = t.cy, C = b.radialReference, j = function() {
                            C && (x = d.getBBox(), A += (C[0] - x.x) / x.width - .5, B += (C[1] - x.y) / x.height - .5, 
                            y *= C[2] / x.width, z *= C[2] / x.height), u = 'src="' + V.global.VMLRadialGradientURL + '" size="' + y + "," + z + '" origin="0.5,0.5" position="' + A + "," + B + '" color2="' + r + '" ', 
                            w();
                        };
                        d.added ? j() : hb(d, "add", j), j = q;
                    } else j = k;
                } else i.test(a) && "IMG" !== b.tagName ? (e = ob(a), f = [ "<", c, ' opacity="', e.get("a"), '"/>' ], 
                p(this.prepVML(f), null, null, b), j = e.get("rgb")) : (j = b.getElementsByTagName(c), 
                j.length && (j[0].opacity = 1, j[0].type = "solid"), j = a);
                return j;
            },
            prepVML: function(a) {
                var b = this.isIE8, a = a.join("");
                return b ? (a = a.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />'), a = a.indexOf('style="') === -1 ? a.replace("/>", ' style="display:inline-block;behavior:url(#default#VML);" />') : a.replace('style="', 'style="display:inline-block;behavior:url(#default#VML);')) : a = a.replace("<", "<hcv:"), 
                a;
            },
            text: pb.prototype.html,
            path: function(b) {
                var c = {
                    coordsize: "10 10"
                };
                return f(b) ? c.d = b : e(b) && a(c, b), this.createElement("shape").attr(c);
            },
            circle: function(a, b, c) {
                var d = this.symbol("circle");
                return e(a) && (c = a.r, b = a.y, a = a.x), d.isCircle = !0, d.r = c, d.attr({
                    x: a,
                    y: b
                });
            },
            g: function(a) {
                var b;
                return a && (b = {
                    className: "highcharts-" + a,
                    class: "highcharts-" + a
                }), this.createElement(Na).attr(b);
            },
            image: function(a, b, c, d, e) {
                var f = this.createElement("img").attr({
                    src: a
                });
                return arguments.length > 1 && f.attr({
                    x: b,
                    y: c,
                    width: d,
                    height: e
                }), f;
            },
            rect: function(a, b, c, d, f, g) {
                var h = this.symbol("rect");
                return h.r = e(a) ? a.r : f, h.attr(e(a) ? a : h.crisp(g, a, b, qa(c, 0), qa(d, 0)));
            },
            invertChild: function(a, b) {
                var d = b.style;
                o(a, {
                    flip: "x",
                    left: c(d.width) - 1,
                    top: c(d.height) - 1,
                    rotation: -90
                });
            },
            symbols: {
                arc: function(a, b, c, d, e) {
                    var f = e.start, g = e.end, h = e.r || c || d, c = e.innerR, d = ta(f), i = ua(f), j = ta(g), k = ua(g);
                    return g - f === 0 ? [ "x" ] : (f = [ "wa", a - h, b - h, a + h, b + h, a + h * d, b + h * i, a + h * j, b + h * k ], 
                    e.open && !c && f.push("e", "M", a, b), f.push("at", a - c, b - c, a + c, b + c, a + c * j, b + c * k, a + c * d, b + c * i, "x", "e"), 
                    f.isArc = !0, f);
                },
                circle: function(a, b, c, d, e) {
                    return e && (c = d = 2 * e.r), e && e.isCircle && (a -= c / 2, b -= d / 2), [ "wa", a, b, a + c, b + d, a + c, b + d / 2, a + c, b + d / 2, "e" ];
                },
                rect: function(a, b, c, d, e) {
                    var f, g = a + c, h = b + d;
                    return k(e) && e.r ? (f = ra(e.r, c, d), g = [ "M", a + f, b, "L", g - f, b, "wa", g - 2 * f, b, g, b + 2 * f, g - f, b, g, b + f, "L", g, h - f, "wa", g - 2 * f, h - 2 * f, g, h, g, h - f, g - f, h, "L", a + f, h, "wa", a, h - 2 * f, a + 2 * f, h, a + f, h, a, h - f, "L", a, b + f, "wa", a, b, a + 2 * f, b + 2 * f, a, b + f, a + f, b, "x", "e" ]) : g = pb.prototype.symbols.square.apply(0, arguments), 
                    g;
                }
            }
        };
        Highcharts.VMLRenderer = qb = function() {
            this.init.apply(this, arguments);
        }, qb.prototype = b(pb.prototype, rb), T = qb;
    }
    var sb;
    Ha && (Highcharts.CanVGRenderer = qb = function() {
        Ea = "http://www.w3.org/1999/xhtml";
    }, qb.prototype.symbols = {}, sb = function() {
        function a() {
            var a, c = b.length;
            for (a = 0; a < c; a++) b[a]();
            b = [];
        }
        var b = [];
        return {
            push: function(c, d) {
                0 === b.length && bb(d, a), b.push(c);
            }
        };
    }(), T = qb), K.prototype = {
        addLabel: function() {
            var b, c = this.axis, d = c.options, e = c.chart, f = c.horiz, h = c.categories, j = c.series[0] && c.series[0].names, l = this.pos, m = d.labels, o = c.tickPositions, f = f && h && !m.step && !m.staggerLines && !m.rotation && e.plotWidth / o.length || !f && (e.margin[3] || .33 * e.chartWidth), p = l === o[0], q = l === o[o.length - 1], j = h ? n(h[l], j && j[l], l) : l, h = this.label, r = o.info;
            c.isDatetimeAxis && r && (b = d.dateTimeLabelFormats[r.higherRanks[l] || r.unitName]), 
            this.isFirst = p, this.isLast = q, d = c.labelFormatter.call({
                axis: c,
                chart: e,
                isFirst: p,
                isLast: q,
                dateTimeLabelFormat: b,
                value: c.isLog ? G(i(j)) : j
            }), l = f && {
                width: qa(1, na(f - 2 * (m.padding || 10))) + "px"
            }, l = a(l, m.style), k(h) ? h && h.attr({
                text: d
            }).css(l) : (b = {
                align: c.labelAlign
            }, g(m.rotation) && (b.rotation = m.rotation), f && m.ellipsis && (b._clipHeight = c.len / o.length), 
            this.label = k(d) && m.enabled ? e.renderer.text(d, 0, 0, m.useHTML).attr(b).css(l).add(c.labelGroup) : null);
        },
        getLabelSize: function() {
            var a = this.label, b = this.axis;
            return a ? (this.labelBBox = a.getBBox())[b.horiz ? "height" : "width"] : 0;
        },
        getLabelSides: function() {
            var a = this.axis, b = this.labelBBox.width, a = b * {
                left: 0,
                center: .5,
                right: 1
            }[a.labelAlign] - a.options.labels.x;
            return [ -a, b - a ];
        },
        handleOverflow: function(a, b) {
            var c = !0, d = this.axis, e = d.chart, f = this.isFirst, g = this.isLast, h = b.x, i = d.reversed, j = d.tickPositions;
            if (f || g) {
                var k = this.getLabelSides(), l = k[0], k = k[1], e = e.plotLeft, m = e + d.len, j = (d = d.ticks[j[a + (f ? 1 : -1)]]) && d.label.xy && d.label.xy.x + d.getLabelSides()[f ? 0 : 1];
                f && !i || g && i ? h + l < e && (h = e - l, d && h + k > j && (c = !1)) : h + k > m && (h = m - k, 
                d && h + l < j && (c = !1)), b.x = h;
            }
            return c;
        },
        getPosition: function(a, b, c, d) {
            var e = this.axis, f = e.chart, g = d && f.oldChartHeight || f.chartHeight;
            return {
                x: a ? e.translate(b + c, null, null, d) + e.transB : e.left + e.offset + (e.opposite ? (d && f.oldChartWidth || f.chartWidth) - e.right - e.left : 0),
                y: a ? g - e.bottom + e.offset - (e.opposite ? e.height : 0) : g - e.translate(b + c, null, null, d) - e.transB
            };
        },
        getLabelPosition: function(a, b, c, d, e, f, g, h) {
            var i = this.axis, j = i.transA, l = i.reversed, m = i.staggerLines, n = i.chart.renderer.fontMetrics(e.style.fontSize).b, o = e.rotation, a = a + e.x - (f && d ? f * j * (l ? -1 : 1) : 0), b = b + e.y - (f && !d ? f * j * (l ? 1 : -1) : 0);
            return o && 2 === i.side && (b -= n - n * ta(o * wa)), !k(e.y) && !o && (b += n - c.getBBox().height / 2), 
            m && (b += g / (h || 1) % m * (i.labelOffset / m)), {
                x: a,
                y: b
            };
        },
        getMarkPath: function(a, b, c, d, e, f) {
            return f.crispLine([ "M", a, b, "L", a + (e ? 0 : -c), b + (e ? c : 0) ], d);
        },
        render: function(a, b, c) {
            var d = this.axis, e = d.options, f = d.chart.renderer, g = d.horiz, h = this.type, i = this.label, j = this.pos, k = e.labels, l = this.gridLine, m = h ? h + "Grid" : "grid", o = h ? h + "Tick" : "tick", p = e[m + "LineWidth"], q = e[m + "LineColor"], r = e[m + "LineDashStyle"], s = e[o + "Length"], m = e[o + "Width"] || 0, t = e[o + "Color"], u = e[o + "Position"], o = this.mark, v = k.step, w = !0, x = d.tickmarkOffset, y = this.getPosition(g, j, x, b), z = y.x, y = y.y, A = g && z === d.pos + d.len || !g && y === d.pos ? -1 : 1, B = d.staggerLines;
            this.isActive = !0, p && (j = d.getPlotLinePath(j + x, p * A, b, !0), l === S && (l = {
                stroke: q,
                "stroke-width": p
            }, r && (l.dashstyle = r), h || (l.zIndex = 1), b && (l.opacity = 0), this.gridLine = l = p ? f.path(j).attr(l).add(d.gridGroup) : null), 
            !b && l && j && l[this.isNew ? "attr" : "animate"]({
                d: j,
                opacity: c
            })), m && s && ("inside" === u && (s = -s), d.opposite && (s = -s), b = this.getMarkPath(z, y, s, m * A, g, f), 
            o ? o.animate({
                d: b,
                opacity: c
            }) : this.mark = f.path(b).attr({
                stroke: t,
                "stroke-width": m,
                opacity: c
            }).add(d.axisGroup)), i && !isNaN(z) && (i.xy = y = this.getLabelPosition(z, y, i, g, k, x, a, v), 
            this.isFirst && !this.isLast && !n(e.showFirstLabel, 1) || this.isLast && !this.isFirst && !n(e.showLastLabel, 1) ? w = !1 : !B && g && "justify" === k.overflow && !this.handleOverflow(a, y) && (w = !1), 
            v && a % v && (w = !1), w && !isNaN(y.y) ? (y.opacity = c, i[this.isNew ? "attr" : "animate"](y), 
            this.isNew = !1) : i.attr("y", -9999));
        },
        destroy: function() {
            D(this, this.axis);
        }
    }, L.prototype = {
        render: function() {
            var a, c = this, d = c.axis, e = d.horiz, f = (d.pointRange || 0) / 2, g = c.options, i = g.label, j = c.label, l = g.width, m = g.to, o = g.from, p = k(o) && k(m), q = g.value, r = g.dashStyle, s = c.svgElem, t = [], u = g.color, v = g.zIndex, w = g.events, x = d.chart.renderer;
            if (d.isLog && (o = h(o), m = h(m), q = h(q)), l) t = d.getPlotLinePath(q, l), f = {
                stroke: u,
                "stroke-width": l
            }, r && (f.dashstyle = r); else {
                if (!p) return;
                o = qa(o, d.min - f), m = ra(m, d.max + f), t = d.getPlotBandPath(o, m, g), f = {
                    fill: u
                }, g.borderWidth && (f.stroke = g.borderColor, f["stroke-width"] = g.borderWidth);
            }
            if (k(v) && (f.zIndex = v), s) t ? s.animate({
                d: t
            }, null, s.onGetPath) : (s.hide(), s.onGetPath = function() {
                s.show();
            }); else if (t && t.length && (c.svgElem = s = x.path(t).attr(f).add(), w)) for (a in g = function(a) {
                s.on(a, function(b) {
                    w[a].apply(c, [ b ]);
                });
            }, w) g(a);
            return i && k(i.text) && t && t.length && d.width > 0 && d.height > 0 ? (i = b({
                align: e && p && "center",
                x: e ? !p && 4 : 10,
                verticalAlign: !e && p && "middle",
                y: e ? p ? 16 : 10 : p ? 6 : -4,
                rotation: e && !p && 90
            }, i), j || (c.label = j = x.text(i.text, 0, 0, i.useHTML).attr({
                align: i.textAlign || i.align,
                rotation: i.rotation,
                zIndex: v
            }).css(i.style).add()), d = [ t[1], t[4], n(t[6], t[1]) ], t = [ t[2], t[5], n(t[7], t[2]) ], 
            e = B(d), p = B(t), j.align(i, !1, {
                x: e,
                y: p,
                width: C(d) - e,
                height: C(t) - p
            }), j.show()) : j && j.hide(), c;
        },
        destroy: function() {
            j(this.axis.plotLinesAndBands, this), delete this.axis, D(this);
        }
    }, M.prototype = {
        destroy: function() {
            D(this, this.axis);
        },
        render: function(a) {
            var b = this.options, c = b.format, c = c ? u(c, this) : b.formatter.call(this);
            this.label ? this.label.attr({
                text: c,
                visibility: "hidden"
            }) : this.label = this.axis.chart.renderer.text(c, 0, 0, b.useHTML).css(b.style).attr({
                align: this.textAlign,
                rotation: b.rotation,
                visibility: "hidden"
            }).add(a);
        },
        setOffset: function(a, b) {
            var c = this.axis, d = c.chart, e = d.inverted, f = this.isNegative, g = c.translate(this.percent ? 100 : this.total, 0, 0, 0, 1), c = c.translate(0), c = sa(g - c), h = d.xAxis[0].translate(this.x) + a, i = d.plotHeight, f = {
                x: e ? f ? g : g - c : h,
                y: e ? i - h - b : f ? i - g - c : i - g,
                width: e ? c : b,
                height: e ? b : c
            };
            (e = this.label) && (e.align(this.alignOptions, null, f), f = e.alignAttr, e.attr({
                visibility: this.options.crop === !1 || d.isInsidePlot(f.x, f.y) ? Fa ? "inherit" : "visible" : "hidden"
            }));
        }
    }, N.prototype = {
        defaultOptions: {
            dateTimeLabelFormats: {
                millisecond: "%H:%M:%S.%L",
                second: "%H:%M:%S",
                minute: "%H:%M",
                hour: "%H:%M",
                day: "%e. %b",
                week: "%e. %b",
                month: "%b '%y",
                year: "%Y"
            },
            endOnTick: !1,
            gridLineColor: "#C0C0C0",
            labels: _a,
            lineColor: "#C0D0E0",
            lineWidth: 1,
            minPadding: .01,
            maxPadding: .01,
            minorGridLineColor: "#E0E0E0",
            minorGridLineWidth: 1,
            minorTickColor: "#A0A0A0",
            minorTickLength: 2,
            minorTickPosition: "outside",
            startOfWeek: 1,
            startOnTick: !1,
            tickColor: "#C0D0E0",
            tickLength: 5,
            tickmarkPlacement: "between",
            tickPixelInterval: 100,
            tickPosition: "outside",
            tickWidth: 1,
            title: {
                align: "middle",
                style: {
                    color: "#4d759e",
                    fontWeight: "bold"
                }
            },
            type: "linear"
        },
        defaultYAxisOptions: {
            endOnTick: !0,
            gridLineWidth: 1,
            tickPixelInterval: 72,
            showLastLabel: !0,
            labels: {
                x: -8,
                y: 3
            },
            lineWidth: 0,
            maxPadding: .05,
            minPadding: .05,
            startOnTick: !0,
            tickWidth: 0,
            title: {
                rotation: 270,
                text: "Values"
            },
            stackLabels: {
                enabled: !1,
                formatter: function() {
                    return r(this.total, -1);
                },
                style: _a.style
            }
        },
        defaultLeftAxisOptions: {
            labels: {
                x: -8,
                y: null
            },
            title: {
                rotation: 270
            }
        },
        defaultRightAxisOptions: {
            labels: {
                x: 8,
                y: null
            },
            title: {
                rotation: 90
            }
        },
        defaultBottomAxisOptions: {
            labels: {
                x: 0,
                y: 14
            },
            title: {
                rotation: 0
            }
        },
        defaultTopAxisOptions: {
            labels: {
                x: 0,
                y: -5
            },
            title: {
                rotation: 0
            }
        },
        init: function(a, b) {
            var c = b.isX;
            this.horiz = a.inverted ? !c : c, this.xOrY = (this.isXAxis = c) ? "x" : "y", this.opposite = b.opposite, 
            this.side = this.horiz ? this.opposite ? 0 : 2 : this.opposite ? 1 : 3, this.setOptions(b);
            var d = this.options, e = d.type;
            this.labelFormatter = d.labels.formatter || this.defaultLabelFormatter, this.userOptions = b, 
            this.minPixelPadding = 0, this.chart = a, this.reversed = d.reversed, this.zoomEnabled = d.zoomEnabled !== !1, 
            this.categories = d.categories || "category" === e, this.isLog = "logarithmic" === e, 
            this.isDatetimeAxis = "datetime" === e, this.isLinked = k(d.linkedTo), this.tickmarkOffset = this.categories && "between" === d.tickmarkPlacement ? .5 : 0, 
            this.ticks = {}, this.minorTicks = {}, this.plotLinesAndBands = [], this.alternateBands = {}, 
            this.len = 0, this.minRange = this.userMinRange = d.minRange || d.maxZoom, this.range = d.range, 
            this.offset = d.offset || 0, this.stacks = {}, this.oldStacks = {}, this.stackExtremes = {}, 
            this.min = this.max = null;
            var f, d = this.options.events;
            cb(this, a.axes) === -1 && (a.axes.push(this), a[c ? "xAxis" : "yAxis"].push(this)), 
            this.series = this.series || [], a.inverted && c && this.reversed === S && (this.reversed = !0), 
            this.removePlotLine = this.removePlotBand = this.removePlotBandOrLine;
            for (f in d) hb(this, f, d[f]);
            this.isLog && (this.val2lin = h, this.lin2val = i);
        },
        setOptions: function(a) {
            this.options = b(this.defaultOptions, this.isXAxis ? {} : this.defaultYAxisOptions, [ this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions ][this.side], b(V[this.isXAxis ? "xAxis" : "yAxis"], a));
        },
        update: function(c, d) {
            var e = this.chart, c = e.options[this.xOrY + "Axis"][this.options.index] = b(this.userOptions, c);
            this.destroy(!0), this._addedPlotLB = this.userMin = this.userMax = S, this.init(e, a(c, {
                events: S
            })), e.isDirtyBox = !0, n(d, !0) && e.redraw();
        },
        remove: function(a) {
            var b = this.chart, c = this.xOrY + "Axis";
            db(this.series, function(a) {
                a.remove(!1);
            }), j(b.axes, this), j(b[c], this), b.options[c].splice(this.options.index, 1), 
            db(b[c], function(a, b) {
                a.options.index = b;
            }), this.destroy(), b.isDirtyBox = !0, n(a, !0) && b.redraw();
        },
        defaultLabelFormatter: function() {
            var a, b = this.axis, c = this.value, d = b.categories, e = this.dateTimeLabelFormat, f = V.lang.numericSymbols, g = f && f.length, h = b.options.labels.format, b = b.isLog ? c : b.tickInterval;
            if (h) a = u(h, this); else if (d) a = c; else if (e) a = W(e, c); else if (g && b >= 1e3) for (;g-- && a === S; ) d = Math.pow(1e3, g + 1), 
            b >= d && null !== f[g] && (a = r(c / d, -1) + f[g]);
            return a === S && (a = c >= 1e3 ? r(c, 0) : r(c, -1)), a;
        },
        getSeriesExtremes: function() {
            var a = this, b = a.chart;
            a.hasVisibleSeries = !1, a.dataMin = a.dataMax = null, a.stackExtremes = {}, a.buildStacks(), 
            db(a.series, function(c) {
                if (c.visible || !b.options.chart.ignoreHiddenSeries) {
                    var d;
                    d = c.options.threshold;
                    var e;
                    a.hasVisibleSeries = !0, a.isLog && d <= 0 && (d = null), a.isXAxis ? (d = c.xData, 
                    d.length && (a.dataMin = ra(n(a.dataMin, d[0]), B(d)), a.dataMax = qa(n(a.dataMax, d[0]), C(d)))) : (c.getExtremes(), 
                    e = c.dataMax, c = c.dataMin, k(c) && k(e) && (a.dataMin = ra(n(a.dataMin, c), c), 
                    a.dataMax = qa(n(a.dataMax, e), e)), k(d) && (a.dataMin >= d ? (a.dataMin = d, a.ignoreMinPadding = !0) : a.dataMax < d && (a.dataMax = d, 
                    a.ignoreMaxPadding = !0)));
                }
            });
        },
        translate: function(a, b, c, d, e, f) {
            var h = this.len, i = 1, j = 0, k = d ? this.oldTransA : this.transA, d = d ? this.oldMin : this.min, l = this.minPixelPadding, e = (this.options.ordinal || this.isLog && e) && this.lin2val;
            return k || (k = this.transA), c && (i *= -1, j = h), this.reversed && (i *= -1, 
            j -= i * h), b ? (a = a * i + j, a -= l, a = a / k + d, e && (a = this.lin2val(a))) : (e && (a = this.val2lin(a)), 
            "between" === f && (f = .5), a = i * (a - d) * k + j + i * l + (g(f) ? k * f * this.pointRange : 0)), 
            a;
        },
        toPixels: function(a, b) {
            return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);
        },
        toValue: function(a, b) {
            return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);
        },
        getPlotLinePath: function(a, b, c, d) {
            var e, f, g, h, i = this.chart, j = this.left, k = this.top, a = this.translate(a, null, null, c), l = c && i.oldChartHeight || i.chartHeight, m = c && i.oldChartWidth || i.chartWidth;
            return e = this.transB, c = f = na(a + e), e = g = na(l - a - e), isNaN(a) ? h = !0 : this.horiz ? (e = k, 
            g = l - this.bottom, (c < j || c > j + this.width) && (h = !0)) : (c = j, f = m - this.right, 
            (e < k || e > k + this.height) && (h = !0)), h && !d ? null : i.renderer.crispLine([ "M", c, e, "L", f, g ], b || 0);
        },
        getPlotBandPath: function(a, b) {
            var c = this.getPlotLinePath(b), d = this.getPlotLinePath(a);
            return d && c ? d.push(c[4], c[5], c[1], c[2]) : d = null, d;
        },
        getLinearTickPositions: function(a, b, c) {
            for (var d, b = G(oa(b / a) * a), c = G(pa(c / a) * a), e = []; b <= c && (e.push(b), 
            b = G(b + a), b !== d); ) d = b;
            return e;
        },
        getLogTickPositions: function(a, b, c, d) {
            var e = this.options, f = this.len, g = [];
            if (d || (this._minorAutoInterval = null), a >= .5) a = na(a), g = this.getLinearTickPositions(a, b, c); else if (a >= .08) for (var j, k, l, m, o, f = oa(b), e = a > .3 ? [ 1, 2, 4 ] : a > .15 ? [ 1, 2, 4, 6, 8 ] : [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]; f < c + 1 && !o; f++) for (k = e.length, 
            j = 0; j < k && !o; j++) l = h(i(f) * e[j]), l > b && (!d || m <= c) && g.push(m), 
            m > c && (o = !0), m = l; else b = i(b), c = i(c), a = e[d ? "minorTickInterval" : "tickInterval"], 
            a = n("auto" === a ? null : a, this._minorAutoInterval, (c - b) * (e.tickPixelInterval / (d ? 5 : 1)) / ((d ? f / this.tickPositions.length : f) || 1)), 
            a = w(a, null, v(a)), g = gb(this.getLinearTickPositions(a, b, c), h), d || (this._minorAutoInterval = a / 5);
            return d || (this.tickInterval = a), g;
        },
        getMinorTickPositions: function() {
            var a, b = this.options, c = this.tickPositions, d = this.minorTickInterval, e = [];
            if (this.isLog) for (a = c.length, b = 1; b < a; b++) e = e.concat(this.getLogTickPositions(d, c[b - 1], c[b], !0)); else if (this.isDatetimeAxis && "auto" === b.minorTickInterval) e = e.concat(y(x(d), this.min, this.max, b.startOfWeek)), 
            e[0] < this.min && e.shift(); else for (c = this.min + (c[0] - this.min) % d; c <= this.max; c += d) e.push(c);
            return e;
        },
        adjustForMinRange: function() {
            var a, b, c, d, e, f, g = this.options, h = this.min, i = this.max, j = this.dataMax - this.dataMin >= this.minRange;
            if (this.isXAxis && this.minRange === S && !this.isLog && (k(g.min) || k(g.max) ? this.minRange = null : (db(this.series, function(a) {
                for (e = a.xData, c = f = a.xIncrement ? 1 : e.length - 1; c > 0; c--) d = e[c] - e[c - 1], 
                (b === S || d < b) && (b = d);
            }), this.minRange = ra(5 * b, this.dataMax - this.dataMin))), i - h < this.minRange) {
                var l = this.minRange;
                a = (l - i + h) / 2, a = [ h - a, n(g.min, h - a) ], j && (a[2] = this.dataMin), 
                h = C(a), i = [ h + l, n(g.max, h + l) ], j && (i[2] = this.dataMax), i = B(i), 
                i - h < l && (a[0] = i - l, a[1] = n(g.min, i - l), h = C(a));
            }
            this.min = h, this.max = i;
        },
        setAxisTranslation: function(a) {
            var b, c = this.max - this.min, e = 0, f = 0, g = 0, h = this.linkedParent, i = this.transA;
            this.isXAxis && (h ? (f = h.minPointOffset, g = h.pointRangePadding) : db(this.series, function(a) {
                var h = a.pointRange, i = a.options.pointPlacement, j = a.closestPointRange;
                h > c && (h = 0), e = qa(e, h), f = qa(f, d(i) ? 0 : h / 2), g = qa(g, "on" === i ? 0 : h), 
                !a.noSharedTooltip && k(j) && (b = k(b) ? ra(b, j) : j);
            }), h = this.ordinalSlope && b ? this.ordinalSlope / b : 1, this.minPointOffset = f *= h, 
            this.pointRangePadding = g *= h, this.pointRange = ra(e, c), this.closestPointRange = b), 
            a && (this.oldTransA = i), this.translationSlope = this.transA = i = this.len / (c + g || 1), 
            this.transB = this.horiz ? this.left : this.bottom, this.minPixelPadding = i * f;
        },
        setTickPositions: function(a) {
            var b, c = this, d = c.chart, e = c.options, f = c.isLog, g = c.isDatetimeAxis, i = c.isXAxis, j = c.isLinked, l = c.options.tickPositioner, m = e.maxPadding, o = e.minPadding, p = e.tickInterval, q = e.minTickInterval, r = e.tickPixelInterval, s = c.categories;
            j ? (c.linkedParent = d[i ? "xAxis" : "yAxis"][e.linkedTo], d = c.linkedParent.getExtremes(), 
            c.min = n(d.min, d.dataMin), c.max = n(d.max, d.dataMax), e.type !== c.linkedParent.options.type && F(11, 1)) : (c.min = n(c.userMin, e.min, c.dataMin), 
            c.max = n(c.userMax, e.max, c.dataMax)), f && (!a && ra(c.min, n(c.dataMin, c.min)) <= 0 && F(10, 1), 
            c.min = G(h(c.min)), c.max = G(h(c.max))), c.range && (c.userMin = c.min = qa(c.min, c.max - c.range), 
            c.userMax = c.max, a) && (c.range = null), c.beforePadding && c.beforePadding(), 
            c.adjustForMinRange(), !s && !c.usePercentage && !j && k(c.min) && k(c.max) && (d = c.max - c.min) && (k(e.min) || k(c.userMin) || !o || !(c.dataMin < 0) && c.ignoreMinPadding || (c.min -= d * o), 
            k(e.max) || k(c.userMax) || !m || !(c.dataMax > 0) && c.ignoreMaxPadding || (c.max += d * m)), 
            c.min === c.max || void 0 === c.min || void 0 === c.max ? c.tickInterval = 1 : j && !p && r === c.linkedParent.options.tickPixelInterval ? c.tickInterval = c.linkedParent.tickInterval : (c.tickInterval = n(p, s ? 1 : (c.max - c.min) * r / qa(c.len, r)), 
            !k(p) && c.len < r && !this.isRadial && (b = !0, c.tickInterval /= 4)), i && !a && db(c.series, function(a) {
                a.processData(c.min !== c.oldMin || c.max !== c.oldMax);
            }), c.setAxisTranslation(!0), c.beforeSetTickPositions && c.beforeSetTickPositions(), 
            c.postProcessTickInterval && (c.tickInterval = c.postProcessTickInterval(c.tickInterval)), 
            c.pointRange && (c.tickInterval = qa(c.pointRange, c.tickInterval)), !p && c.tickInterval < q && (c.tickInterval = q), 
            g || f || p || (c.tickInterval = w(c.tickInterval, null, v(c.tickInterval), e)), 
            c.minorTickInterval = "auto" === e.minorTickInterval && c.tickInterval ? c.tickInterval / 5 : e.minorTickInterval, 
            c.tickPositions = a = e.tickPositions ? [].concat(e.tickPositions) : l && l.apply(c, [ c.min, c.max ]), 
            a || (!c.ordinalPositions && (c.max - c.min) / c.tickInterval > qa(2 * c.len, 200) && F(19, !0), 
            a = g ? (c.getNonLinearTimeTicks || y)(x(c.tickInterval, e.units), c.min, c.max, e.startOfWeek, c.ordinalPositions, c.closestPointRange, !0) : f ? c.getLogTickPositions(c.tickInterval, c.min, c.max) : c.getLinearTickPositions(c.tickInterval, c.min, c.max), 
            b && a.splice(1, a.length - 2), c.tickPositions = a), j || (f = a[0], g = a[a.length - 1], 
            j = c.minPointOffset || 0, e.startOnTick ? c.min = f : c.min - j > f && a.shift(), 
            e.endOnTick ? c.max = g : c.max + j < g && a.pop(), 1 === a.length && (c.min -= .001, 
            c.max += .001));
        },
        setMaxTicks: function() {
            var a = this.chart, b = a.maxTicks || {}, c = this.tickPositions, d = this._maxTicksKey = [ this.xOrY, this.pos, this.len ].join("-");
            !this.isLinked && !this.isDatetimeAxis && c && c.length > (b[d] || 0) && this.options.alignTicks !== !1 && (b[d] = c.length), 
            a.maxTicks = b;
        },
        adjustTickAmount: function() {
            var a = this._maxTicksKey, b = this.tickPositions, c = this.chart.maxTicks;
            if (c && c[a] && !this.isDatetimeAxis && !this.categories && !this.isLinked && this.options.alignTicks !== !1) {
                var d = this.tickAmount, e = b.length;
                if (this.tickAmount = a = c[a], e < a) {
                    for (;b.length < a; ) b.push(G(b[b.length - 1] + this.tickInterval));
                    this.transA *= (e - 1) / (a - 1), this.max = b[b.length - 1];
                }
                k(d) && a !== d && (this.isDirty = !0);
            }
        },
        setScale: function() {
            var a, b, c, d, e = this.stacks;
            if (this.oldMin = this.min, this.oldMax = this.max, this.oldAxisLength = this.len, 
            this.setAxisSize(), d = this.len !== this.oldAxisLength, db(this.series, function(a) {
                (a.isDirtyData || a.isDirty || a.xAxis.isDirty) && (c = !0);
            }), d || c || this.isLinked || this.forceRedraw || this.userMin !== this.oldUserMin || this.userMax !== this.oldUserMax) {
                if (!this.isXAxis) for (a in e) delete e[a];
                this.forceRedraw = !1, this.getSeriesExtremes(), this.setTickPositions(), this.oldUserMin = this.userMin, 
                this.oldUserMax = this.userMax, this.isDirty || (this.isDirty = d || this.min !== this.oldMin || this.max !== this.oldMax);
            } else if (!this.isXAxis) {
                this.oldStacks && (e = this.stacks = this.oldStacks);
                for (a in e) for (b in e[a]) e[a][b].cum = e[a][b].total;
            }
            this.setMaxTicks();
        },
        setExtremes: function(b, c, d, e, f) {
            var g = this, h = g.chart, d = n(d, !0), f = a(f, {
                min: b,
                max: c
            });
            jb(g, "setExtremes", f, function() {
                g.userMin = b, g.userMax = c, g.eventArgs = f, g.isDirtyExtremes = !0, d && h.redraw(e);
            });
        },
        zoom: function(a, b) {
            return this.allowZoomOutside || (k(this.dataMin) && a <= this.dataMin && (a = S), 
            k(this.dataMax) && b >= this.dataMax && (b = S)), this.displayBtn = a !== S || b !== S, 
            this.setExtremes(a, b, !1, S, {
                trigger: "zoom"
            }), !0;
        },
        setAxisSize: function() {
            var a, b, c = this.chart, d = this.options, e = d.offsetLeft || 0, f = d.offsetRight || 0, g = this.horiz;
            this.left = b = n(d.left, c.plotLeft + e), this.top = a = n(d.top, c.plotTop), this.width = e = n(d.width, c.plotWidth - e + f), 
            this.height = d = n(d.height, c.plotHeight), this.bottom = c.chartHeight - d - a, 
            this.right = c.chartWidth - e - b, this.len = qa(g ? e : d, 0), this.pos = g ? b : a;
        },
        getExtremes: function() {
            var a = this.isLog;
            return {
                min: a ? G(i(this.min)) : this.min,
                max: a ? G(i(this.max)) : this.max,
                dataMin: this.dataMin,
                dataMax: this.dataMax,
                userMin: this.userMin,
                userMax: this.userMax
            };
        },
        getThreshold: function(a) {
            var b = this.isLog, c = b ? i(this.min) : this.min, b = b ? i(this.max) : this.max;
            return c > a || null === a ? a = c : b < a && (a = b), this.translate(a, 0, 1, 0, 1);
        },
        addPlotBand: function(a) {
            this.addPlotBandOrLine(a, "plotBands");
        },
        addPlotLine: function(a) {
            this.addPlotBandOrLine(a, "plotLines");
        },
        addPlotBandOrLine: function(a, b) {
            var c = new L(this, a).render(), d = this.userOptions;
            return c && (b && (d[b] = d[b] || [], d[b].push(a)), this.plotLinesAndBands.push(c)), 
            c;
        },
        autoLabelAlign: function(a) {
            return a = (n(a, 0) - 90 * this.side + 720) % 360, a > 15 && a < 165 ? "right" : a > 195 && a < 345 ? "left" : "center";
        },
        getOffset: function() {
            var a, b, c, d, e, f, g, h = this, i = h.chart, j = i.renderer, l = h.options, m = h.tickPositions, o = h.ticks, p = h.horiz, q = h.side, r = i.inverted ? [ 1, 0, 3, 2 ][q] : q, s = 0, t = 0, u = l.title, v = l.labels, w = 0, x = i.axisOffset, y = i.clipOffset, z = [ -1, 1, 1, -1 ][q], A = 1, B = n(v.maxStaggerLines, 5);
            if (h.hasData = a = h.hasVisibleSeries || k(h.min) && k(h.max) && !!m, h.showAxis = i = a || n(l.showEmpty, !0), 
            h.staggerLines = h.horiz && v.staggerLines, h.axisGroup || (h.gridGroup = j.g("grid").attr({
                zIndex: l.gridZIndex || 1
            }).add(), h.axisGroup = j.g("axis").attr({
                zIndex: l.zIndex || 2
            }).add(), h.labelGroup = j.g("axis-labels").attr({
                zIndex: v.zIndex || 7
            }).add()), a || h.isLinked) {
                if (h.labelAlign = n(v.align || h.autoLabelAlign(v.rotation)), db(m, function(a) {
                    o[a] ? o[a].addLabel() : o[a] = new K(h, a);
                }), h.horiz && !h.staggerLines && B && !v.rotation) {
                    for (c = h.reversed ? [].concat(m).reverse() : m; A < B; ) {
                        for (a = [], d = !1, v = 0; v < c.length; v++) e = c[v], f = (f = o[e].label && o[e].label.getBBox()) ? f.width : 0, 
                        g = v % A, f && (e = h.translate(e), a[g] !== S && e < a[g] && (d = !0), a[g] = e + f);
                        if (!d) break;
                        A++;
                    }
                    A > 1 && (h.staggerLines = A);
                }
                db(m, function(a) {
                    0 !== q && 2 !== q && {
                        1: "left",
                        3: "right"
                    }[q] !== h.labelAlign || (w = qa(o[a].getLabelSize(), w));
                }), h.staggerLines && (w *= h.staggerLines, h.labelOffset = w);
            } else for (c in o) o[c].destroy(), delete o[c];
            u && u.text && u.enabled !== !1 && (h.axisTitle || (h.axisTitle = j.text(u.text, 0, 0, u.useHTML).attr({
                zIndex: 7,
                rotation: u.rotation || 0,
                align: u.textAlign || {
                    low: "left",
                    middle: "center",
                    high: "right"
                }[u.align]
            }).css(u.style).add(h.axisGroup), h.axisTitle.isNew = !0), i && (s = h.axisTitle.getBBox()[p ? "height" : "width"], 
            t = n(u.margin, p ? 5 : 10), b = u.offset), h.axisTitle[i ? "show" : "hide"]()), 
            h.offset = z * n(l.offset, x[q]), h.axisTitleMargin = n(b, w + t + (2 !== q && w && z * l.labels[p ? "y" : "x"])), 
            x[q] = qa(x[q], h.axisTitleMargin + s + z * h.offset), y[r] = qa(y[r], 2 * oa(l.lineWidth / 2));
        },
        getLinePath: function(a) {
            var b = this.chart, c = this.opposite, d = this.offset, e = this.horiz, f = this.left + (c ? this.width : 0) + d, d = b.chartHeight - this.bottom - (c ? this.height : 0) + d;
            return c && (a *= -1), b.renderer.crispLine([ "M", e ? this.left : f, e ? d : this.top, "L", e ? b.chartWidth - this.right : f, e ? d : b.chartHeight - this.bottom ], a);
        },
        getTitlePosition: function() {
            var a = this.horiz, b = this.left, d = this.top, e = this.len, f = this.options.title, g = a ? b : d, h = this.opposite, i = this.offset, j = c(f.style.fontSize || 12), e = {
                low: g + (a ? 0 : e),
                middle: g + e / 2,
                high: g + (a ? e : 0)
            }[f.align], b = (a ? d + this.height : b) + (a ? 1 : -1) * (h ? -1 : 1) * this.axisTitleMargin + (2 === this.side ? j : 0);
            return {
                x: a ? e : b + (h ? this.width : 0) + i + (f.x || 0),
                y: a ? b - (h ? this.height : 0) + i : e + (f.y || 0)
            };
        },
        render: function() {
            var a, b = this, c = b.chart, d = c.renderer, e = b.options, f = b.isLog, g = b.isLinked, h = b.tickPositions, j = b.axisTitle, l = b.stacks, m = b.ticks, n = b.minorTicks, o = b.alternateBands, p = e.stackLabels, q = e.alternateGridColor, r = b.tickmarkOffset, s = e.lineWidth, t = c.hasRendered && k(b.oldMin) && !isNaN(b.oldMin);
            a = b.hasData;
            var u, v, w = b.showAxis;
            if (db([ m, n, o ], function(a) {
                for (var b in a) a[b].isActive = !1;
            }), (a || g) && (b.minorTickInterval && !b.categories && db(b.getMinorTickPositions(), function(a) {
                n[a] || (n[a] = new K(b, a, "minor")), t && n[a].isNew && n[a].render(null, !0), 
                n[a].render(null, !1, 1);
            }), h.length && (db(h.slice(1).concat([ h[0] ]), function(a, c) {
                c = c === h.length - 1 ? 0 : c + 1, (!g || a >= b.min && a <= b.max) && (m[a] || (m[a] = new K(b, a)), 
                t && m[a].isNew && m[a].render(c, !0), m[a].render(c, !1, 1));
            }), r && 0 === b.min && (m[-1] || (m[-1] = new K(b, (-1), null, (!0))), m[-1].render(-1))), 
            q && db(h, function(a, c) {
                c % 2 === 0 && a < b.max && (o[a] || (o[a] = new L(b)), u = a + r, v = h[c + 1] !== S ? h[c + 1] + r : b.max, 
                o[a].options = {
                    from: f ? i(u) : u,
                    to: f ? i(v) : v,
                    color: q
                }, o[a].render(), o[a].isActive = !0);
            }), b._addedPlotLB || (db((e.plotLines || []).concat(e.plotBands || []), function(a) {
                b.addPlotBandOrLine(a);
            }), b._addedPlotLB = !0)), db([ m, n, o ], function(a) {
                var b, d, e = [], f = X ? X.duration || 500 : 0, g = function() {
                    for (d = e.length; d--; ) a[e[d]] && !a[e[d]].isActive && (a[e[d]].destroy(), delete a[e[d]]);
                };
                for (b in a) a[b].isActive || (a[b].render(b, !1, 0), a[b].isActive = !1, e.push(b));
                a !== o && c.hasRendered && f ? f && setTimeout(g, f) : g();
            }), s && (a = b.getLinePath(s), b.axisLine ? b.axisLine.animate({
                d: a
            }) : b.axisLine = d.path(a).attr({
                stroke: e.lineColor,
                "stroke-width": s,
                zIndex: 7
            }).add(b.axisGroup), b.axisLine[w ? "show" : "hide"]()), j && w && (j[j.isNew ? "attr" : "animate"](b.getTitlePosition()), 
            j.isNew = !1), p && p.enabled) {
                var x, y, e = b.stackTotalGroup;
                e || (b.stackTotalGroup = e = d.g("stack-labels").attr({
                    visibility: "visible",
                    zIndex: 6
                }).add()), e.translate(c.plotLeft, c.plotTop);
                for (x in l) for (y in d = l[x]) d[y].render(e);
            }
            b.isDirty = !1;
        },
        removePlotBandOrLine: function(a) {
            for (var b = this.plotLinesAndBands, c = this.options, d = this.userOptions, e = b.length; e--; ) b[e].id === a && b[e].destroy();
            db([ c.plotLines || [], d.plotLines || [], c.plotBands || [], d.plotBands || [] ], function(b) {
                for (e = b.length; e--; ) b[e].id === a && j(b, b[e]);
            });
        },
        setTitle: function(a, b) {
            this.update({
                title: a
            }, b);
        },
        redraw: function() {
            var a = this.chart.pointer;
            a.reset && a.reset(!0), this.render(), db(this.plotLinesAndBands, function(a) {
                a.render();
            }), db(this.series, function(a) {
                a.isDirty = !0;
            });
        },
        buildStacks: function() {
            var a = this.series, b = a.length;
            if (!this.isXAxis) {
                for (;b--; ) a[b].setStackedPoints();
                if (this.usePercentage) for (b = 0; b < a.length; b++) a[b].setPercentStacks();
            }
        },
        setCategories: function(a, b) {
            this.update({
                categories: a
            }, b);
        },
        destroy: function(a) {
            var b, c = this, d = c.stacks, e = c.plotLinesAndBands;
            a || ib(c);
            for (b in d) D(d[b]), d[b] = null;
            for (db([ c.ticks, c.minorTicks, c.alternateBands ], function(a) {
                D(a);
            }), a = e.length; a--; ) e[a].destroy();
            db("stackTotalGroup,axisLine,axisGroup,gridGroup,labelGroup,axisTitle".split(","), function(a) {
                c[a] && (c[a] = c[a].destroy());
            });
        }
    }, O.prototype = {
        init: function(a, b) {
            var d = b.borderWidth, e = b.style, f = c(e.padding);
            this.chart = a, this.options = b, this.crosshairs = [], this.now = {
                x: 0,
                y: 0
            }, this.isHidden = !0, this.label = a.renderer.label("", 0, 0, b.shape, null, null, b.useHTML, null, "tooltip").attr({
                padding: f,
                fill: b.backgroundColor,
                "stroke-width": d,
                r: b.borderRadius,
                zIndex: 8
            }).css(e).css({
                padding: 0
            }).add().attr({
                y: -999
            }), Ha || this.label.shadow(b.shadow), this.shared = b.shared;
        },
        destroy: function() {
            db(this.crosshairs, function(a) {
                a && a.destroy();
            }), this.label && (this.label = this.label.destroy()), clearTimeout(this.hideTimer), 
            clearTimeout(this.tooltipTimeout);
        },
        move: function(b, c, d, e) {
            var f = this, g = f.now, h = f.options.animation !== !1 && !f.isHidden;
            a(g, {
                x: h ? (2 * g.x + b) / 3 : b,
                y: h ? (g.y + c) / 2 : c,
                anchorX: h ? (2 * g.anchorX + d) / 3 : d,
                anchorY: h ? (g.anchorY + e) / 2 : e
            }), f.label.attr(g), h && (sa(b - g.x) > 1 || sa(c - g.y) > 1) && (clearTimeout(this.tooltipTimeout), 
            this.tooltipTimeout = setTimeout(function() {
                f && f.move(b, c, d, e);
            }, 32));
        },
        hide: function() {
            var a, b = this;
            clearTimeout(this.hideTimer), this.isHidden || (a = this.chart.hoverPoints, this.hideTimer = setTimeout(function() {
                b.label.fadeOut(), b.isHidden = !0;
            }, n(this.options.hideDelay, 500)), a && db(a, function(a) {
                a.setState();
            }), this.chart.hoverPoints = null);
        },
        hideCrosshairs: function() {
            db(this.crosshairs, function(a) {
                a && a.hide();
            });
        },
        getAnchor: function(a, b) {
            var c, d, e = this.chart, f = e.inverted, g = e.plotTop, h = 0, i = 0, a = m(a);
            return c = a[0].tooltipPos, this.followPointer && b && (b.chartX === S && (b = e.pointer.normalize(b)), 
            c = [ b.chartX - e.plotLeft, b.chartY - g ]), c || (db(a, function(a) {
                d = a.series.yAxis, h += a.plotX, i += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!f && d ? d.top - g : 0);
            }), h /= a.length, i /= a.length, c = [ f ? e.plotWidth - i : h, this.shared && !f && a.length > 1 && b ? b.chartY - g : f ? e.plotHeight - h : i ]), 
            gb(c, na);
        },
        getPosition: function(a, b, c) {
            var d, e = this.chart, f = e.plotLeft, g = e.plotTop, h = e.plotWidth, i = e.plotHeight, j = n(this.options.distance, 12), k = c.plotX, c = c.plotY, e = k + f + (e.inverted ? j : -a - j), l = c - b + g + 15;
            return e < 7 && (e = f + qa(k, 0) + j), e + a > f + h && (e -= e + a - (f + h), 
            l = c - b + g - j, d = !0), l < g + 5 && (l = g + 5, d && c >= l && c <= l + b && (l = c + g + j)), 
            l + b > g + i && (l = qa(g, g + i - b - j)), {
                x: e,
                y: l
            };
        },
        defaultFormatter: function(a) {
            var b, c = this.points || m(this), d = c[0].series;
            return b = [ d.tooltipHeaderFormatter(c[0]) ], db(c, function(a) {
                d = a.series, b.push(d.tooltipFormatter && d.tooltipFormatter(a) || a.point.tooltipFormatter(d.tooltipOptions.pointFormat));
            }), b.push(a.options.footerFormat || ""), b.join("");
        },
        refresh: function(a, b) {
            var c, d, e, f = this.chart, g = this.label, i = this.options, j = {}, k = [];
            e = i.formatter || this.defaultFormatter;
            var l, j = f.hoverPoints, o = i.crosshairs, p = this.shared;
            if (clearTimeout(this.hideTimer), this.followPointer = m(a)[0].series.tooltipOptions.followPointer, 
            d = this.getAnchor(a, b), c = d[0], d = d[1], !p || a.series && a.series.noSharedTooltip ? j = a.getLabelConfig() : (f.hoverPoints = a, 
            j && db(j, function(a) {
                a.setState();
            }), db(a, function(a) {
                a.setState("hover"), k.push(a.getLabelConfig());
            }), j = {
                x: a[0].category,
                y: a[0].y
            }, j.points = k, a = a[0]), e = e.call(j, this), j = a.series, e === !1 ? this.hide() : (this.isHidden && (mb(g), 
            g.attr("opacity", 1).show()), g.attr({
                text: e
            }), l = i.borderColor || a.color || j.color || "#606060", g.attr({
                stroke: l
            }), this.updatePosition({
                plotX: c,
                plotY: d
            }), this.isHidden = !1), o) for (o = m(o), g = o.length; g--; ) p = a.series, i = p[g ? "yAxis" : "xAxis"], 
            o[g] && i && (j = g ? n(a.stackY, a.y) : a.x, i.isLog && (j = h(j)), 1 === g && p.modifyValue && (j = p.modifyValue(j)), 
            i = i.getPlotLinePath(j, 1), this.crosshairs[g] ? this.crosshairs[g].attr({
                d: i,
                visibility: "visible"
            }) : (j = {
                "stroke-width": o[g].width || 1,
                stroke: o[g].color || "#C0C0C0",
                zIndex: o[g].zIndex || 2
            }, o[g].dashStyle && (j.dashstyle = o[g].dashStyle), this.crosshairs[g] = f.renderer.path(i).attr(j).add()));
            jb(f, "tooltipRefresh", {
                text: e,
                x: c + f.plotLeft,
                y: d + f.plotTop,
                borderColor: l
            });
        },
        updatePosition: function(a) {
            var b = this.chart, c = this.label, c = (this.options.positioner || this.getPosition).call(this, c.width, c.height, a);
            this.move(na(c.x), na(c.y), a.plotX + b.plotLeft, a.plotY + b.plotTop);
        }
    }, P.prototype = {
        init: function(a, b) {
            var c, d = b.chart, e = d.events, f = Ha ? "" : d.zoomType, d = a.inverted;
            this.options = b, this.chart = a, this.zoomX = c = /x/.test(f), this.zoomY = f = /y/.test(f), 
            this.zoomHor = c && !d || f && d, this.zoomVert = f && !d || c && d, this.runChartClick = e && !!e.click, 
            this.pinchDown = [], this.lastValidTouch = {}, b.tooltip.enabled && (a.tooltip = new O(a, b.tooltip)), 
            this.setDOMEvents();
        },
        normalize: function(b, c) {
            var d, e, b = b || la.event;
            return b.target || (b.target = b.srcElement), b = kb(b), e = b.touches ? b.touches.item(0) : b, 
            c || (this.chartPosition = c = fb(this.chart.container)), e.pageX === S ? (d = qa(b.x, b.clientX - c.left), 
            e = b.y) : (d = e.pageX - c.left, e = e.pageY - c.top), a(b, {
                chartX: na(d),
                chartY: na(e)
            });
        },
        getCoordinates: function(a) {
            var b = {
                xAxis: [],
                yAxis: []
            };
            return db(this.chart.axes, function(c) {
                b[c.isXAxis ? "xAxis" : "yAxis"].push({
                    axis: c,
                    value: c.toValue(a[c.horiz ? "chartX" : "chartY"])
                });
            }), b;
        },
        getIndex: function(a) {
            var b = this.chart;
            return b.inverted ? b.plotHeight + b.plotTop - a.chartY : a.chartX - b.plotLeft;
        },
        runPointActions: function(a) {
            var b, c, d, e = this.chart, f = e.series, g = e.tooltip, h = e.hoverPoint, i = e.hoverSeries, j = e.chartWidth, k = this.getIndex(a);
            if (g && this.options.tooltip.shared && (!i || !i.noSharedTooltip)) {
                for (b = [], c = f.length, d = 0; d < c; d++) f[d].visible && f[d].options.enableMouseTracking !== !1 && !f[d].noSharedTooltip && f[d].tooltipPoints.length && (e = f[d].tooltipPoints[k]) && e.series && (e._dist = sa(k - e.clientX), 
                j = ra(j, e._dist), b.push(e));
                for (c = b.length; c--; ) b[c]._dist > j && b.splice(c, 1);
                b.length && b[0].clientX !== this.hoverX && (g.refresh(b, a), this.hoverX = b[0].clientX);
            }
            i && i.tracker ? (e = i.tooltipPoints[k]) && e !== h && e.onMouseOver(a) : g && g.followPointer && !g.isHidden && (a = g.getAnchor([ {} ], a), 
            g.updatePosition({
                plotX: a[0],
                plotY: a[1]
            }));
        },
        reset: function(a) {
            var b = this.chart, c = b.hoverSeries, d = b.hoverPoint, e = b.tooltip, b = e && e.shared ? b.hoverPoints : d;
            (a = a && e && b) && m(b)[0].plotX === S && (a = !1), a ? e.refresh(b) : (d && d.onMouseOut(), 
            c && c.onMouseOut(), e && (e.hide(), e.hideCrosshairs()), this.hoverX = null);
        },
        scaleGroups: function(a, b) {
            var c, d = this.chart;
            db(d.series, function(e) {
                c = a || e.getPlotBox(), e.xAxis && e.xAxis.zoomEnabled && (e.group.attr(c), e.markerGroup && (e.markerGroup.attr(c), 
                e.markerGroup.clip(b ? d.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(c));
            }), d.clipRect.attr(b || d.clipBox);
        },
        pinchTranslateDirection: function(a, b, c, d, e, f, g) {
            var h, i, j, k = this.chart, l = a ? "x" : "y", m = a ? "X" : "Y", n = "chart" + m, o = a ? "width" : "height", p = k["plot" + (a ? "Left" : "Top")], q = 1, r = k.inverted, s = k.bounds[a ? "h" : "v"], t = 1 === b.length, u = b[0][n], v = c[0][n], w = !t && b[1][n], x = !t && c[1][n], c = function() {
                !t && sa(u - w) > 20 && (q = sa(v - x) / sa(u - w)), i = (p - v) / q + u, h = k["plot" + (a ? "Width" : "Height")] / q;
            };
            c(), b = i, b < s.min ? (b = s.min, j = !0) : b + h > s.max && (b = s.max - h, j = !0), 
            j ? (v -= .8 * (v - g[l][0]), t || (x -= .8 * (x - g[l][1])), c()) : g[l] = [ v, x ], 
            r || (f[l] = i - p, f[o] = h), f = r ? 1 / q : q, e[o] = h, e[l] = b, d[r ? a ? "scaleY" : "scaleX" : "scale" + m] = q, 
            d["translate" + m] = f * p + (v - f * u);
        },
        pinch: function(b) {
            var c = this, d = c.chart, e = c.pinchDown, f = d.tooltip && d.tooltip.options.followTouchMove, g = b.touches, h = g.length, i = c.lastValidTouch, j = c.zoomHor || c.pinchHor, k = c.zoomVert || c.pinchVert, l = j || k, m = c.selectionMarker, n = {}, o = 1 === h && (c.inClass(b.target, "highcharts-tracker") && d.runTrackerClick || d.runChartClick), p = {};
            (l || f) && !o && b.preventDefault(), gb(g, function(a) {
                return c.normalize(a);
            }), "touchstart" === b.type ? (db(g, function(a, b) {
                e[b] = {
                    chartX: a.chartX,
                    chartY: a.chartY
                };
            }), i.x = [ e[0].chartX, e[1] && e[1].chartX ], i.y = [ e[0].chartY, e[1] && e[1].chartY ], 
            db(d.axes, function(a) {
                if (a.zoomEnabled) {
                    var b = d.bounds[a.horiz ? "h" : "v"], c = a.minPixelPadding, e = a.toPixels(a.dataMin), f = a.toPixels(a.dataMax), g = ra(e, f), e = qa(e, f);
                    b.min = ra(a.pos, g - c), b.max = qa(a.pos + a.len, e + c);
                }
            })) : e.length && (m || (c.selectionMarker = m = a({
                destroy: La
            }, d.plotBox)), j && c.pinchTranslateDirection(!0, e, g, n, m, p, i), k && c.pinchTranslateDirection(!1, e, g, n, m, p, i), 
            c.hasPinched = l, c.scaleGroups(n, p), !l && f && 1 === h && this.runPointActions(c.normalize(b)));
        },
        dragStart: function(a) {
            var b = this.chart;
            b.mouseIsDown = a.type, b.cancelClick = !1, b.mouseDownX = this.mouseDownX = a.chartX, 
            b.mouseDownY = this.mouseDownY = a.chartY;
        },
        drag: function(a) {
            var b, c = this.chart, d = c.options.chart, e = a.chartX, f = a.chartY, g = this.zoomHor, h = this.zoomVert, i = c.plotLeft, j = c.plotTop, k = c.plotWidth, l = c.plotHeight, m = this.mouseDownX, n = this.mouseDownY;
            e < i ? e = i : e > i + k && (e = i + k), f < j ? f = j : f > j + l && (f = j + l), 
            this.hasDragged = Math.sqrt(Math.pow(m - e, 2) + Math.pow(n - f, 2)), this.hasDragged > 10 && (b = c.isInsidePlot(m - i, n - j), 
            c.hasCartesianSeries && (this.zoomX || this.zoomY) && b && !this.selectionMarker && (this.selectionMarker = c.renderer.rect(i, j, g ? 1 : k, h ? 1 : l, 0).attr({
                fill: d.selectionMarkerFill || "rgba(69,114,167,0.25)",
                zIndex: 7
            }).add()), this.selectionMarker && g && (e -= m, this.selectionMarker.attr({
                width: sa(e),
                x: (e > 0 ? 0 : e) + m
            })), this.selectionMarker && h && (e = f - n, this.selectionMarker.attr({
                height: sa(e),
                y: (e > 0 ? 0 : e) + n
            })), b && !this.selectionMarker && d.panning && c.pan(a, d.panning));
        },
        drop: function(b) {
            var c = this.chart, d = this.hasPinched;
            if (this.selectionMarker) {
                var e, f = {
                    xAxis: [],
                    yAxis: [],
                    originalEvent: b.originalEvent || b
                }, g = this.selectionMarker, h = g.x, i = g.y;
                (this.hasDragged || d) && (db(c.axes, function(a) {
                    if (a.zoomEnabled) {
                        var b = a.horiz, c = a.toValue(b ? h : i), b = a.toValue(b ? h + g.width : i + g.height);
                        !isNaN(c) && !isNaN(b) && (f[a.xOrY + "Axis"].push({
                            axis: a,
                            min: ra(c, b),
                            max: qa(c, b)
                        }), e = !0);
                    }
                }), e && jb(c, "selection", f, function(b) {
                    c.zoom(a(b, d ? {
                        animation: !1
                    } : null));
                })), this.selectionMarker = this.selectionMarker.destroy(), d && this.scaleGroups();
            }
            c && (o(c.container, {
                cursor: c._cursor
            }), c.cancelClick = this.hasDragged > 10, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, 
            this.pinchDown = []);
        },
        onContainerMouseDown: function(a) {
            a = this.normalize(a), a.preventDefault && a.preventDefault(), this.dragStart(a);
        },
        onDocumentMouseUp: function(a) {
            this.drop(a);
        },
        onDocumentMouseMove: function(a) {
            var b = this.chart, c = this.chartPosition, d = b.hoverSeries, a = this.normalize(a, c);
            c && d && !this.inClass(a.target, "highcharts-tracker") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) && this.reset();
        },
        onContainerMouseLeave: function() {
            this.reset(), this.chartPosition = null;
        },
        onContainerMouseMove: function(a) {
            var b = this.chart, a = this.normalize(a);
            a.returnValue = !1, "mousedown" === b.mouseIsDown && this.drag(a), (this.inClass(a.target, "highcharts-tracker") || b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop)) && !b.openMenu && this.runPointActions(a);
        },
        inClass: function(a, b) {
            for (var c; a; ) {
                if (c = l(a, "class")) {
                    if (c.indexOf(b) !== -1) return !0;
                    if (c.indexOf("highcharts-container") !== -1) return !1;
                }
                a = a.parentNode;
            }
        },
        onTrackerMouseOut: function(a) {
            var b = this.chart.hoverSeries;
            !b || b.options.stickyTracking || this.inClass(a.toElement || a.relatedTarget, "highcharts-tooltip") || b.onMouseOut();
        },
        onContainerClick: function(b) {
            var c, d, e, f = this.chart, g = f.hoverPoint, h = f.plotLeft, i = f.plotTop, j = f.inverted, b = this.normalize(b);
            b.cancelBubble = !0, f.cancelClick || (g && this.inClass(b.target, "highcharts-tracker") ? (c = this.chartPosition, 
            d = g.plotX, e = g.plotY, a(g, {
                pageX: c.left + h + (j ? f.plotWidth - e : d),
                pageY: c.top + i + (j ? f.plotHeight - d : e)
            }), jb(g.series, "click", a(b, {
                point: g
            })), f.hoverPoint && g.firePointEvent("click", b)) : (a(b, this.getCoordinates(b)), 
            f.isInsidePlot(b.chartX - h, b.chartY - i) && jb(f, "click", b)));
        },
        onContainerTouchStart: function(a) {
            var b = this.chart;
            1 === a.touches.length ? (a = this.normalize(a), b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) ? (this.runPointActions(a), 
            this.pinch(a)) : this.reset()) : 2 === a.touches.length && this.pinch(a);
        },
        onContainerTouchMove: function(a) {
            (1 === a.touches.length || 2 === a.touches.length) && this.pinch(a);
        },
        onDocumentTouchEnd: function(a) {
            this.drop(a);
        },
        setDOMEvents: function() {
            var a, b = this, c = b.chart.container;
            this._events = a = [ [ c, "onmousedown", "onContainerMouseDown" ], [ c, "onmousemove", "onContainerMouseMove" ], [ c, "onclick", "onContainerClick" ], [ c, "mouseleave", "onContainerMouseLeave" ], [ ka, "mousemove", "onDocumentMouseMove" ], [ ka, "mouseup", "onDocumentMouseUp" ] ], 
            Ia && a.push([ c, "ontouchstart", "onContainerTouchStart" ], [ c, "ontouchmove", "onContainerTouchMove" ], [ ka, "touchend", "onDocumentTouchEnd" ]), 
            db(a, function(a) {
                b["_" + a[2]] = function(c) {
                    b[a[2]](c);
                }, 0 === a[1].indexOf("on") ? a[0][a[1]] = b["_" + a[2]] : hb(a[0], a[1], b["_" + a[2]]);
            });
        },
        destroy: function() {
            var a = this;
            db(a._events, function(b) {
                0 === b[1].indexOf("on") ? b[0][b[1]] = null : ib(b[0], b[1], a["_" + b[2]]);
            }), delete a._events, clearInterval(a.tooltipTimeout);
        }
    }, Q.prototype = {
        init: function(a, d) {
            var e = this, f = d.itemStyle, g = n(d.padding, 8), h = d.itemMarginTop || 0;
            this.options = d, d.enabled && (e.baseline = c(f.fontSize) + 3 + h, e.itemStyle = f, 
            e.itemHiddenStyle = b(f, d.itemHiddenStyle), e.itemMarginTop = h, e.padding = g, 
            e.initialItemX = g, e.initialItemY = g - 5, e.maxItemWidth = 0, e.chart = a, e.itemHeight = 0, 
            e.lastLineHeight = 0, e.render(), hb(e.chart, "endResize", function() {
                e.positionCheckboxes();
            }));
        },
        colorizeItem: function(a, b) {
            var c, d = this.options, e = a.legendItem, f = a.legendLine, g = a.legendSymbol, h = this.itemHiddenStyle.color, d = b ? d.itemStyle.color : h, i = b ? a.color : h, h = a.options && a.options.marker, j = {
                stroke: i,
                fill: i
            };
            if (e && e.css({
                fill: d,
                color: d
            }), f && f.attr({
                stroke: i
            }), g) {
                if (h && g.isMarker) for (c in h = a.convertAttribs(h)) e = h[c], e !== S && (j[c] = e);
                g.attr(j);
            }
        },
        positionItem: function(a) {
            var b = this.options, c = b.symbolPadding, b = !b.rtl, d = a._legendItemPos, e = d[0], d = d[1], f = a.checkbox;
            a.legendGroup && a.legendGroup.translate(b ? e : this.legendWidth - e - 2 * c - 4, d), 
            f && (f.x = e, f.y = d);
        },
        destroyItem: function(a) {
            var b = a.checkbox;
            db([ "legendItem", "legendLine", "legendSymbol", "legendGroup" ], function(b) {
                a[b] && (a[b] = a[b].destroy());
            }), b && E(a.checkbox);
        },
        destroy: function() {
            var a = this.group, b = this.box;
            b && (this.box = b.destroy()), a && (this.group = a.destroy());
        },
        positionCheckboxes: function(a) {
            var b, c = this.group.alignAttr, d = this.clipHeight || this.legendHeight;
            c && (b = c.translateY, db(this.allItems, function(e) {
                var f, g = e.checkbox;
                g && (f = b + g.y + (a || 0) + 3, o(g, {
                    left: c.translateX + e.legendItemWidth + g.x - 20 + "px",
                    top: f + "px",
                    display: f > b - 6 && f < b + d - 6 ? "" : Oa
                }));
            }));
        },
        renderTitle: function() {
            var a = this.padding, b = this.options.title, c = 0;
            b.text && (this.title || (this.title = this.chart.renderer.label(b.text, a - 3, a - 4, null, null, null, null, null, "legend-title").attr({
                zIndex: 1
            }).css(b.style).add(this.group)), a = this.title.getBBox(), c = a.height, this.offsetWidth = a.width, 
            this.contentGroup.attr({
                translateY: c
            })), this.titleHeight = c;
        },
        renderItem: function(a) {
            var c, d = this, e = d.chart, f = e.renderer, g = d.options, h = "horizontal" === g.layout, i = g.symbolWidth, j = g.symbolPadding, k = d.itemStyle, l = d.itemHiddenStyle, m = d.padding, o = h ? n(g.itemDistance, 8) : 0, q = !g.rtl, r = g.width, s = g.itemMarginBottom || 0, t = d.itemMarginTop, v = d.initialItemX, w = a.legendItem, x = a.series || a, y = x.options, z = y.showCheckbox, A = g.useHTML;
            !w && (a.legendGroup = f.g("legend-item").attr({
                zIndex: 1
            }).add(d.scrollGroup), x.drawLegendSymbol(d, a), a.legendItem = w = f.text(g.labelFormat ? u(g.labelFormat, a) : g.labelFormatter.call(a), q ? i + j : -j, d.baseline, A).css(b(a.visible ? k : l)).attr({
                align: q ? "left" : "right",
                zIndex: 2
            }).add(a.legendGroup), (A ? w : a.legendGroup).on("mouseover", function() {
                a.setState("hover"), w.css(d.options.itemHoverStyle);
            }).on("mouseout", function() {
                w.css(a.visible ? k : l), a.setState();
            }).on("click", function(b) {
                var c = function() {
                    a.setVisible();
                }, b = {
                    browserEvent: b
                };
                a.firePointEvent ? a.firePointEvent("legendItemClick", b, c) : jb(a, "legendItemClick", b, c);
            }), d.colorizeItem(a, a.visible), y && z) && (a.checkbox = p("input", {
                type: "checkbox",
                checked: a.selected,
                defaultChecked: a.selected
            }, g.itemCheckboxStyle, e.container), hb(a.checkbox, "click", function(b) {
                jb(a, "checkboxClick", {
                    checked: b.target.checked
                }, function() {
                    a.select();
                });
            })), f = w.getBBox(), c = a.legendItemWidth = g.itemWidth || i + j + f.width + o + (z ? 20 : 0), 
            g = c, d.itemHeight = i = f.height, h && d.itemX - v + g > (r || e.chartWidth - 2 * m - v) && (d.itemX = v, 
            d.itemY += t + d.lastLineHeight + s, d.lastLineHeight = 0), d.maxItemWidth = qa(d.maxItemWidth, g), 
            d.lastItemY = t + d.itemY + s, d.lastLineHeight = qa(i, d.lastLineHeight), a._legendItemPos = [ d.itemX, d.itemY ], 
            h ? d.itemX += g : (d.itemY += t + i + s, d.lastLineHeight = i), d.offsetWidth = r || qa((h ? d.itemX - v - o : g) + m, d.offsetWidth);
        },
        render: function() {
            var b, c, d, e, f = this, g = f.chart, h = g.renderer, i = f.group, j = f.box, l = f.options, m = f.padding, n = l.borderWidth, o = l.backgroundColor;
            f.itemX = f.initialItemX, f.itemY = f.initialItemY, f.offsetWidth = 0, f.lastItemY = 0, 
            i || (f.group = i = h.g("legend").attr({
                zIndex: 7
            }).add(), f.contentGroup = h.g().attr({
                zIndex: 1
            }).add(i), f.scrollGroup = h.g().add(f.contentGroup)), f.renderTitle(), b = [], 
            db(g.series, function(a) {
                var c = a.options;
                c.showInLegend && !k(c.linkedTo) && (b = b.concat(a.legendItems || ("point" === c.legendType ? a.data : a)));
            }), A(b, function(a, b) {
                return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
            }), l.reversed && b.reverse(), f.allItems = b, f.display = c = !!b.length, db(b, function(a) {
                f.renderItem(a);
            }), d = l.width || f.offsetWidth, e = f.lastItemY + f.lastLineHeight + f.titleHeight, 
            e = f.handleOverflow(e), (n || o) && (d += m, e += m, j ? d > 0 && e > 0 && (j[j.isNew ? "attr" : "animate"](j.crisp(null, null, null, d, e)), 
            j.isNew = !1) : (f.box = j = h.rect(0, 0, d, e, l.borderRadius, n || 0).attr({
                stroke: l.borderColor,
                "stroke-width": n || 0,
                fill: o || Oa
            }).add(i).shadow(l.shadow), j.isNew = !0), j[c ? "show" : "hide"]()), f.legendWidth = d, 
            f.legendHeight = e, db(b, function(a) {
                f.positionItem(a);
            }), c && i.align(a({
                width: d,
                height: e
            }, l), !0, "spacingBox"), g.isResizing || this.positionCheckboxes();
        },
        handleOverflow: function(a) {
            var b = this, c = this.chart, d = c.renderer, e = this.options, f = e.y, f = c.spacingBox.height + ("top" === e.verticalAlign ? -f : f) - this.padding, g = e.maxHeight, h = this.clipRect, i = e.navigation, j = n(i.animation, !0), k = i.arrowSize || 12, l = this.nav;
            return "horizontal" === e.layout && (f /= 2), g && (f = ra(f, g)), a > f && !e.useHTML ? (this.clipHeight = c = f - 20 - this.titleHeight, 
            this.pageCount = pa(a / c), this.currentPage = n(this.currentPage, 1), this.fullHeight = a, 
            h || (h = b.clipRect = d.clipRect(0, 0, 9999, 0), b.contentGroup.clip(h)), h.attr({
                height: c
            }), l || (this.nav = l = d.g().attr({
                zIndex: 1
            }).add(this.group), this.up = d.symbol("triangle", 0, 0, k, k).on("click", function() {
                b.scroll(-1, j);
            }).add(l), this.pager = d.text("", 15, 10).css(i.style).add(l), this.down = d.symbol("triangle-down", 0, 0, k, k).on("click", function() {
                b.scroll(1, j);
            }).add(l)), b.scroll(0), a = f) : l && (h.attr({
                height: c.chartHeight
            }), l.hide(), this.scrollGroup.attr({
                translateY: 1
            }), this.clipHeight = 0), a;
        },
        scroll: function(a, b) {
            var c = this.pageCount, d = this.currentPage + a, e = this.clipHeight, f = this.options.navigation, g = f.activeColor, h = f.inactiveColor, f = this.pager, i = this.padding;
            d > c && (d = c), d > 0 && (b !== S && H(b, this.chart), this.nav.attr({
                translateX: i,
                translateY: e + 7 + this.titleHeight,
                visibility: "visible"
            }), this.up.attr({
                fill: 1 === d ? h : g
            }).css({
                cursor: 1 === d ? "default" : "pointer"
            }), f.attr({
                text: d + "/" + this.pageCount
            }), this.down.attr({
                x: 18 + this.pager.getBBox().width,
                fill: d === c ? h : g
            }).css({
                cursor: d === c ? "default" : "pointer"
            }), e = -ra(e * (d - 1), this.fullHeight - e + i) + 1, this.scrollGroup.animate({
                translateY: e
            }), f.attr({
                text: d + "/" + c
            }), this.currentPage = d, this.positionCheckboxes(e));
        }
    }, /Trident.*?11\.0/.test(xa) && t(Q.prototype, "positionItem", function(a, b) {
        var c = this;
        setTimeout(function() {
            a.call(c, b);
        });
    }), R.prototype = {
        init: function(a, c) {
            var d, e = a.series;
            a.series = null, d = b(V, a), d.series = a.series = e, e = d.chart, this.margin = this.splashArray("margin", e), 
            this.spacing = this.splashArray("spacing", e);
            var f = e.events;
            this.bounds = {
                h: {},
                v: {}
            }, this.callback = c, this.isResizing = 0, this.options = d, this.axes = [], this.series = [], 
            this.hasCartesianSeries = e.showAxes;
            var g, h = this;
            if (h.index = Ma.length, Ma.push(h), e.reflow !== !1 && hb(h, "load", function() {
                h.initReflow();
            }), f) for (g in f) hb(h, g, f[g]);
            h.xAxis = [], h.yAxis = [], h.animation = !Ha && n(e.animation, !0), h.pointCount = 0, 
            h.counters = new z(), h.firstRender();
        },
        initSeries: function(a) {
            var b = this.options.chart;
            return (b = Za[a.type || b.type || b.defaultSeriesType]) || F(17, !0), b = new b(), 
            b.init(this, a), b;
        },
        addSeries: function(a, b, c) {
            var d, e = this;
            return a && (b = n(b, !0), jb(e, "addSeries", {
                options: a
            }, function() {
                d = e.initSeries(a), e.isDirtyLegend = !0, e.linkSeries(), b && e.redraw(c);
            })), d;
        },
        addAxis: function(a, c, d, e) {
            var f = c ? "xAxis" : "yAxis", g = this.options;
            new N(this, b(a, {
                index: this[f].length,
                isX: c
            })), g[f] = m(g[f] || {}), g[f].push(a), n(d, !0) && this.redraw(e);
        },
        isInsidePlot: function(a, b, c) {
            var d = c ? b : a, a = c ? a : b;
            return d >= 0 && d <= this.plotWidth && a >= 0 && a <= this.plotHeight;
        },
        adjustTickAmounts: function() {
            this.options.chart.alignTicks !== !1 && db(this.axes, function(a) {
                a.adjustTickAmount();
            }), this.maxTicks = null;
        },
        redraw: function(b) {
            var c, d, e = this.axes, f = this.series, g = this.pointer, h = this.legend, i = this.isDirtyLegend, j = this.isDirtyBox, k = f.length, l = k, m = this.renderer, n = m.isHidden(), o = [];
            for (H(b, this), n && this.cloneRenderTo(), this.layOutTitles(); l--; ) if (b = f[l], 
            b.options.stacking && (c = !0, b.isDirty)) {
                d = !0;
                break;
            }
            if (d) for (l = k; l--; ) b = f[l], b.options.stacking && (b.isDirty = !0);
            db(f, function(a) {
                a.isDirty && "point" === a.options.legendType && (i = !0);
            }), i && h.options.enabled && (h.render(), this.isDirtyLegend = !1), c && this.getStacks(), 
            this.hasCartesianSeries && (this.isResizing || (this.maxTicks = null, db(e, function(a) {
                a.setScale();
            })), this.adjustTickAmounts(), this.getMargins(), db(e, function(a) {
                a.isDirty && (j = !0);
            }), db(e, function(b) {
                b.isDirtyExtremes && (b.isDirtyExtremes = !1, o.push(function() {
                    jb(b, "afterSetExtremes", a(b.eventArgs, b.getExtremes())), delete b.eventArgs;
                })), (j || c) && b.redraw();
            })), j && this.drawChartBox(), db(f, function(a) {
                a.isDirty && a.visible && (!a.isCartesian || a.xAxis) && a.redraw();
            }), g && g.reset && g.reset(!0), m.draw(), jb(this, "redraw"), n && this.cloneRenderTo(!0), 
            db(o, function(a) {
                a.call();
            });
        },
        showLoading: function(b) {
            var c = this.options, d = this.loadingDiv, e = c.loading;
            d || (this.loadingDiv = d = p(Na, {
                className: "highcharts-loading"
            }, a(e.style, {
                zIndex: 10,
                display: Oa
            }), this.container), this.loadingSpan = p("span", null, e.labelStyle, d)), this.loadingSpan.innerHTML = b || c.lang.loading, 
            this.loadingShown || (o(d, {
                opacity: 0,
                display: "",
                left: this.plotLeft + "px",
                top: this.plotTop + "px",
                width: this.plotWidth + "px",
                height: this.plotHeight + "px"
            }), lb(d, {
                opacity: e.style.opacity
            }, {
                duration: e.showDuration || 0
            }), this.loadingShown = !0);
        },
        hideLoading: function() {
            var a = this.options, b = this.loadingDiv;
            b && lb(b, {
                opacity: 0
            }, {
                duration: a.loading.hideDuration || 100,
                complete: function() {
                    o(b, {
                        display: Oa
                    });
                }
            }), this.loadingShown = !1;
        },
        get: function(a) {
            var b, c, d = this.axes, e = this.series;
            for (b = 0; b < d.length; b++) if (d[b].options.id === a) return d[b];
            for (b = 0; b < e.length; b++) if (e[b].options.id === a) return e[b];
            for (b = 0; b < e.length; b++) for (c = e[b].points || [], d = 0; d < c.length; d++) if (c[d].id === a) return c[d];
            return null;
        },
        getAxes: function() {
            var a = this, b = this.options, c = b.xAxis = m(b.xAxis || {}), b = b.yAxis = m(b.yAxis || {});
            db(c, function(a, b) {
                a.index = b, a.isX = !0;
            }), db(b, function(a, b) {
                a.index = b;
            }), c = c.concat(b), db(c, function(b) {
                new N(a, b);
            }), a.adjustTickAmounts();
        },
        getSelectedPoints: function() {
            var a = [];
            return db(this.series, function(b) {
                a = a.concat(eb(b.points || [], function(a) {
                    return a.selected;
                }));
            }), a;
        },
        getSelectedSeries: function() {
            return eb(this.series, function(a) {
                return a.selected;
            });
        },
        getStacks: function() {
            var a = this;
            db(a.yAxis, function(a) {
                a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks);
            }), db(a.series, function(b) {
                !b.options.stacking || b.visible !== !0 && a.options.chart.ignoreHiddenSeries !== !1 || (b.stackKey = b.type + n(b.options.stack, ""));
            });
        },
        showResetZoom: function() {
            var a = this, b = V.lang, c = a.options.chart.resetZoomButton, d = c.theme, e = d.states, f = "chart" === c.relativeTo ? null : "plotBox";
            this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function() {
                a.zoomOut();
            }, d, e && e.hover).attr({
                align: c.position.align,
                title: b.resetZoomTitle
            }).add().align(c.position, !1, f);
        },
        zoomOut: function() {
            var a = this;
            jb(a, "selection", {
                resetSelection: !0
            }, function() {
                a.zoom();
            });
        },
        zoom: function(a) {
            var b, c, d = this.pointer, f = !1;
            !a || a.resetSelection ? db(this.axes, function(a) {
                b = a.zoom();
            }) : db(a.xAxis.concat(a.yAxis), function(a) {
                var c = a.axis, e = c.isXAxis;
                (d[e ? "zoomX" : "zoomY"] || d[e ? "pinchX" : "pinchY"]) && (b = c.zoom(a.min, a.max), 
                c.displayBtn && (f = !0));
            }), c = this.resetZoomButton, f && !c ? this.showResetZoom() : !f && e(c) && (this.resetZoomButton = c.destroy()), 
            b && this.redraw(n(this.options.chart.animation, a && a.animation, this.pointCount < 100));
        },
        pan: function(a, b) {
            var c, d = this, e = d.hoverPoints;
            e && db(e, function(a) {
                a.setState();
            }), db("xy" === b ? [ 1, 0 ] : [ 1 ], function(b) {
                var e = a[b ? "chartX" : "chartY"], f = d[b ? "xAxis" : "yAxis"][0], g = d[b ? "mouseDownX" : "mouseDownY"], h = (f.pointRange || 0) / 2, i = f.getExtremes(), j = f.toValue(g - e, !0) + h, g = f.toValue(g + d[b ? "plotWidth" : "plotHeight"] - e, !0) - h;
                f.series.length && j > ra(i.dataMin, i.min) && g < qa(i.dataMax, i.max) && (f.setExtremes(j, g, !1, !1, {
                    trigger: "pan"
                }), c = !0), d[b ? "mouseDownX" : "mouseDownY"] = e;
            }), c && d.redraw(!1), o(d.container, {
                cursor: "move"
            });
        },
        setTitle: function(a, c) {
            var d, e, f = this, g = f.options;
            e = g.title = b(g.title, a), d = g.subtitle = b(g.subtitle, c), g = d, db([ [ "title", a, e ], [ "subtitle", c, g ] ], function(a) {
                var b = a[0], c = f[b], d = a[1], a = a[2];
                c && d && (f[b] = c = c.destroy()), a && a.text && !c && (f[b] = f.renderer.text(a.text, 0, 0, a.useHTML).attr({
                    align: a.align,
                    class: "highcharts-" + b,
                    zIndex: a.zIndex || 4
                }).css(a.style).add());
            }), f.layOutTitles();
        },
        layOutTitles: function() {
            var b = 0, c = this.title, d = this.subtitle, e = this.options, f = e.title, e = e.subtitle, g = this.spacingBox.width - 44;
            !c || (c.css({
                width: (f.width || g) + "px"
            }).align(a({
                y: 15
            }, f), !1, "spacingBox"), f.floating || f.verticalAlign) || (b = c.getBBox().height, 
            b >= 18 && b <= 25 && (b = 15)), d && (d.css({
                width: (e.width || g) + "px"
            }).align(a({
                y: b + f.margin
            }, e), !1, "spacingBox"), !e.floating && !e.verticalAlign && (b = pa(b + d.getBBox().height))), 
            this.titleOffset = b;
        },
        getChartSize: function() {
            var a = this.options.chart, b = this.renderToClone || this.renderTo;
            this.containerWidth = ab(b, "width"), this.containerHeight = ab(b, "height"), this.chartWidth = qa(0, a.width || this.containerWidth || 600), 
            this.chartHeight = qa(0, n(a.height, this.containerHeight > 19 ? this.containerHeight : 400));
        },
        cloneRenderTo: function(a) {
            var b = this.renderToClone, c = this.container;
            a ? b && (this.renderTo.appendChild(c), E(b), delete this.renderToClone) : (c && c.parentNode === this.renderTo && this.renderTo.removeChild(c), 
            this.renderToClone = b = this.renderTo.cloneNode(0), o(b, {
                position: "absolute",
                top: "-9999px",
                display: "block"
            }), ka.body.appendChild(b), c && b.appendChild(c));
        },
        getContainer: function() {
            var b, e, f, g, h = this.options.chart;
            this.renderTo = b = h.renderTo, g = "highcharts-" + Ka++, d(b) && (this.renderTo = b = ka.getElementById(b)), 
            b || F(13, !0), e = c(l(b, "data-highcharts-chart")), !isNaN(e) && Ma[e] && Ma[e].destroy(), 
            l(b, "data-highcharts-chart", this.index), b.innerHTML = "", b.offsetWidth || this.cloneRenderTo(), 
            this.getChartSize(), e = this.chartWidth, f = this.chartHeight, this.container = b = p(Na, {
                className: "highcharts-container" + (h.className ? " " + h.className : ""),
                id: g
            }, a({
                position: "relative",
                overflow: "hidden",
                width: e + "px",
                height: f + "px",
                textAlign: "left",
                lineHeight: "normal",
                zIndex: 0,
                "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
            }, h.style), this.renderToClone || b), this._cursor = b.style.cursor, this.renderer = h.forExport ? new pb(b, e, f, (!0)) : new T(b, e, f), 
            Ha && this.renderer.create(this, b, e, f);
        },
        getMargins: function() {
            var a, b = this.spacing, c = this.legend, d = this.margin, e = this.options.legend, f = n(e.margin, 10), g = e.x, h = e.y, i = e.align, j = e.verticalAlign, l = this.titleOffset;
            this.resetMargins(), a = this.axisOffset, l && !k(d[0]) && (this.plotTop = qa(this.plotTop, l + this.options.title.margin + b[0])), 
            c.display && !e.floating && ("right" === i ? k(d[1]) || (this.marginRight = qa(this.marginRight, c.legendWidth - g + f + b[1])) : "left" === i ? k(d[3]) || (this.plotLeft = qa(this.plotLeft, c.legendWidth + g + f + b[3])) : "top" === j ? k(d[0]) || (this.plotTop = qa(this.plotTop, c.legendHeight + h + f + b[0])) : "bottom" !== j || k(d[2]) || (this.marginBottom = qa(this.marginBottom, c.legendHeight - h + f + b[2]))), 
            this.extraBottomMargin && (this.marginBottom += this.extraBottomMargin), this.extraTopMargin && (this.plotTop += this.extraTopMargin), 
            this.hasCartesianSeries && db(this.axes, function(a) {
                a.getOffset();
            }), k(d[3]) || (this.plotLeft += a[3]), k(d[0]) || (this.plotTop += a[0]), k(d[2]) || (this.marginBottom += a[2]), 
            k(d[1]) || (this.marginRight += a[1]), this.setChartSize();
        },
        initReflow: function() {
            function a(a) {
                var f = d.width || ab(e, "width"), g = d.height || ab(e, "height"), a = a ? a.target : la;
                c.hasUserSize || !f || !g || a !== la && a !== ka || (f === c.containerWidth && g === c.containerHeight || (clearTimeout(b), 
                c.reflowTimeout = b = setTimeout(function() {
                    c.container && (c.setSize(f, g, !1), c.hasUserSize = null);
                }, 100)), c.containerWidth = f, c.containerHeight = g);
            }
            var b, c = this, d = c.options.chart, e = c.renderTo;
            c.reflow = a, hb(la, "resize", a), hb(c, "destroy", function() {
                ib(la, "resize", a);
            });
        },
        setSize: function(a, b, c) {
            var d, e, f, g = this;
            g.isResizing += 1, f = function() {
                g && jb(g, "endResize", null, function() {
                    g.isResizing -= 1;
                });
            }, H(c, g), g.oldChartHeight = g.chartHeight, g.oldChartWidth = g.chartWidth, k(a) && (g.chartWidth = d = qa(0, na(a)), 
            g.hasUserSize = !!d), k(b) && (g.chartHeight = e = qa(0, na(b))), o(g.container, {
                width: d + "px",
                height: e + "px"
            }), g.setChartSize(!0), g.renderer.setSize(d, e, c), g.maxTicks = null, db(g.axes, function(a) {
                a.isDirty = !0, a.setScale();
            }), db(g.series, function(a) {
                a.isDirty = !0;
            }), g.isDirtyLegend = !0, g.isDirtyBox = !0, g.getMargins(), g.redraw(c), g.oldChartHeight = null, 
            jb(g, "resize"), X === !1 ? f() : setTimeout(f, X && X.duration || 500);
        },
        setChartSize: function(a) {
            var b, c, d, e, f = this.inverted, g = this.renderer, h = this.chartWidth, i = this.chartHeight, j = this.options.chart, k = this.spacing, l = this.clipOffset;
            this.plotLeft = b = na(this.plotLeft), this.plotTop = c = na(this.plotTop), this.plotWidth = d = qa(0, na(h - b - this.marginRight)), 
            this.plotHeight = e = qa(0, na(i - c - this.marginBottom)), this.plotSizeX = f ? e : d, 
            this.plotSizeY = f ? d : e, this.plotBorderWidth = j.plotBorderWidth || 0, this.spacingBox = g.spacingBox = {
                x: k[3],
                y: k[0],
                width: h - k[3] - k[1],
                height: i - k[0] - k[2]
            }, this.plotBox = g.plotBox = {
                x: b,
                y: c,
                width: d,
                height: e
            }, h = 2 * oa(this.plotBorderWidth / 2), f = pa(qa(h, l[3]) / 2), g = pa(qa(h, l[0]) / 2), 
            this.clipBox = {
                x: f,
                y: g,
                width: oa(this.plotSizeX - qa(h, l[1]) / 2 - f),
                height: oa(this.plotSizeY - qa(h, l[2]) / 2 - g)
            }, a || db(this.axes, function(a) {
                a.setAxisSize(), a.setAxisTranslation();
            });
        },
        resetMargins: function() {
            var a = this.spacing, b = this.margin;
            this.plotTop = n(b[0], a[0]), this.marginRight = n(b[1], a[1]), this.marginBottom = n(b[2], a[2]), 
            this.plotLeft = n(b[3], a[3]), this.axisOffset = [ 0, 0, 0, 0 ], this.clipOffset = [ 0, 0, 0, 0 ];
        },
        drawChartBox: function() {
            var a, b = this.options.chart, c = this.renderer, d = this.chartWidth, e = this.chartHeight, f = this.chartBackground, g = this.plotBackground, h = this.plotBorder, i = this.plotBGImage, j = b.borderWidth || 0, k = b.backgroundColor, l = b.plotBackgroundColor, m = b.plotBackgroundImage, n = b.plotBorderWidth || 0, o = this.plotLeft, p = this.plotTop, q = this.plotWidth, r = this.plotHeight, s = this.plotBox, t = this.clipRect, u = this.clipBox;
            a = j + (b.shadow ? 8 : 0), (j || k) && (f ? f.animate(f.crisp(null, null, null, d - a, e - a)) : (f = {
                fill: k || Oa
            }, j && (f.stroke = b.borderColor, f["stroke-width"] = j), this.chartBackground = c.rect(a / 2, a / 2, d - a, e - a, b.borderRadius, j).attr(f).add().shadow(b.shadow))), 
            l && (g ? g.animate(s) : this.plotBackground = c.rect(o, p, q, r, 0).attr({
                fill: l
            }).add().shadow(b.plotShadow)), m && (i ? i.animate(s) : this.plotBGImage = c.image(m, o, p, q, r).add()), 
            t ? t.animate({
                width: u.width,
                height: u.height
            }) : this.clipRect = c.clipRect(u), n && (h ? h.animate(h.crisp(null, o, p, q, r)) : this.plotBorder = c.rect(o, p, q, r, 0, -n).attr({
                stroke: b.plotBorderColor,
                "stroke-width": n,
                zIndex: 1
            }).add()), this.isDirtyBox = !1;
        },
        propFromSeries: function() {
            var a, b, c, d = this, e = d.options.chart, f = d.options.series;
            db([ "inverted", "angular", "polar" ], function(g) {
                for (a = Za[e.type || e.defaultSeriesType], c = d[g] || e[g] || a && a.prototype[g], 
                b = f && f.length; !c && b--; ) (a = Za[f[b].type]) && a.prototype[g] && (c = !0);
                d[g] = c;
            });
        },
        linkSeries: function() {
            var a = this, b = a.series;
            db(b, function(a) {
                a.linkedSeries.length = 0;
            }), db(b, function(b) {
                var c = b.options.linkedTo;
                d(c) && (c = ":previous" === c ? a.series[b.index - 1] : a.get(c)) && (c.linkedSeries.push(b), 
                b.linkedParent = c);
            });
        },
        render: function() {
            var b, d = this, e = d.axes, f = d.renderer, g = d.options, h = g.labels, i = g.credits;
            d.setTitle(), d.legend = new Q(d, g.legend), d.getStacks(), db(e, function(a) {
                a.setScale();
            }), d.getMargins(), d.maxTicks = null, db(e, function(a) {
                a.setTickPositions(!0), a.setMaxTicks();
            }), d.adjustTickAmounts(), d.getMargins(), d.drawChartBox(), d.hasCartesianSeries && db(e, function(a) {
                a.render();
            }), d.seriesGroup || (d.seriesGroup = f.g("series-group").attr({
                zIndex: 3
            }).add()), db(d.series, function(a) {
                a.translate(), a.setTooltipPoints(), a.render();
            }), h.items && db(h.items, function(b) {
                var e = a(h.style, b.style), g = c(e.left) + d.plotLeft, i = c(e.top) + d.plotTop + 12;
                delete e.left, delete e.top, f.text(b.html, g, i).attr({
                    zIndex: 2
                }).css(e).add();
            }), i.enabled && !d.credits && (b = i.href, d.credits = f.text(i.text, 0, 0).on("click", function() {
                b && (location.href = b);
            }).attr({
                align: i.position.align,
                zIndex: 8
            }).css(i.style).add().align(i.position)), d.hasRendered = !0;
        },
        destroy: function() {
            var a, b = this, c = b.axes, d = b.series, e = b.container, f = e && e.parentNode;
            for (jb(b, "destroy"), Ma[b.index] = S, b.renderTo.removeAttribute("data-highcharts-chart"), 
            ib(b), a = c.length; a--; ) c[a] = c[a].destroy();
            for (a = d.length; a--; ) d[a] = d[a].destroy();
            db("title,subtitle,chartBackground,plotBackground,plotBGImage,plotBorder,seriesGroup,clipRect,credits,pointer,scroller,rangeSelector,legend,resetZoomButton,tooltip,renderer".split(","), function(a) {
                var c = b[a];
                c && c.destroy && (b[a] = c.destroy());
            }), e && (e.innerHTML = "", ib(e), f && E(e));
            for (a in b) delete b[a];
        },
        isReadyToRender: function() {
            var a = this;
            return !(!Fa && la == la.top && "complete" !== ka.readyState || Ha && !la.canvg) || (Ha ? sb.push(function() {
                a.firstRender();
            }, a.options.global.canvasToolsURL) : ka.attachEvent("onreadystatechange", function() {
                ka.detachEvent("onreadystatechange", a.firstRender), "complete" === ka.readyState && a.firstRender();
            }), !1);
        },
        firstRender: function() {
            var a = this, b = a.options, c = a.callback;
            a.isReadyToRender() && (a.getContainer(), jb(a, "init"), a.resetMargins(), a.setChartSize(), 
            a.propFromSeries(), a.getAxes(), db(b.series || [], function(b) {
                a.initSeries(b);
            }), a.linkSeries(), jb(a, "beforeRender"), a.pointer = new P(a, b), a.render(), 
            a.renderer.draw(), c && c.apply(a, [ a ]), db(a.callbacks, function(b) {
                b.apply(a, [ a ]);
            }), a.cloneRenderTo(!0), jb(a, "load"));
        },
        splashArray: function(a, b) {
            var c = b[a], c = e(c) ? c : [ c, c, c, c ];
            return [ n(b[a + "Top"], c[0]), n(b[a + "Right"], c[1]), n(b[a + "Bottom"], c[2]), n(b[a + "Left"], c[3]) ];
        }
    }, R.prototype.callbacks = [];
    var tb = function() {};
    tb.prototype = {
        init: function(a, b, c) {
            return this.series = a, this.applyOptions(b, c), this.pointAttr = {}, a.options.colorByPoint && (b = a.options.colors || a.chart.options.colors, 
            this.color = this.color || b[a.colorCounter++], a.colorCounter === b.length) && (a.colorCounter = 0), 
            a.chart.pointCount++, this;
        },
        applyOptions: function(b, c) {
            var d = this.series, e = d.pointValKey, b = tb.prototype.optionsToObject.call(this, b);
            return a(this, b), this.options = this.options ? a(this.options, b) : b, e && (this.y = this[e]), 
            this.x === S && d && (this.x = c === S ? d.autoIncrement() : c), this;
        },
        optionsToObject: function(a) {
            var b, c = this.series, d = c.pointArrayMap || [ "y" ], e = d.length, g = 0, h = 0;
            if ("number" == typeof a || null === a) b = {
                y: a
            }; else if (f(a)) for (b = {}, a.length > e && (c = typeof a[0], "string" === c ? b.name = a[0] : "number" === c && (b.x = a[0]), 
            g++); h < e; ) b[d[h++]] = a[g++]; else "object" == typeof a && (b = a, a.dataLabels && (c._hasPointLabels = !0), 
            a.marker && (c._hasPointMarkers = !0));
            return b;
        },
        destroy: function() {
            var a, b = this.series.chart, c = b.hoverPoints;
            b.pointCount--, c && (this.setState(), j(c, this), !c.length) && (b.hoverPoints = null), 
            this === b.hoverPoint && this.onMouseOut(), (this.graphic || this.dataLabel) && (ib(this), 
            this.destroyElements()), this.legendItem && b.legend.destroyItem(this);
            for (a in this) this[a] = null;
        },
        destroyElements: function() {
            for (var a, b = "graphic,dataLabel,dataLabelUpper,group,connector,shadowGroup".split(","), c = 6; c--; ) a = b[c], 
            this[a] && (this[a] = this[a].destroy());
        },
        getLabelConfig: function() {
            return {
                x: this.category,
                y: this.y,
                key: this.name || this.category,
                series: this.series,
                point: this,
                percentage: this.percentage,
                total: this.total || this.stackTotal
            };
        },
        select: function(a, b) {
            var c = this, d = c.series, e = d.chart, a = n(a, !c.selected);
            c.firePointEvent(a ? "select" : "unselect", {
                accumulate: b
            }, function() {
                c.selected = c.options.selected = a, d.options.data[cb(c, d.data)] = c.options, 
                c.setState(a && "select"), b || db(e.getSelectedPoints(), function(a) {
                    a.selected && a !== c && (a.selected = a.options.selected = !1, d.options.data[cb(a, d.data)] = a.options, 
                    a.setState(""), a.firePointEvent("unselect"));
                });
            });
        },
        onMouseOver: function(a) {
            var b = this.series, c = b.chart, d = c.tooltip, e = c.hoverPoint;
            e && e !== this && e.onMouseOut(), this.firePointEvent("mouseOver"), d && (!d.shared || b.noSharedTooltip) && d.refresh(this, a), 
            this.setState("hover"), c.hoverPoint = this;
        },
        onMouseOut: function() {
            var a = this.series.chart, b = a.hoverPoints;
            b && cb(this, b) !== -1 || (this.firePointEvent("mouseOut"), this.setState(), a.hoverPoint = null);
        },
        tooltipFormatter: function(a) {
            var b = this.series, c = b.tooltipOptions, d = n(c.valueDecimals, ""), e = c.valuePrefix || "", f = c.valueSuffix || "";
            return db(b.pointArrayMap || [ "y" ], function(b) {
                b = "{point." + b, (e || f) && (a = a.replace(b + "}", e + b + "}" + f)), a = a.replace(b + "}", b + ":,." + d + "f}");
            }), u(a, {
                point: this,
                series: this.series
            });
        },
        update: function(a, b, c) {
            var d, f = this, g = f.series, h = f.graphic, i = g.data, j = g.chart, k = g.options, b = n(b, !0);
            f.firePointEvent("update", {
                options: a
            }, function() {
                f.applyOptions(a), e(a) && (g.getAttribs(), h) && (a.marker && a.marker.symbol ? f.graphic = h.destroy() : h.attr(f.pointAttr[f.state || ""])), 
                d = cb(f, i), g.xData[d] = f.x, g.yData[d] = g.toYData ? g.toYData(f) : f.y, g.zData[d] = f.z, 
                k.data[d] = f.options, g.isDirty = g.isDirtyData = !0, !g.fixedBox && g.hasCartesianSeries && (j.isDirtyBox = !0), 
                "point" === k.legendType && j.legend.destroyItem(f), b && j.redraw(c);
            });
        },
        remove: function(a, b) {
            var c, d = this, e = d.series, f = e.points, g = e.chart, h = e.data;
            H(b, g), a = n(a, !0), d.firePointEvent("remove", null, function() {
                c = cb(d, h), h.length === f.length && f.splice(c, 1), h.splice(c, 1), e.options.data.splice(c, 1), 
                e.xData.splice(c, 1), e.yData.splice(c, 1), e.zData.splice(c, 1), d.destroy(), e.isDirty = !0, 
                e.isDirtyData = !0, a && g.redraw();
            });
        },
        firePointEvent: function(a, b, c) {
            var d = this, e = this.series.options;
            (e.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents(), 
            "click" === a && e.allowPointSelect && (c = function(a) {
                d.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
            }), jb(this, a, b, c);
        },
        importEvents: function() {
            if (!this.hasImportedEvents) {
                var a, c = b(this.series.options.point, this.options).events;
                this.events = c;
                for (a in c) hb(this, a, c[a]);
                this.hasImportedEvents = !0;
            }
        },
        setState: function(a) {
            var c = this.plotX, d = this.plotY, e = this.series, f = e.options.states, g = nb[e.type].marker && e.options.marker, h = g && !g.enabled, i = g && g.states[a], j = i && i.enabled === !1, k = e.stateMarkerGraphic, l = this.marker || {}, m = e.chart, n = this.pointAttr, a = a || "";
            a === this.state || this.selected && "select" !== a || f[a] && f[a].enabled === !1 || a && (j || h && !i.enabled) || (this.graphic ? (f = g && this.graphic.symbolName && n[a].r, 
            this.graphic.attr(b(n[a], f ? {
                x: c - f,
                y: d - f,
                width: 2 * f,
                height: 2 * f
            } : {}))) : (a && i && (f = i.radius, l = l.symbol || e.symbol, k && k.currentSymbol !== l && (k = k.destroy()), 
            k ? k.attr({
                x: c - f,
                y: d - f
            }) : (e.stateMarkerGraphic = k = m.renderer.symbol(l, c - f, d - f, 2 * f, 2 * f).attr(n[a]).add(e.markerGroup), 
            k.currentSymbol = l)), k && k[a && m.isInsidePlot(c, d) ? "show" : "hide"]()), this.state = a);
        }
    };
    var ub = function() {};
    ub.prototype = {
        isCartesian: !0,
        type: "line",
        pointClass: tb,
        sorted: !0,
        requireSorting: !0,
        pointAttrToOptions: {
            stroke: "lineColor",
            "stroke-width": "lineWidth",
            fill: "fillColor",
            r: "radius"
        },
        colorCounter: 0,
        init: function(b, c) {
            var d, e, f = b.series;
            this.chart = b, this.options = c = this.setOptions(c), this.linkedSeries = [], this.bindAxes(), 
            a(this, {
                name: c.name,
                state: "",
                pointAttr: {},
                visible: c.visible !== !1,
                selected: c.selected === !0
            }), Ha && (c.animation = !1), e = c.events;
            for (d in e) hb(this, d, e[d]);
            (e && e.click || c.point && c.point.events && c.point.events.click || c.allowPointSelect) && (b.runTrackerClick = !0), 
            this.getColor(), this.getSymbol(), this.setData(c.data, !1), this.isCartesian && (b.hasCartesianSeries = !0), 
            f.push(this), this._i = f.length - 1, A(f, function(a, b) {
                return n(a.options.index, a._i) - n(b.options.index, a._i);
            }), db(f, function(a, b) {
                a.index = b, a.name = a.name || "Series " + (b + 1);
            });
        },
        bindAxes: function() {
            var a, b = this, c = b.options, d = b.chart;
            b.isCartesian && db([ "xAxis", "yAxis" ], function(e) {
                db(d[e], function(d) {
                    a = d.options, (c[e] === a.index || c[e] !== S && c[e] === a.id || c[e] === S && 0 === a.index) && (d.series.push(b), 
                    b[e] = d, d.isDirty = !0);
                }), b[e] || F(18, !0);
            });
        },
        autoIncrement: function() {
            var a = this.options, b = this.xIncrement, b = n(b, a.pointStart, 0);
            return this.pointInterval = n(this.pointInterval, a.pointInterval, 1), this.xIncrement = b + this.pointInterval, 
            b;
        },
        getSegments: function() {
            var a, b = -1, c = [], d = this.points, e = d.length;
            if (e) if (this.options.connectNulls) {
                for (a = e; a--; ) null === d[a].y && d.splice(a, 1);
                d.length && (c = [ d ]);
            } else db(d, function(a, f) {
                null === a.y ? (f > b + 1 && c.push(d.slice(b + 1, f)), b = f) : f === e - 1 && c.push(d.slice(b + 1, f + 1));
            });
            this.segments = c;
        },
        setOptions: function(a) {
            var c = this.chart.options, d = c.plotOptions, e = d[this.type];
            return this.userOptions = a, a = b(e, d.series, a), this.tooltipOptions = b(c.tooltip, a.tooltip), 
            null === e.marker && delete a.marker, a;
        },
        getColor: function() {
            var a, b = this.options, c = this.userOptions, d = this.chart.options.colors, e = this.chart.counters;
            a = b.color || nb[this.type].color, a || b.colorByPoint || (k(c._colorIndex) ? b = c._colorIndex : (c._colorIndex = e.color, 
            b = e.color++), a = d[b]), this.color = a, e.wrapColor(d.length);
        },
        getSymbol: function() {
            var a = this.userOptions, b = this.options.marker, c = this.chart, d = c.options.symbols, c = c.counters;
            this.symbol = b.symbol, this.symbol || (k(a._symbolIndex) ? a = a._symbolIndex : (a._symbolIndex = c.symbol, 
            a = c.symbol++), this.symbol = d[a]), /^url/.test(this.symbol) && (b.radius = 0), 
            c.wrapSymbol(d.length);
        },
        drawLegendSymbol: function(a) {
            var b, c = this.options, d = c.marker, e = a.options;
            b = e.symbolWidth;
            var f = this.chart.renderer, g = this.legendGroup, a = a.baseline - na(.3 * f.fontMetrics(e.itemStyle.fontSize).b);
            c.lineWidth && (e = {
                "stroke-width": c.lineWidth
            }, c.dashStyle && (e.dashstyle = c.dashStyle), this.legendLine = f.path([ "M", 0, a, "L", b, a ]).attr(e).add(g)), 
            d && d.enabled && (c = d.radius, this.legendSymbol = b = f.symbol(this.symbol, b / 2 - c, a - c, 2 * c, 2 * c).add(g), 
            b.isMarker = !0);
        },
        addPoint: function(a, b, c, d) {
            var e, f = this.options, g = this.data, h = this.graph, i = this.area, j = this.chart, k = this.xData, l = this.yData, m = this.zData, o = this.names, p = h && h.shift || 0, q = f.data;
            if (H(d, j), c && db([ h, i, this.graphNeg, this.areaNeg ], function(a) {
                a && (a.shift = p + 1);
            }), i && (i.isArea = !0), b = n(b, !0), d = {
                series: this
            }, this.pointClass.prototype.applyOptions.apply(d, [ a ]), h = d.x, i = k.length, 
            this.requireSorting && h < k[i - 1]) for (e = !0; i && k[i - 1] > h; ) i--;
            k.splice(i, 0, h), l.splice(i, 0, this.toYData ? this.toYData(d) : d.y), m.splice(i, 0, d.z), 
            o && (o[h] = d.name), q.splice(i, 0, a), e && (this.data.splice(i, 0, null), this.processData()), 
            "point" === f.legendType && this.generatePoints(), c && (g[0] && g[0].remove ? g[0].remove(!1) : (g.shift(), 
            k.shift(), l.shift(), m.shift(), q.shift())), this.isDirtyData = this.isDirty = !0, 
            b && (this.getAttribs(), j.redraw());
        },
        setData: function(a, b) {
            var c, e = this.points, h = this.options, i = this.chart, j = null, k = this.xAxis, l = k && k.categories && !k.categories.length ? [] : null;
            this.xIncrement = null, this.pointRange = k && k.categories ? 1 : h.pointRange, 
            this.colorCounter = 0;
            var m = [], o = [], p = [], q = a ? a.length : [];
            c = n(h.turboThreshold, 1e3);
            var r = this.pointArrayMap, r = r && r.length, s = !!this.toYData;
            if (c && q > c) {
                for (c = 0; null === j && c < q; ) j = a[c], c++;
                if (g(j)) {
                    for (j = n(h.pointStart, 0), h = n(h.pointInterval, 1), c = 0; c < q; c++) m[c] = j, 
                    o[c] = a[c], j += h;
                    this.xIncrement = j;
                } else if (f(j)) if (r) for (c = 0; c < q; c++) h = a[c], m[c] = h[0], o[c] = h.slice(1, r + 1); else for (c = 0; c < q; c++) h = a[c], 
                m[c] = h[0], o[c] = h[1]; else F(12);
            } else for (c = 0; c < q; c++) a[c] !== S && (h = {
                series: this
            }, this.pointClass.prototype.applyOptions.apply(h, [ a[c] ]), m[c] = h.x, o[c] = s ? this.toYData(h) : h.y, 
            p[c] = h.z, l && h.name) && (l[h.x] = h.name);
            for (d(o[0]) && F(14, !0), this.data = [], this.options.data = a, this.xData = m, 
            this.yData = o, this.zData = p, this.names = l, c = e && e.length || 0; c--; ) e[c] && e[c].destroy && e[c].destroy();
            k && (k.minRange = k.userMinRange), this.isDirty = this.isDirtyData = i.isDirtyBox = !0, 
            n(b, !0) && i.redraw(!1);
        },
        remove: function(a, b) {
            var c = this, d = c.chart, a = n(a, !0);
            c.isRemoving || (c.isRemoving = !0, jb(c, "remove", null, function() {
                c.destroy(), d.isDirtyLegend = d.isDirtyBox = !0, d.linkSeries(), a && d.redraw(b);
            })), c.isRemoving = !1;
        },
        processData: function(a) {
            var b, c = this.xData, d = this.yData, e = c.length;
            b = 0;
            var f, g, h = this.xAxis, i = this.options, j = i.cropThreshold, k = this.isCartesian;
            if (k && !this.isDirty && !h.isDirty && !this.yAxis.isDirty && !a) return !1;
            for (k && this.sorted && (!j || e > j || this.forceCrop) && (a = h.min, h = h.max, 
            c[e - 1] < a || c[0] > h ? (c = [], d = []) : (c[0] < a || c[e - 1] > h) && (b = this.cropData(this.xData, this.yData, a, h), 
            c = b.xData, d = b.yData, b = b.start, f = !0)), h = c.length - 1; h >= 0; h--) e = c[h] - c[h - 1], 
            e > 0 && (g === S || e < g) ? g = e : e < 0 && this.requireSorting && F(15);
            this.cropped = f, this.cropStart = b, this.processedXData = c, this.processedYData = d, 
            null === i.pointRange && (this.pointRange = g || 1), this.closestPointRange = g;
        },
        cropData: function(a, b, c, d) {
            var e, f = a.length, g = 0, h = f, i = n(this.cropShoulder, 1);
            for (e = 0; e < f; e++) if (a[e] >= c) {
                g = qa(0, e - i);
                break;
            }
            for (;e < f; e++) if (a[e] > d) {
                h = e + i;
                break;
            }
            return {
                xData: a.slice(g, h),
                yData: b.slice(g, h),
                start: g,
                end: h
            };
        },
        generatePoints: function() {
            var a, b, c, d, e = this.options.data, f = this.data, g = this.processedXData, h = this.processedYData, i = this.pointClass, j = g.length, k = this.cropStart || 0, l = this.hasGroupedData, n = [];
            for (f || l || (f = [], f.length = e.length, f = this.data = f), d = 0; d < j; d++) b = k + d, 
            l ? n[d] = new i().init(this, [ g[d] ].concat(m(h[d]))) : (f[b] ? c = f[b] : e[b] !== S && (f[b] = c = new i().init(this, e[b], g[d])), 
            n[d] = c);
            if (f && (j !== (a = f.length) || l)) for (d = 0; d < a; d++) d === k && !l && (d += j), 
            f[d] && (f[d].destroyElements(), f[d].plotX = S);
            this.data = f, this.points = n;
        },
        setStackedPoints: function() {
            if (this.options.stacking && (this.visible === !0 || this.chart.options.chart.ignoreHiddenSeries === !1)) {
                var a, b, c, d, e, f = this.processedXData, g = this.processedYData, h = [], i = g.length, j = this.options, k = j.threshold, l = j.stack, j = j.stacking, m = this.stackKey, n = "-" + m, o = this.negStacks, p = this.yAxis, q = p.stacks, r = p.oldStacks;
                for (c = 0; c < i; c++) d = f[c], e = g[c], b = (a = o && e < k) ? n : m, q[b] || (q[b] = {}), 
                q[b][d] || (r[b] && r[b][d] ? (q[b][d] = r[b][d], q[b][d].total = null) : q[b][d] = new M(p, p.options.stackLabels, a, d, l, j)), 
                b = q[b][d], b.points[this.index] = [ b.cum || 0 ], "percent" === j ? (a = a ? m : n, 
                o && q[a] && q[a][d] ? (a = q[a][d], b.total = a.total = qa(a.total, b.total) + sa(e) || 0) : b.total += sa(e) || 0) : b.total += e || 0, 
                b.cum = (b.cum || 0) + (e || 0), b.points[this.index].push(b.cum), h[c] = b.cum;
                "percent" === j && (p.usePercentage = !0), this.stackedYData = h, p.oldStacks = {};
            }
        },
        setPercentStacks: function() {
            var a = this, b = a.stackKey, c = a.yAxis.stacks;
            db([ b, "-" + b ], function(b) {
                for (var d, e, f, g = a.xData.length; g--; ) e = a.xData[g], d = (f = c[b] && c[b][e]) && f.points[a.index], 
                (e = d) && (f = f.total ? 100 / f.total : 0, e[0] = G(e[0] * f), e[1] = G(e[1] * f), 
                a.stackedYData[g] = e[1]);
            });
        },
        getExtremes: function() {
            var a, b, c, d, e = this.yAxis, f = this.processedXData, g = this.stackedYData || this.processedYData, h = g.length, i = [], j = 0, k = this.xAxis.getExtremes(), l = k.min, k = k.max;
            for (d = 0; d < h; d++) if (b = f[d], c = g[d], a = null !== c && c !== S && (!e.isLog || c.length || c > 0), 
            b = this.getExtremesFromAll || this.cropped || (f[d + 1] || b) >= l && (f[d - 1] || b) <= k, 
            a && b) if (a = c.length) for (;a--; ) null !== c[a] && (i[j++] = c[a]); else i[j++] = c;
            this.dataMin = n(void 0, B(i)), this.dataMax = n(void 0, C(i));
        },
        translate: function() {
            this.processedXData || this.processData(), this.generatePoints();
            for (var a = this.options, b = a.stacking, c = this.xAxis, d = c.categories, e = this.yAxis, f = this.points, h = f.length, i = !!this.modifyValue, j = a.pointPlacement, l = "between" === j || g(j), m = a.threshold, a = 0; a < h; a++) {
                var o = f[a], p = o.x, q = o.y, r = o.low, s = e.stacks[(this.negStacks && q < m ? "-" : "") + this.stackKey];
                e.isLog && q <= 0 && (o.y = q = null), o.plotX = c.translate(p, 0, 0, 0, 1, j, "flags" === this.type), 
                b && this.visible && s && s[p] && (s = s[p], q = s.points[this.index], r = q[0], 
                q = q[1], 0 === r && (r = n(m, e.min)), e.isLog && r <= 0 && (r = null), o.percentage = "percent" === b && q, 
                o.total = o.stackTotal = s.total, o.stackY = q, s.setOffset(this.pointXOffset || 0, this.barW || 0)), 
                o.yBottom = k(r) ? e.translate(r, 0, 1, 0, 1) : null, i && (q = this.modifyValue(q, o)), 
                o.plotY = "number" == typeof q && q !== 1 / 0 ? e.translate(q, 0, 1, 0, 1) : S, 
                o.clientX = l ? c.translate(p, 0, 0, 0, 1) : o.plotX, o.negative = o.y < (m || 0), 
                o.category = d && d[o.x] !== S ? d[o.x] : o.x;
            }
            this.getSegments();
        },
        setTooltipPoints: function(a) {
            var b, c, d, e, f = [], g = this.xAxis, h = g && g.getExtremes(), i = g ? g.tooltipLen || g.len : this.chart.plotSizeX, j = [];
            if (this.options.enableMouseTracking !== !1) {
                for (a && (this.tooltipPoints = null), db(this.segments || this.points, function(a) {
                    f = f.concat(a);
                }), g && g.reversed && (f = f.reverse()), this.orderTooltipPoints && this.orderTooltipPoints(f), 
                a = f.length, e = 0; e < a; e++) if (g = f[e], b = g.x, b >= h.min && b <= h.max) for (d = f[e + 1], 
                b = c === S ? 0 : c + 1, c = f[e + 1] ? ra(qa(0, oa((g.clientX + (d ? d.wrappedClientX || d.clientX : i)) / 2)), i) : i; b >= 0 && b <= c; ) j[b++] = g;
                this.tooltipPoints = j;
            }
        },
        tooltipHeaderFormatter: function(a) {
            var b, c = this.tooltipOptions, d = c.xDateFormat, e = c.dateTimeLabelFormats, f = this.xAxis, h = f && "datetime" === f.options.type, c = c.headerFormat, f = f && f.closestPointRange;
            if (h && !d) if (f) {
                for (b in Z) if (Z[b] >= f) {
                    d = e[b];
                    break;
                }
            } else d = e.day;
            return h && d && g(a.key) && (c = c.replace("{point.key}", "{point.key:" + d + "}")), 
            u(c, {
                point: a,
                series: this
            });
        },
        onMouseOver: function() {
            var a = this.chart, b = a.hoverSeries;
            b && b !== this && b.onMouseOut(), this.options.events.mouseOver && jb(this, "mouseOver"), 
            this.setState("hover"), a.hoverSeries = this;
        },
        onMouseOut: function() {
            var a = this.options, b = this.chart, c = b.tooltip, d = b.hoverPoint;
            d && d.onMouseOut(), this && a.events.mouseOut && jb(this, "mouseOut"), c && !a.stickyTracking && (!c.shared || this.noSharedTooltip) && c.hide(), 
            this.setState(), b.hoverSeries = null;
        },
        animate: function(b) {
            var c, d = this, f = d.chart, g = f.renderer;
            c = d.options.animation;
            var h, i = f.clipBox, j = f.inverted;
            c && !e(c) && (c = nb[d.type].animation), h = "_sharedClip" + c.duration + c.easing, 
            b ? (b = f[h], c = f[h + "m"], b || (f[h] = b = g.clipRect(a(i, {
                width: 0
            })), f[h + "m"] = c = g.clipRect(-99, j ? -f.plotLeft : -f.plotTop, 99, j ? f.chartWidth : f.chartHeight)), 
            d.group.clip(b), d.markerGroup.clip(c), d.sharedClipKey = h) : ((b = f[h]) && (b.animate({
                width: f.plotSizeX
            }, c), f[h + "m"].animate({
                width: f.plotSizeX + 99
            }, c)), d.animate = null, d.animationTimeout = setTimeout(function() {
                d.afterAnimate();
            }, c.duration));
        },
        afterAnimate: function() {
            var a = this.chart, b = this.sharedClipKey, c = this.group;
            c && this.options.clip !== !1 && (c.clip(a.clipRect), this.markerGroup.clip()), 
            setTimeout(function() {
                b && a[b] && (a[b] = a[b].destroy(), a[b + "m"] = a[b + "m"].destroy());
            }, 100);
        },
        drawPoints: function() {
            var b, c, d, e, f, g, h, i, j, k, l = this.points, m = this.chart, o = this.options.marker, p = this.markerGroup;
            if (o.enabled || this._hasPointMarkers) for (e = l.length; e--; ) f = l[e], c = oa(f.plotX), 
            d = f.plotY, j = f.graphic, h = f.marker || {}, b = o.enabled && h.enabled === S || h.enabled, 
            k = m.isInsidePlot(na(c), d, m.inverted), b && d !== S && !isNaN(d) && null !== f.y ? (b = f.pointAttr[f.selected ? "select" : ""], 
            g = b.r, h = n(h.symbol, this.symbol), i = 0 === h.indexOf("url"), j ? j.attr({
                visibility: k ? Fa ? "inherit" : "visible" : "hidden"
            }).animate(a({
                x: c - g,
                y: d - g
            }, j.symbolName ? {
                width: 2 * g,
                height: 2 * g
            } : {})) : k && (g > 0 || i) && (f.graphic = m.renderer.symbol(h, c - g, d - g, 2 * g, 2 * g).attr(b).add(p))) : j && (f.graphic = j.destroy());
        },
        convertAttribs: function(a, b, c, d) {
            var e, f, g = this.pointAttrToOptions, h = {}, a = a || {}, b = b || {}, c = c || {}, d = d || {};
            for (e in g) f = g[e], h[e] = n(a[f], b[e], c[e], d[e]);
            return h;
        },
        getAttribs: function() {
            var b, c, d, e = this, f = e.options, g = nb[e.type].marker ? f.marker : f, h = g.states, i = h.hover, j = e.color, l = {
                stroke: j,
                fill: j
            }, m = e.points || [], n = [], o = e.pointAttrToOptions, p = f.negativeColor, q = g.lineColor;
            for (f.marker ? (i.radius = i.radius || g.radius + 2, i.lineWidth = i.lineWidth || g.lineWidth + 1) : i.color = i.color || ob(i.color || j).brighten(i.brightness).get(), 
            n[""] = e.convertAttribs(g, l), db([ "hover", "select" ], function(a) {
                n[a] = e.convertAttribs(h[a], n[""]);
            }), e.pointAttr = n, j = m.length; j--; ) {
                if (l = m[j], (g = l.options && l.options.marker || l.options) && g.enabled === !1 && (g.radius = 0), 
                l.negative && p && (l.color = l.fillColor = p), b = f.colorByPoint || l.color, l.options) for (d in o) k(g[o[d]]) && (b = !0);
                b ? (g = g || {}, c = [], h = g.states || {}, b = h.hover = h.hover || {}, f.marker || (b.color = ob(b.color || l.color).brighten(b.brightness || i.brightness).get()), 
                c[""] = e.convertAttribs(a({
                    color: l.color,
                    fillColor: l.color,
                    lineColor: null === q ? l.color : S
                }, g), n[""]), c.hover = e.convertAttribs(h.hover, n.hover, c[""]), c.select = e.convertAttribs(h.select, n.select, c[""])) : c = n, 
                l.pointAttr = c;
            }
        },
        update: function(c, d) {
            var e, f = this.chart, g = this.type, h = Za[g].prototype, c = b(this.userOptions, {
                animation: !1,
                index: this.index,
                pointStart: this.xData[0]
            }, {
                data: this.options.data
            }, c);
            this.remove(!1);
            for (e in h) h.hasOwnProperty(e) && (this[e] = S);
            a(this, Za[c.type || g].prototype), this.init(f, c), n(d, !0) && f.redraw(!1);
        },
        destroy: function() {
            var a, b, c, d, e, f = this, g = f.chart, h = /AppleWebKit\/533/.test(xa), i = f.data || [];
            for (jb(f, "destroy"), ib(f), db([ "xAxis", "yAxis" ], function(a) {
                (e = f[a]) && (j(e.series, f), e.isDirty = e.forceRedraw = !0, e.stacks = {});
            }), f.legendItem && f.chart.legend.destroyItem(f), b = i.length; b--; ) (c = i[b]) && c.destroy && c.destroy();
            f.points = null, clearTimeout(f.animationTimeout), db("area,graph,dataLabelsGroup,group,markerGroup,tracker,graphNeg,areaNeg,posClip,negClip".split(","), function(b) {
                f[b] && (a = h && "group" === b ? "hide" : "destroy", f[b][a]());
            }), g.hoverSeries === f && (g.hoverSeries = null), j(g.series, f);
            for (d in f) delete f[d];
        },
        drawDataLabels: function() {
            var a, c, d, e, f = this, g = f.options.dataLabels, h = f.points;
            (g.enabled || f._hasPointLabels) && (f.dlProcessOptions && f.dlProcessOptions(g), 
            e = f.plotGroup("dataLabelsGroup", "data-labels", f.visible ? "visible" : "hidden", g.zIndex || 6), 
            c = g, db(h, function(h) {
                var i, j, l, m = h.dataLabel, o = h.connector, p = !0;
                if (a = h.options && h.options.dataLabels, i = n(a && a.enabled, c.enabled), m && !i) h.dataLabel = m.destroy(); else if (i) {
                    if (g = b(c, a), i = g.rotation, j = h.getLabelConfig(), d = g.format ? u(g.format, j) : g.formatter.call(j, g), 
                    g.style.color = n(g.color, g.style.color, f.color, "black"), m) k(d) ? (m.attr({
                        text: d
                    }), p = !1) : (h.dataLabel = m = m.destroy(), o && (h.connector = o.destroy())); else if (k(d)) {
                        m = {
                            fill: g.backgroundColor,
                            stroke: g.borderColor,
                            "stroke-width": g.borderWidth,
                            r: g.borderRadius || 0,
                            rotation: i,
                            padding: g.padding,
                            zIndex: 1
                        };
                        for (l in m) m[l] === S && delete m[l];
                        m = h.dataLabel = f.chart.renderer[i ? "text" : "label"](d, 0, -999, null, null, null, g.useHTML).attr(m).css(g.style).add(e).shadow(g.shadow);
                    }
                    m && f.alignDataLabel(h, m, g, null, p);
                }
            }));
        },
        alignDataLabel: function(b, c, d, e, f) {
            var g = this.chart, h = g.inverted, i = n(b.plotX, -999), j = n(b.plotY, -999), k = c.getBBox();
            (b = this.visible && g.isInsidePlot(b.plotX, b.plotY, h)) && (e = a({
                x: h ? g.plotWidth - j : i,
                y: na(h ? g.plotHeight - i : j),
                width: 0,
                height: 0
            }, e), a(d, {
                width: k.width,
                height: k.height
            }), d.rotation ? (h = {
                align: d.align,
                x: e.x + d.x + e.width / 2,
                y: e.y + d.y + e.height / 2
            }, c[f ? "attr" : "animate"](h)) : (c.align(d, null, e), h = c.alignAttr, "justify" === n(d.overflow, "justify") ? this.justifyDataLabel(c, d, h, k, e, f) : n(d.crop, !0) && (b = g.isInsidePlot(h.x, h.y) && g.isInsidePlot(h.x + k.width, h.y + k.height)))), 
            b || c.attr({
                y: -999
            });
        },
        justifyDataLabel: function(a, b, c, d, e, f) {
            var g, h, i = this.chart, j = b.align, k = b.verticalAlign;
            g = c.x, g < 0 && ("right" === j ? b.align = "left" : b.x = -g, h = !0), g = c.x + d.width, 
            g > i.plotWidth && ("left" === j ? b.align = "right" : b.x = i.plotWidth - g, h = !0), 
            g = c.y, g < 0 && ("bottom" === k ? b.verticalAlign = "top" : b.y = -g, h = !0), 
            g = c.y + d.height, g > i.plotHeight && ("top" === k ? b.verticalAlign = "bottom" : b.y = i.plotHeight - g, 
            h = !0), h && (a.placed = !f, a.align(b, null, e));
        },
        getSegmentPath: function(a) {
            var b = this, c = [], d = b.options.step;
            return db(a, function(e, f) {
                var g, h = e.plotX, i = e.plotY;
                b.getPointSpline ? c.push.apply(c, b.getPointSpline(a, e, f)) : (c.push(f ? "L" : "M"), 
                d && f && (g = a[f - 1], "right" === d ? c.push(g.plotX, i) : "center" === d ? c.push((g.plotX + h) / 2, g.plotY, (g.plotX + h) / 2, i) : c.push(h, g.plotY)), 
                c.push(e.plotX, e.plotY));
            }), c;
        },
        getGraphPath: function() {
            var a, b = this, c = [], d = [];
            return db(b.segments, function(e) {
                a = b.getSegmentPath(e), e.length > 1 ? c = c.concat(a) : d.push(e[0]);
            }), b.singlePoints = d, b.graphPath = c;
        },
        drawGraph: function() {
            var a = this, b = this.options, c = [ [ "graph", b.lineColor || this.color ] ], d = b.lineWidth, e = b.dashStyle, f = this.getGraphPath(), g = b.negativeColor;
            g && c.push([ "graphNeg", g ]), db(c, function(c, g) {
                var h = c[0], i = a[h];
                i ? (mb(i), i.animate({
                    d: f
                })) : d && f.length && (i = {
                    stroke: c[1],
                    "stroke-width": d,
                    zIndex: 1
                }, e ? i.dashstyle = e : i["stroke-linecap"] = i["stroke-linejoin"] = "round", a[h] = a.chart.renderer.path(f).attr(i).add(a.group).shadow(!g && b.shadow));
            });
        },
        clipNeg: function() {
            var a, b = this.options, c = this.chart, d = c.renderer, e = b.negativeColor || b.negativeFillColor, f = this.graph, g = this.area, h = this.posClip, i = this.negClip;
            a = c.chartWidth;
            var j = c.chartHeight, k = qa(a, j), l = this.yAxis;
            e && (f || g) && (e = na(l.toPixels(b.threshold || 0, !0)), b = {
                x: 0,
                y: 0,
                width: k,
                height: e
            }, k = {
                x: 0,
                y: e,
                width: k,
                height: k
            }, c.inverted && (b.height = k.y = c.plotWidth - e, d.isVML && (b = {
                x: c.plotWidth - e - c.plotLeft,
                y: 0,
                width: a,
                height: j
            }, k = {
                x: e + c.plotLeft - a,
                y: 0,
                width: c.plotLeft + e,
                height: a
            })), l.reversed ? (c = k, a = b) : (c = b, a = k), h ? (h.animate(c), i.animate(a)) : (this.posClip = h = d.clipRect(c), 
            this.negClip = i = d.clipRect(a), f && this.graphNeg && (f.clip(h), this.graphNeg.clip(i)), 
            g && (g.clip(h), this.areaNeg.clip(i))));
        },
        invertGroups: function() {
            function a() {
                var a = {
                    width: b.yAxis.len,
                    height: b.xAxis.len
                };
                db([ "group", "markerGroup" ], function(c) {
                    b[c] && b[c].attr(a).invert();
                });
            }
            var b = this, c = b.chart;
            b.xAxis && (hb(c, "resize", a), hb(b, "destroy", function() {
                ib(c, "resize", a);
            }), a(), b.invertGroups = a);
        },
        plotGroup: function(a, b, c, d, e) {
            var f = this[a], g = !f;
            return g && (this[a] = f = this.chart.renderer.g(b).attr({
                visibility: c,
                zIndex: d || .1
            }).add(e)), f[g ? "attr" : "animate"](this.getPlotBox()), f;
        },
        getPlotBox: function() {
            return {
                translateX: this.xAxis ? this.xAxis.left : this.chart.plotLeft,
                translateY: this.yAxis ? this.yAxis.top : this.chart.plotTop,
                scaleX: 1,
                scaleY: 1
            };
        },
        render: function() {
            var a, b = this.chart, c = this.options, d = c.animation && !!this.animate && b.renderer.isSVG, e = this.visible ? "visible" : "hidden", f = c.zIndex, g = this.hasRendered, h = b.seriesGroup;
            a = this.plotGroup("group", "series", e, f, h), this.markerGroup = this.plotGroup("markerGroup", "markers", e, f, h), 
            d && this.animate(!0), this.getAttribs(), a.inverted = !!this.isCartesian && b.inverted, 
            this.drawGraph && (this.drawGraph(), this.clipNeg()), this.drawDataLabels(), this.drawPoints(), 
            this.options.enableMouseTracking !== !1 && this.drawTracker(), b.inverted && this.invertGroups(), 
            c.clip !== !1 && !this.sharedClipKey && !g && a.clip(b.clipRect), d ? this.animate() : g || this.afterAnimate(), 
            this.isDirty = this.isDirtyData = !1, this.hasRendered = !0;
        },
        redraw: function() {
            var a = this.chart, b = this.isDirtyData, c = this.group, d = this.xAxis, e = this.yAxis;
            c && (a.inverted && c.attr({
                width: a.plotWidth,
                height: a.plotHeight
            }), c.animate({
                translateX: n(d && d.left, a.plotLeft),
                translateY: n(e && e.top, a.plotTop)
            })), this.translate(), this.setTooltipPoints(!0), this.render(), b && jb(this, "updatedData");
        },
        setState: function(a) {
            var b = this.options, c = this.graph, d = this.graphNeg, e = b.states, b = b.lineWidth, a = a || "";
            this.state !== a && (this.state = a, e[a] && e[a].enabled === !1 || (a && (b = e[a].lineWidth || b + 1), 
            c && !c.dashstyle && (a = {
                "stroke-width": b
            }, c.attr(a), d && d.attr(a))));
        },
        setVisible: function(a, b) {
            var c, d = this, e = d.chart, f = d.legendItem, g = e.options.chart.ignoreHiddenSeries, h = d.visible;
            c = (d.visible = a = d.userOptions.visible = a === S ? !h : a) ? "show" : "hide", 
            db([ "group", "dataLabelsGroup", "markerGroup", "tracker" ], function(a) {
                d[a] && d[a][c]();
            }), e.hoverSeries === d && d.onMouseOut(), f && e.legend.colorizeItem(d, a), d.isDirty = !0, 
            d.options.stacking && db(e.series, function(a) {
                a.options.stacking && a.visible && (a.isDirty = !0);
            }), db(d.linkedSeries, function(b) {
                b.setVisible(a, !1);
            }), g && (e.isDirtyBox = !0), b !== !1 && e.redraw(), jb(d, c);
        },
        show: function() {
            this.setVisible(!0);
        },
        hide: function() {
            this.setVisible(!1);
        },
        select: function(a) {
            this.selected = a = a === S ? !this.selected : a, this.checkbox && (this.checkbox.checked = a), 
            jb(this, a ? "select" : "unselect");
        },
        drawTracker: function() {
            var a, b = this, c = b.options, d = c.trackByArea, e = [].concat(d ? b.areaPath : b.graphPath), f = e.length, g = b.chart, h = g.pointer, i = g.renderer, j = g.options.tooltip.snap, k = b.tracker, l = c.cursor, m = l && {
                cursor: l
            }, l = b.singlePoints, n = function() {
                g.hoverSeries !== b && b.onMouseOver();
            };
            if (f && !d) for (a = f + 1; a--; ) "M" === e[a] && e.splice(a + 1, 0, e[a + 1] - j, e[a + 2], "L"), 
            (a && "M" === e[a] || a === f) && e.splice(a, 0, "L", e[a - 2] + j, e[a - 1]);
            for (a = 0; a < l.length; a++) f = l[a], e.push("M", f.plotX - j, f.plotY, "L", f.plotX + j, f.plotY);
            k ? k.attr({
                d: e
            }) : (b.tracker = i.path(e).attr({
                "stroke-linejoin": "round",
                visibility: b.visible ? "visible" : "hidden",
                stroke: Pa,
                fill: d ? Pa : Oa,
                "stroke-width": c.lineWidth + (d ? 0 : 2 * j),
                zIndex: 2
            }).add(b.group), db([ b.tracker, b.markerGroup ], function(a) {
                a.addClass("highcharts-tracker").on("mouseover", n).on("mouseout", function(a) {
                    h.onTrackerMouseOut(a);
                }).css(m), Ia && a.on("touchstart", n);
            }));
        }
    }, _a = q(ub), Za.line = _a, nb.area = b($a, {
        threshold: 0
    }), _a = q(ub, {
        type: "area",
        getSegments: function() {
            var a, b, c, d, e, f = [], g = [], h = [], i = this.xAxis, j = this.yAxis, k = j.stacks[this.stackKey], l = {}, m = this.points, n = this.options.connectNulls;
            if (this.options.stacking && !this.cropped) {
                for (d = 0; d < m.length; d++) l[m[d].x] = m[d];
                for (e in k) h.push(+e);
                h.sort(function(a, b) {
                    return a - b;
                }), db(h, function(d) {
                    (!n || l[d] && null !== l[d].y) && (l[d] ? g.push(l[d]) : (a = i.translate(d), c = k[d].percent ? k[d].total ? 100 * k[d].cum / k[d].total : 0 : k[d].cum, 
                    b = j.toPixels(c, !0), g.push({
                        y: null,
                        plotX: a,
                        clientX: a,
                        plotY: b,
                        yBottom: b,
                        onMouseOver: La
                    })));
                }), g.length && f.push(g);
            } else ub.prototype.getSegments.call(this), f = this.segments;
            this.segments = f;
        },
        getSegmentPath: function(a) {
            var b, c = ub.prototype.getSegmentPath.call(this, a), d = [].concat(c), e = this.options;
            b = c.length;
            var f, g = this.yAxis.getThreshold(e.threshold);
            if (3 === b && d.push("L", c[1], c[2]), e.stacking && !this.closedStacks) for (b = a.length - 1; b >= 0; b--) f = n(a[b].yBottom, g), 
            b < a.length - 1 && e.step && d.push(a[b + 1].plotX, f), d.push(a[b].plotX, f); else this.closeSegment(d, a, g);
            return this.areaPath = this.areaPath.concat(d), c;
        },
        closeSegment: function(a, b, c) {
            a.push("L", b[b.length - 1].plotX, c, "L", b[0].plotX, c);
        },
        drawGraph: function() {
            this.areaPath = [], ub.prototype.drawGraph.apply(this);
            var a = this, b = this.areaPath, c = this.options, d = c.negativeColor, e = c.negativeFillColor, f = [ [ "area", this.color, c.fillColor ] ];
            (d || e) && f.push([ "areaNeg", d, e ]), db(f, function(d) {
                var e = d[0], f = a[e];
                f ? f.animate({
                    d: b
                }) : a[e] = a.chart.renderer.path(b).attr({
                    fill: n(d[2], ob(d[1]).setOpacity(n(c.fillOpacity, .75)).get()),
                    zIndex: 0
                }).add(a.group);
            });
        },
        drawLegendSymbol: function(a, b) {
            b.legendSymbol = this.chart.renderer.rect(0, a.baseline - 11, a.options.symbolWidth, 12, 2).attr({
                zIndex: 3
            }).add(b.legendGroup);
        }
    }), Za.area = _a, nb.spline = b($a), qb = q(ub, {
        type: "spline",
        getPointSpline: function(a, b, c) {
            var d, e, f, g, h = b.plotX, i = b.plotY, j = a[c - 1], k = a[c + 1];
            if (j && k) {
                a = j.plotY, f = k.plotX;
                var l, k = k.plotY;
                d = (1.5 * h + j.plotX) / 2.5, e = (1.5 * i + a) / 2.5, f = (1.5 * h + f) / 2.5, 
                g = (1.5 * i + k) / 2.5, l = (g - e) * (f - h) / (f - d) + i - g, e += l, g += l, 
                e > a && e > i ? (e = qa(a, i), g = 2 * i - e) : e < a && e < i && (e = ra(a, i), 
                g = 2 * i - e), g > k && g > i ? (g = qa(k, i), e = 2 * i - g) : g < k && g < i && (g = ra(k, i), 
                e = 2 * i - g), b.rightContX = f, b.rightContY = g;
            }
            return c ? (b = [ "C", j.rightContX || j.plotX, j.rightContY || j.plotY, d || h, e || i, h, i ], 
            j.rightContX = j.rightContY = null) : b = [ "M", h, i ], b;
        }
    }), Za.spline = qb, nb.areaspline = b(nb.area), rb = _a.prototype, qb = q(qb, {
        type: "areaspline",
        closedStacks: !0,
        getSegmentPath: rb.getSegmentPath,
        closeSegment: rb.closeSegment,
        drawGraph: rb.drawGraph,
        drawLegendSymbol: rb.drawLegendSymbol
    }), Za.areaspline = qb, nb.column = b($a, {
        borderColor: "#FFFFFF",
        borderWidth: 1,
        borderRadius: 0,
        groupPadding: .2,
        marker: null,
        pointPadding: .1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
            hover: {
                brightness: .1,
                shadow: !1
            },
            select: {
                color: "#C0C0C0",
                borderColor: "#000000",
                shadow: !1
            }
        },
        dataLabels: {
            align: null,
            verticalAlign: null,
            y: null
        },
        stickyTracking: !1,
        threshold: 0
    }), qb = q(ub, {
        type: "column",
        pointAttrToOptions: {
            stroke: "borderColor",
            "stroke-width": "borderWidth",
            fill: "color",
            r: "borderRadius"
        },
        cropShoulder: 0,
        trackerGroups: [ "group", "dataLabelsGroup" ],
        negStacks: !0,
        init: function() {
            ub.prototype.init.apply(this, arguments);
            var a = this, b = a.chart;
            b.hasRendered && db(b.series, function(b) {
                b.type === a.type && (b.isDirty = !0);
            });
        },
        getColumnMetrics: function() {
            var a, b, c = this, d = c.options, e = c.xAxis, f = c.yAxis, g = e.reversed, h = {}, i = 0;
            d.grouping === !1 ? i = 1 : db(c.chart.series, function(d) {
                var e = d.options, g = d.yAxis;
                d.type === c.type && d.visible && f.len === g.len && f.pos === g.pos && (e.stacking ? (a = d.stackKey, 
                h[a] === S && (h[a] = i++), b = h[a]) : e.grouping !== !1 && (b = i++), d.columnIndex = b);
            });
            var e = ra(sa(e.transA) * (e.ordinalSlope || d.pointRange || e.closestPointRange || 1), e.len), j = e * d.groupPadding, l = (e - 2 * j) / i, m = d.pointWidth, d = k(m) ? (l - m) / 2 : l * d.pointPadding, m = n(m, l - 2 * d);
            return c.columnMetrics = {
                width: m,
                offset: d + (j + ((g ? i - (c.columnIndex || 0) : c.columnIndex) || 0) * l - e / 2) * (g ? -1 : 1)
            };
        },
        translate: function() {
            var a = this.chart, b = this.options, c = b.borderWidth, d = this.yAxis, e = this.translatedThreshold = d.getThreshold(b.threshold), f = n(b.minPointLength, 5), b = this.getColumnMetrics(), g = b.width, h = this.barW = pa(qa(g, 1 + 2 * c)), i = this.pointXOffset = b.offset, j = -(c % 2 ? .5 : 0), k = c % 2 ? .5 : 1;
            a.renderer.isVML && a.inverted && (k += 1), ub.prototype.translate.apply(this), 
            db(this.points, function(a) {
                var b, c = n(a.yBottom, e), l = ra(qa(-999 - c, a.plotY), d.len + 999 + c), m = a.plotX + i, o = h, p = ra(l, c), l = qa(l, c) - p;
                sa(l) < f && f && (l = f, p = na(sa(p - e) > f ? c - f : e - (d.translate(a.y, 0, 1, 0, 1) <= e ? f : 0))), 
                a.barX = m, a.pointWidth = g, c = sa(m) < .5, o = na(m + o) + j, m = na(m) + j, 
                o -= m, b = sa(p) < .5, l = na(p + l) + k, p = na(p) + k, l -= p, c && (m += 1, 
                o -= 1), b && (p -= 1, l += 1), a.shapeType = "rect", a.shapeArgs = {
                    x: m,
                    y: p,
                    width: o,
                    height: l
                };
            });
        },
        getSymbol: La,
        drawLegendSymbol: _a.prototype.drawLegendSymbol,
        drawGraph: La,
        drawPoints: function() {
            var a, c = this, d = c.options, e = c.chart.renderer;
            db(c.points, function(f) {
                var g = f.plotY, h = f.graphic;
                g === S || isNaN(g) || null === f.y ? h && (f.graphic = h.destroy()) : (a = f.shapeArgs, 
                h ? (mb(h), h.animate(b(a))) : f.graphic = e[f.shapeType](a).attr(f.pointAttr[f.selected ? "select" : ""]).add(c.group).shadow(d.shadow, null, d.stacking && !d.borderRadius));
            });
        },
        drawTracker: function() {
            var a = this, b = a.chart, c = b.pointer, d = a.options.cursor, e = d && {
                cursor: d
            }, f = function(c) {
                var d, e = c.target;
                for (b.hoverSeries !== a && a.onMouseOver(); e && !d; ) d = e.point, e = e.parentNode;
                d !== S && d !== b.hoverPoint && d.onMouseOver(c);
            };
            db(a.points, function(a) {
                a.graphic && (a.graphic.element.point = a), a.dataLabel && (a.dataLabel.element.point = a);
            }), a._hasTracking || (db(a.trackerGroups, function(b) {
                a[b] && (a[b].addClass("highcharts-tracker").on("mouseover", f).on("mouseout", function(a) {
                    c.onTrackerMouseOut(a);
                }).css(e), Ia) && a[b].on("touchstart", f);
            }), a._hasTracking = !0);
        },
        alignDataLabel: function(a, c, d, e, f) {
            var g = this.chart, h = g.inverted, i = a.dlBox || a.shapeArgs, j = a.below || a.plotY > n(this.translatedThreshold, g.plotSizeY), k = n(d.inside, !!this.options.stacking);
            i && (e = b(i), h && (e = {
                x: g.plotWidth - e.y - e.height,
                y: g.plotHeight - e.x - e.width,
                width: e.height,
                height: e.width
            }), !k) && (h ? (e.x += j ? 0 : e.width, e.width = 0) : (e.y += j ? e.height : 0, 
            e.height = 0)), d.align = n(d.align, !h || k ? "center" : j ? "right" : "left"), 
            d.verticalAlign = n(d.verticalAlign, h || k ? "middle" : j ? "top" : "bottom"), 
            ub.prototype.alignDataLabel.call(this, a, c, d, e, f);
        },
        animate: function(a) {
            var b = this.yAxis, c = this.options, d = this.chart.inverted, e = {};
            Fa && (a ? (e.scaleY = .001, a = ra(b.pos + b.len, qa(b.pos, b.toPixels(c.threshold))), 
            d ? e.translateX = a - b.len : e.translateY = a, this.group.attr(e)) : (e.scaleY = 1, 
            e[d ? "translateX" : "translateY"] = b.pos, this.group.animate(e, this.options.animation), 
            this.animate = null));
        },
        remove: function() {
            var a = this, b = a.chart;
            b.hasRendered && db(b.series, function(b) {
                b.type === a.type && (b.isDirty = !0);
            }), ub.prototype.remove.apply(a, arguments);
        }
    }), Za.column = qb, nb.bar = b(nb.column), rb = q(qb, {
        type: "bar",
        inverted: !0
    }), Za.bar = rb, nb.scatter = b($a, {
        lineWidth: 0,
        tooltip: {
            headerFormat: '<span style="font-size: 10px; color:{series.color}">{series.name}</span><br/>',
            pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>",
            followPointer: !0
        },
        stickyTracking: !1
    }), rb = q(ub, {
        type: "scatter",
        sorted: !1,
        requireSorting: !1,
        noSharedTooltip: !0,
        trackerGroups: [ "markerGroup" ],
        drawTracker: qb.prototype.drawTracker,
        setTooltipPoints: La
    }), Za.scatter = rb, nb.pie = b($a, {
        borderColor: "#FFFFFF",
        borderWidth: 1,
        center: [ null, null ],
        clip: !1,
        colorByPoint: !0,
        dataLabels: {
            distance: 30,
            enabled: !0,
            formatter: function() {
                return this.point.name;
            }
        },
        ignoreHiddenPoint: !0,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: !1,
        slicedOffset: 10,
        states: {
            hover: {
                brightness: .1,
                shadow: !1
            }
        },
        stickyTracking: !1,
        tooltip: {
            followPointer: !0
        }
    }), $a = {
        type: "pie",
        isCartesian: !1,
        pointClass: q(tb, {
            init: function() {
                tb.prototype.init.apply(this, arguments);
                var b, c = this;
                return c.y < 0 && (c.y = null), a(c, {
                    visible: c.visible !== !1,
                    name: n(c.name, "Slice")
                }), b = function(a) {
                    c.slice("select" === a.type);
                }, hb(c, "select", b), hb(c, "unselect", b), c;
            },
            setVisible: function(a) {
                var b, c = this, d = c.series, e = d.chart;
                c.visible = c.options.visible = a = a === S ? !c.visible : a, d.options.data[cb(c, d.data)] = c.options, 
                b = a ? "show" : "hide", db([ "graphic", "dataLabel", "connector", "shadowGroup" ], function(a) {
                    c[a] && c[a][b]();
                }), c.legendItem && e.legend.colorizeItem(c, a), !d.isDirty && d.options.ignoreHiddenPoint && (d.isDirty = !0, 
                e.redraw());
            },
            slice: function(a, b, c) {
                var d = this.series;
                H(c, d.chart), n(b, !0), this.sliced = this.options.sliced = a = k(a) ? a : !this.sliced, 
                d.options.data[cb(this, d.data)] = this.options, a = a ? this.slicedTranslation : {
                    translateX: 0,
                    translateY: 0
                }, this.graphic.animate(a), this.shadowGroup && this.shadowGroup.animate(a);
            }
        }),
        requireSorting: !1,
        noSharedTooltip: !0,
        trackerGroups: [ "group", "dataLabelsGroup" ],
        pointAttrToOptions: {
            stroke: "borderColor",
            "stroke-width": "borderWidth",
            fill: "color"
        },
        getColor: La,
        animate: function(a) {
            var b = this, c = b.points, d = b.startAngleRad;
            a || (db(c, function(a) {
                var c = a.graphic, a = a.shapeArgs;
                c && (c.attr({
                    r: b.center[3] / 2,
                    start: d,
                    end: d
                }), c.animate({
                    r: a.r,
                    start: a.start,
                    end: a.end
                }, b.options.animation));
            }), b.animate = null);
        },
        setData: function(a, b) {
            ub.prototype.setData.call(this, a, !1), this.processData(), this.generatePoints(), 
            n(b, !0) && this.chart.redraw();
        },
        generatePoints: function() {
            var a, b, c, d, e = 0, f = this.options.ignoreHiddenPoint;
            for (ub.prototype.generatePoints.call(this), b = this.points, c = b.length, a = 0; a < c; a++) d = b[a], 
            e += f && !d.visible ? 0 : d.y;
            for (this.total = e, a = 0; a < c; a++) d = b[a], d.percentage = e > 0 ? d.y / e * 100 : 0, 
            d.total = e;
        },
        getCenter: function() {
            var a, b, d = this.options, e = this.chart, f = 2 * (d.slicedOffset || 0), g = e.plotWidth - 2 * f, h = e.plotHeight - 2 * f, e = d.center, d = [ n(e[0], "50%"), n(e[1], "50%"), d.size || "100%", d.innerSize || 0 ], i = ra(g, h);
            return gb(d, function(d, e) {
                return b = /%$/.test(d), a = e < 2 || 2 === e && b, (b ? [ g, h, i, i ][e] * c(d) / 100 : d) + (a ? f : 0);
            });
        },
        translate: function(a) {
            this.generatePoints();
            var b, c, d, e, f, g = 0, h = this.options, i = h.slicedOffset, j = i + h.borderWidth, k = h.startAngle || 0, l = this.startAngleRad = va / 180 * (k - 90), k = (this.endAngleRad = va / 180 * ((h.endAngle || k + 360) - 90)) - l, m = this.points, n = h.dataLabels.distance, h = h.ignoreHiddenPoint, o = m.length;
            for (a || (this.center = a = this.getCenter()), this.getX = function(b, c) {
                return d = ma.asin((b - a[1]) / (a[2] / 2 + n)), a[0] + (c ? -1 : 1) * ta(d) * (a[2] / 2 + n);
            }, e = 0; e < o; e++) f = m[e], b = l + g * k, h && !f.visible || (g += f.percentage / 100), 
            c = l + g * k, f.shapeType = "arc", f.shapeArgs = {
                x: a[0],
                y: a[1],
                r: a[2] / 2,
                innerR: a[3] / 2,
                start: na(1e3 * b) / 1e3,
                end: na(1e3 * c) / 1e3
            }, d = (c + b) / 2, d > .75 * k && (d -= 2 * va), f.slicedTranslation = {
                translateX: na(ta(d) * i),
                translateY: na(ua(d) * i)
            }, b = ta(d) * a[2] / 2, c = ua(d) * a[2] / 2, f.tooltipPos = [ a[0] + .7 * b, a[1] + .7 * c ], 
            f.half = d < -va / 2 || d > va / 2 ? 1 : 0, f.angle = d, j = ra(j, n / 2), f.labelPos = [ a[0] + b + ta(d) * n, a[1] + c + ua(d) * n, a[0] + b + ta(d) * j, a[1] + c + ua(d) * j, a[0] + b, a[1] + c, n < 0 ? "center" : f.half ? "right" : "left", d ];
        },
        setTooltipPoints: La,
        drawGraph: null,
        drawPoints: function() {
            var b, c, d, e, f = this, g = f.chart.renderer, h = f.options.shadow;
            h && !f.shadowGroup && (f.shadowGroup = g.g("shadow").add(f.group)), db(f.points, function(i) {
                c = i.graphic, e = i.shapeArgs, d = i.shadowGroup, h && !d && (d = i.shadowGroup = g.g("shadow").add(f.shadowGroup)), 
                b = i.sliced ? i.slicedTranslation : {
                    translateX: 0,
                    translateY: 0
                }, d && d.attr(b), c ? c.animate(a(e, b)) : i.graphic = c = g.arc(e).setRadialReference(f.center).attr(i.pointAttr[i.selected ? "select" : ""]).attr({
                    "stroke-linejoin": "round"
                }).attr(b).add(f.group).shadow(h, d), i.visible === !1 && i.setVisible(!1);
            });
        },
        sortByAngle: function(a, b) {
            a.sort(function(a, c) {
                return void 0 !== a.angle && (c.angle - a.angle) * b;
            });
        },
        drawDataLabels: function() {
            var a, b, c, d, e, f, g, h, i, j, k, l, m = this, o = m.data, p = m.chart, q = m.options.dataLabels, r = n(q.connectorPadding, 10), s = n(q.connectorWidth, 1), t = p.plotWidth, p = p.plotHeight, u = n(q.softConnector, !0), v = q.distance, w = m.center, x = w[2] / 2, y = w[1], z = v > 0, A = [ [], [] ], B = [ 0, 0, 0, 0 ], D = function(a, b) {
                return b.y - a.y;
            };
            if (m.visible && (q.enabled || m._hasPointLabels)) {
                for (ub.prototype.drawDataLabels.apply(m), db(o, function(a) {
                    a.dataLabel && A[a.half].push(a);
                }), k = 0; !g && o[k]; ) g = o[k] && o[k].dataLabel && (o[k].dataLabel.getBBox().height || 21), 
                k++;
                for (k = 2; k--; ) {
                    var E, o = [], F = [], G = A[k], H = G.length;
                    if (m.sortByAngle(G, k - .5), v > 0) {
                        for (l = y - x - v; l <= y + x + v; l += g) o.push(l);
                        if (e = o.length, H > e) {
                            for (a = [].concat(G), a.sort(D), l = H; l--; ) a[l].rank = l;
                            for (l = H; l--; ) G[l].rank >= e && G.splice(l, 1);
                            H = G.length;
                        }
                        for (l = 0; l < H; l++) {
                            a = G[l], f = a.labelPos, a = 9999;
                            var I, J;
                            for (J = 0; J < e; J++) I = sa(o[J] - f[1]), I < a && (a = I, E = J);
                            if (E < l && null !== o[l]) E = l; else for (e < H - l + E && null !== o[l] && (E = e - H + l); null === o[E]; ) E++;
                            F.push({
                                i: E,
                                y: o[E]
                            }), o[E] = null;
                        }
                        F.sort(D);
                    }
                    for (l = 0; l < H; l++) a = G[l], f = a.labelPos, d = a.dataLabel, j = a.visible === !1 ? "hidden" : "visible", 
                    a = f[1], v > 0 ? (e = F.pop(), E = e.i, i = e.y, (a > i && null !== o[E + 1] || a < i && null !== o[E - 1]) && (i = a)) : i = a, 
                    h = q.justify ? w[0] + (k ? -1 : 1) * (x + v) : m.getX(0 === E || E === o.length - 1 ? a : i, k), 
                    d._attr = {
                        visibility: j,
                        align: f[6]
                    }, d._pos = {
                        x: h + q.x + ({
                            left: r,
                            right: -r
                        }[f[6]] || 0),
                        y: i + q.y - 10
                    }, d.connX = h, d.connY = i, null === this.options.size && (e = d.width, h - e < r ? B[3] = qa(na(e - h + r), B[3]) : h + e > t - r && (B[1] = qa(na(h + e - t + r), B[1])), 
                    i - g / 2 < 0 ? B[0] = qa(na(-i + g / 2), B[0]) : i + g / 2 > p && (B[2] = qa(na(i + g / 2 - p), B[2])));
                }
                (0 === C(B) || this.verifyDataLabelOverflow(B)) && (this.placeDataLabels(), z && s && db(this.points, function(a) {
                    b = a.connector, f = a.labelPos, (d = a.dataLabel) && d._pos ? (j = d._attr.visibility, 
                    h = d.connX, i = d.connY, c = u ? [ "M", h + ("left" === f[6] ? 5 : -5), i, "C", h, i, 2 * f[2] - f[4], 2 * f[3] - f[5], f[2], f[3], "L", f[4], f[5] ] : [ "M", h + ("left" === f[6] ? 5 : -5), i, "L", f[2], f[3], "L", f[4], f[5] ], 
                    b ? (b.animate({
                        d: c
                    }), b.attr("visibility", j)) : a.connector = b = m.chart.renderer.path(c).attr({
                        "stroke-width": s,
                        stroke: q.connectorColor || a.color || "#606060",
                        visibility: j
                    }).add(m.group)) : b && (a.connector = b.destroy());
                }));
            }
        },
        verifyDataLabelOverflow: function(a) {
            var b, c = this.center, d = this.options, e = d.center, f = d = d.minSize || 80;
            return null !== e[0] ? f = qa(c[2] - qa(a[1], a[3]), d) : (f = qa(c[2] - a[1] - a[3], d), 
            c[0] += (a[3] - a[1]) / 2), null !== e[1] ? f = qa(ra(f, c[2] - qa(a[0], a[2])), d) : (f = qa(ra(f, c[2] - a[0] - a[2]), d), 
            c[1] += (a[0] - a[2]) / 2), f < c[2] ? (c[2] = f, this.translate(c), db(this.points, function(a) {
                a.dataLabel && (a.dataLabel._pos = null);
            }), this.drawDataLabels()) : b = !0, b;
        },
        placeDataLabels: function() {
            db(this.points, function(a) {
                var b, a = a.dataLabel;
                a && ((b = a._pos) ? (a.attr(a._attr), a[a.moved ? "animate" : "attr"](b), a.moved = !0) : a && a.attr({
                    y: -999
                }));
            });
        },
        alignDataLabel: La,
        drawTracker: qb.prototype.drawTracker,
        drawLegendSymbol: _a.prototype.drawLegendSymbol,
        getSymbol: La
    }, $a = q(ub, $a), Za.pie = $a, a(Highcharts, {
        Axis: N,
        Chart: R,
        Color: ob,
        Legend: Q,
        Pointer: P,
        Point: tb,
        Tick: K,
        Tooltip: O,
        Renderer: T,
        Series: ub,
        SVGElement: J,
        SVGRenderer: pb,
        arrayMin: B,
        arrayMax: C,
        charts: Ma,
        dateFormat: W,
        format: u,
        pathAnim: Y,
        getOptions: function() {
            return V;
        },
        hasBidiBug: Ga,
        isTouchDevice: Da,
        numberFormat: r,
        seriesTypes: Za,
        setOptions: function(a) {
            return V = b(V, a), I(), V;
        },
        addEvent: hb,
        removeEvent: ib,
        createElement: p,
        discardElement: E,
        css: o,
        each: db,
        extend: a,
        map: gb,
        merge: b,
        pick: n,
        splat: m,
        extendClass: q,
        pInt: c,
        wrap: t,
        svg: Fa,
        canvas: Ha,
        vml: !Fa && !Ha,
        product: "Highcharts",
        version: "3.0.6"
    });
}(), function() {
    function a(a, b) {
        var c;
        a || (a = {});
        for (c in b) a[c] = b[c];
        return a;
    }
    function b() {
        var a, b = arguments.length, c = {}, d = function(a, b) {
            var c, e;
            "object" != typeof a && (a = {});
            for (e in b) b.hasOwnProperty(e) && (c = b[e], c && "object" == typeof c && "[object Array]" !== Object.prototype.toString.call(c) && "number" != typeof c.nodeType ? a[e] = d(a[e] || {}, c) : a[e] = b[e]);
            return a;
        };
        for (a = 0; a < b; a++) c = d(c, arguments[a]);
        return c;
    }
    function c() {
        for (var a = 0, b = arguments, c = b.length, d = {}; a < c; a++) d[b[a++]] = b[a];
        return d;
    }
    function d(a, b) {
        return parseInt(a, b || 10);
    }
    function e(a) {
        return "string" == typeof a;
    }
    function f(a) {
        return "object" == typeof a;
    }
    function g(a) {
        return "[object Array]" === Object.prototype.toString.call(a);
    }
    function h(a) {
        return "number" == typeof a;
    }
    function i(a) {
        return qa.log(a) / qa.LN10;
    }
    function j(a) {
        return qa.pow(10, a);
    }
    function k(a, b) {
        for (var c = a.length; c--; ) if (a[c] === b) {
            a.splice(c, 1);
            break;
        }
    }
    function l(a) {
        return a !== W && null !== a;
    }
    function m(a, b, c) {
        var d, g, h = "setAttribute";
        if (e(b)) l(c) ? a[h](b, c) : a && a.getAttribute && (g = a.getAttribute(b)); else if (l(b) && f(b)) for (d in b) a[h](d, b[d]);
        return g;
    }
    function n(a) {
        return g(a) ? a : [ a ];
    }
    function o() {
        var a, b, c = arguments, d = c.length;
        for (a = 0; a < d; a++) if (b = c[a], "undefined" != typeof b && null !== b) return b;
    }
    function p(b, c) {
        Da && c && c.opacity !== W && (c.filter = "alpha(opacity=" + 100 * c.opacity + ")"), 
        a(b.style, c);
    }
    function q(b, c, d, e, f) {
        var g = oa.createElement(b);
        return c && a(g, c), f && p(g, {
            padding: 0,
            border: $a,
            margin: 0
        }), d && p(g, d), e && e.appendChild(g), g;
    }
    function r(b, c) {
        var d = function() {};
        return d.prototype = new b(), a(d.prototype, c), d;
    }
    function s(a, b, c, e) {
        var f = Z.lang, g = +a || 0, h = b === -1 ? (g.toString().split(".")[1] || "").length : isNaN(b = wa(b)) ? 2 : b, i = void 0 === c ? f.decimalPoint : c, j = void 0 === e ? f.thousandsSep : e, k = g < 0 ? "-" : "", l = String(d(g = wa(g).toFixed(h))), m = l.length > 3 ? l.length % 3 : 0;
        return k + (m ? l.substr(0, m) + j : "") + l.substr(m).replace(/(\d{3})(?=\d)/g, "$1" + j) + (h ? i + wa(g - l).toFixed(h).slice(2) : "");
    }
    function t(a, b) {
        return new Array((b || 2) + 1 - String(a).length).join(0) + a;
    }
    function u(a, b, c) {
        var d = a[b];
        a[b] = function() {
            var a = Array.prototype.slice.call(arguments);
            return a.unshift(d), c.apply(this, a);
        };
    }
    function v(a, b) {
        var c, d = /f$/, e = /\.([0-9])/, f = Z.lang;
        return d.test(a) ? (c = a.match(e), c = c ? c[1] : -1, b = s(b, c, f.decimalPoint, a.indexOf(",") > -1 ? f.thousandsSep : "")) : b = $(a, b), 
        b;
    }
    function w(a, b) {
        for (var c, d, e, f, g, h, i, j = "{", k = !1, l = []; (i = a.indexOf(j)) !== -1; ) {
            if (c = a.slice(0, i), k) {
                for (d = c.split(":"), e = d.shift().split("."), g = e.length, h = b, f = 0; f < g; f++) h = h[e[f]];
                d.length && (h = v(d.join(":"), h)), l.push(h);
            } else l.push(c);
            a = a.slice(i + 1), k = !k, j = k ? "}" : "{";
        }
        return l.push(a), l.join("");
    }
    function x(a) {
        return qa.pow(10, sa(qa.log(a) / qa.LN10));
    }
    function y(a, b, c, d) {
        var e, f;
        for (c = o(c, 1), e = a / c, b || (b = [ 1, 2, 2.5, 5, 10 ], d && d.allowDecimals === !1 && (1 === c ? b = [ 1, 2, 5, 10 ] : c <= .1 && (b = [ 1 / c ]))), 
        f = 0; f < b.length && (a = b[f], !(e <= (b[f] + (b[f + 1] || b[f])) / 2)); f++) ;
        return a *= c;
    }
    function z(a, b) {
        var c, d, e = b || [ [ fb, [ 1, 2, 5, 10, 20, 25, 50, 100, 200, 500 ] ], [ gb, [ 1, 2, 5, 10, 15, 30 ] ], [ hb, [ 1, 2, 5, 10, 15, 30 ] ], [ ib, [ 1, 2, 3, 4, 6, 8, 12 ] ], [ jb, [ 1, 2 ] ], [ kb, [ 1, 2 ] ], [ lb, [ 1, 2, 3, 4, 6 ] ], [ mb, null ] ], f = e[e.length - 1], g = ba[f[0]], h = f[1];
        for (d = 0; d < e.length; d++) if (f = e[d], g = ba[f[0]], h = f[1], e[d + 1]) {
            var i = (g * h[h.length - 1] + ba[e[d + 1][0]]) / 2;
            if (a <= i) break;
        }
        return g === ba[mb] && a < 5 * g && (h = [ 1, 2, 5 ]), c = y(a / g, h, f[0] === mb ? x(a / g) : 1), 
        {
            unitRange: g,
            count: c,
            unitName: f[0]
        };
    }
    function A(b, c, d, e) {
        var f, g, h = [], i = {}, j = Z.global.useUTC, k = new Date(c), m = b.unitRange, n = b.count;
        if (l(c)) {
            m >= ba[gb] && (k.setMilliseconds(0), k.setSeconds(m >= ba[hb] ? 0 : n * sa(k.getSeconds() / n))), 
            m >= ba[hb] && k[ja](m >= ba[ib] ? 0 : n * sa(k[da]() / n)), m >= ba[ib] && k[ka](m >= ba[jb] ? 0 : n * sa(k[ea]() / n)), 
            m >= ba[jb] && k[la](m >= ba[lb] ? 1 : n * sa(k[ga]() / n)), m >= ba[lb] && (k[ma](m >= ba[mb] ? 0 : n * sa(k[ha]() / n)), 
            g = k[ia]()), m >= ba[mb] && (g -= g % n, k[na](g)), m === ba[kb] && k[la](k[ga]() - k[fa]() + o(e, 1)), 
            f = 1, g = k[ia]();
            for (var p = k.getTime(), q = k[ha](), r = k[ga](), s = j ? 0 : (864e5 + 60 * k.getTimezoneOffset() * 1e3) % 864e5; p < d; ) h.push(p), 
            m === ba[mb] ? p = ca(g + f * n, 0) : m === ba[lb] ? p = ca(g, q + f * n) : j || m !== ba[jb] && m !== ba[kb] ? p += m * n : p = ca(g, q, r + f * n * (m === ba[jb] ? 1 : 7)), 
            f++;
            h.push(p), ub(vb(h, function(a) {
                return m <= ba[ib] && a % ba[jb] === s;
            }), function(a) {
                i[a] = jb;
            });
        }
        return h.info = a(b, {
            higherRanks: i,
            totalRange: m * n
        }), h;
    }
    function B() {
        this.color = 0, this.symbol = 0;
    }
    function C(a, b) {
        var c, d, e = a.length;
        for (d = 0; d < e; d++) a[d].ss_i = d;
        for (a.sort(function(a, d) {
            return c = b(a, d), 0 === c ? a.ss_i - d.ss_i : c;
        }), d = 0; d < e; d++) delete a[d].ss_i;
    }
    function D(a) {
        for (var b = a.length, c = a[0]; b--; ) a[b] < c && (c = a[b]);
        return c;
    }
    function E(a) {
        for (var b = a.length, c = a[0]; b--; ) a[b] > c && (c = a[b]);
        return c;
    }
    function F(a, b) {
        var c;
        for (c in a) a[c] && a[c] !== b && a[c].destroy && a[c].destroy(), delete a[c];
    }
    function G(a) {
        Y || (Y = q(Ta)), a && Y.appendChild(a), Y.innerHTML = "";
    }
    function H(a, b) {
        var c = "Highcharts error #" + a + ": www.highcharts.com/errors/" + a;
        if (b) throw c;
        pa.console && console.log(c);
    }
    function I(a) {
        return parseFloat(a.toPrecision(14));
    }
    function J(a, b) {
        _ = o(a, b.animation);
    }
    function K() {
        var a = Z.global.useUTC, b = a ? "getUTC" : "get", c = a ? "setUTC" : "set";
        ca = a ? Date.UTC : function(a, b, c, d, e, f) {
            return new Date(a, b, o(c, 1), o(d, 0), o(e, 0), o(f, 0)).getTime();
        }, da = b + "Minutes", ea = b + "Hours", fa = b + "Day", ga = b + "Date", ha = b + "Month", 
        ia = b + "FullYear", ja = c + "Minutes", ka = c + "Hours", la = c + "Date", ma = c + "Month", 
        na = c + "FullYear";
    }
    function L(a) {
        return Z = b(Z, a), K(), Z;
    }
    function M() {
        return Z;
    }
    function N() {}
    function O(a, b, c, d) {
        this.axis = a, this.pos = b, this.type = c || "", this.isNew = !0, c || d || this.addLabel();
    }
    function P(a, b) {
        this.axis = a, b && (this.options = b, this.id = b.id);
    }
    function Q(a, b, c, d, e, f) {
        var g = a.chart.inverted;
        this.axis = a, this.isNegative = c, this.options = b, this.x = d, this.total = null, 
        this.points = {}, this.stack = e, this.percent = "percent" === f, this.alignOptions = {
            align: b.align || (g ? c ? "left" : "right" : "center"),
            verticalAlign: b.verticalAlign || (g ? "middle" : c ? "bottom" : "top"),
            y: o(b.y, g ? 4 : c ? 14 : -6),
            x: o(b.x, g ? c ? -6 : 6 : 0)
        }, this.textAlign = b.textAlign || (g ? c ? "right" : "left" : "center");
    }
    function R() {
        this.init.apply(this, arguments);
    }
    function S() {
        this.init.apply(this, arguments);
    }
    function T(a, b) {
        this.init(a, b);
    }
    function U(a, b) {
        this.init(a, b);
    }
    function V() {
        this.init.apply(this, arguments);
    }
    var W, X, Y, Z, $, _, aa, ba, ca, da, ea, fa, ga, ha, ia, ja, ka, la, ma, na, oa = document, pa = window, qa = Math, ra = qa.round, sa = qa.floor, ta = qa.ceil, ua = qa.max, va = qa.min, wa = qa.abs, xa = qa.cos, ya = qa.sin, za = qa.PI, Aa = 2 * za / 360, Ba = navigator.userAgent, Ca = pa.opera, Da = /msie/i.test(Ba) && !Ca, Ea = 8 === oa.documentMode, Fa = /AppleWebKit/.test(Ba), Ga = /Firefox/.test(Ba), Ha = /(Mobile|Android|Windows Phone)/.test(Ba), Ia = "http://www.w3.org/2000/svg", Ja = !!oa.createElementNS && !!oa.createElementNS(Ia, "svg").createSVGRect, Ka = Ga && parseInt(Ba.split("Firefox/")[1], 10) < 4, La = !Ja && !Da && !!oa.createElement("canvas").getContext, Ma = oa.documentElement.ontouchstart !== W, Na = {}, Oa = 0, Pa = function() {}, Qa = [], Ra = "Highcharts", Sa = "3.0.6", Ta = "div", Ua = "absolute", Va = "relative", Wa = "hidden", Xa = "highcharts-", Ya = "visible", Za = "px", $a = "none", _a = "M", ab = "L", bb = "rgba(192,192,192," + (Ja ? 1e-4 : .002) + ")", cb = "", db = "hover", eb = "select", fb = "millisecond", gb = "second", hb = "minute", ib = "hour", jb = "day", kb = "week", lb = "month", mb = "year", nb = "stroke-width", ob = {};
    pa.Highcharts = pa.Highcharts ? H(16, !0) : {}, $ = function(b, c, d) {
        if (!l(c) || isNaN(c)) return "Invalid date";
        b = o(b, "%Y-%m-%d %H:%M:%S");
        var e, f = new Date(c), g = f[ea](), h = f[fa](), i = f[ga](), j = f[ha](), k = f[ia](), m = Z.lang, n = m.weekdays, p = a({
            a: n[h].substr(0, 3),
            A: n[h],
            d: t(i),
            e: i,
            b: m.shortMonths[j],
            B: m.months[j],
            m: t(j + 1),
            y: k.toString().substr(2, 2),
            Y: k,
            H: t(g),
            I: t(g % 12 || 12),
            l: g % 12 || 12,
            M: t(f[da]()),
            p: g < 12 ? "AM" : "PM",
            P: g < 12 ? "am" : "pm",
            S: t(f.getSeconds()),
            L: t(ra(c % 1e3), 3)
        }, Highcharts.dateFormats);
        for (e in p) for (;b.indexOf("%" + e) !== -1; ) b = b.replace("%" + e, "function" == typeof p[e] ? p[e](c) : p[e]);
        return d ? b.substr(0, 1).toUpperCase() + b.substr(1) : b;
    }, B.prototype = {
        wrapColor: function(a) {
            this.color >= a && (this.color = 0);
        },
        wrapSymbol: function(a) {
            this.symbol >= a && (this.symbol = 0);
        }
    }, ba = c(fb, 1, gb, 1e3, hb, 6e4, ib, 36e5, jb, 864e5, kb, 6048e5, lb, 26784e5, mb, 31556952e3), 
    aa = {
        init: function(a, b, c) {
            b = b || "";
            var d, e, f, g, h, i = a.shift, j = b.indexOf("C") > -1, k = j ? 7 : 3, l = b.split(" "), m = [].concat(c), n = function(a) {
                for (f = a.length; f--; ) a[f] === _a && a.splice(f + 1, 0, a[f + 1], a[f + 2], a[f + 1], a[f + 2]);
            };
            if (j && (n(l), n(m)), a.isArea && (g = l.splice(l.length - 6, 6), h = m.splice(m.length - 6, 6)), 
            i <= m.length / k && l.length === m.length) for (;i--; ) m = [].concat(m).splice(0, k).concat(m);
            if (a.shift = 0, l.length) for (d = m.length; l.length < d; ) e = [].concat(l).splice(l.length - k, k), 
            j && (e[k - 6] = e[k - 2], e[k - 5] = e[k - 1]), l = l.concat(e);
            return g && (l = l.concat(g), m = m.concat(h)), [ l, m ];
        },
        step: function(a, b, c, d) {
            var e, f = [], g = a.length;
            if (1 === c) f = d; else if (g === b.length && c < 1) for (;g--; ) e = parseFloat(a[g]), 
            f[g] = isNaN(e) ? a[g] : c * parseFloat(b[g] - e) + e; else f = b;
            return f;
        }
    }, function(b) {
        pa.HighchartsAdapter = pa.HighchartsAdapter || b && {
            init: function(a) {
                var c, d = b.fx, f = d.step, g = b.Tween, h = g && g.propHooks, i = b.cssHooks.opacity;
                b.extend(b.easing, {
                    easeOutQuad: function(a, b, c, d, e) {
                        return -d * (b /= e) * (b - 2) + c;
                    }
                }), b.each([ "cur", "_default", "width", "height", "opacity" ], function(a, b) {
                    var c, e, i = f;
                    "cur" === b ? i = d.prototype : "_default" === b && g && (i = h[b], b = "set"), 
                    c = i[b], c && (i[b] = function(d) {
                        if (d = a ? d : this, "align" !== d.prop) return e = d.elem, e.attr ? e.attr(d.prop, "cur" === b ? W : d.now) : c.apply(this, arguments);
                    });
                }), u(i, "get", function(a, b, c) {
                    return b.attr ? b.opacity || 0 : a.call(this, b, c);
                }), c = function(b) {
                    var c, d = b.elem;
                    b.started || (c = a.init(d, d.d, d.toD), b.start = c[0], b.end = c[1], b.started = !0), 
                    d.attr("d", a.step(b.start, b.end, b.pos, d.toD));
                }, g ? h.d = {
                    set: c
                } : f.d = c, this.each = Array.prototype.forEach ? function(a, b) {
                    return Array.prototype.forEach.call(a, b);
                } : function(a, b) {
                    for (var c = 0, d = a.length; c < d; c++) if (b.call(a[c], a[c], c, a) === !1) return c;
                }, b.fn.highcharts = function() {
                    var a, b, c, d = "Chart", f = arguments;
                    return e(f[0]) && (d = f[0], f = Array.prototype.slice.call(f, 1)), a = f[0], a !== W && (a.chart = a.chart || {}, 
                    a.chart.renderTo = this[0], c = new Highcharts[d](a, f[1]), b = this), a === W && (b = Qa[m(this[0], "data-highcharts-chart")]), 
                    b;
                };
            },
            getScript: b.getScript,
            inArray: b.inArray,
            adapterRun: function(a, c) {
                return b(a)[c]();
            },
            grep: b.grep,
            map: function(a, b) {
                for (var c = [], d = 0, e = a.length; d < e; d++) c[d] = b.call(a[d], a[d], d, a);
                return c;
            },
            offset: function(a) {
                return b(a).offset();
            },
            addEvent: function(a, c, d) {
                b(a).bind(c, d);
            },
            removeEvent: function(a, c, d) {
                var e = oa.removeEventListener ? "removeEventListener" : "detachEvent";
                oa[e] && a && !a[e] && (a[e] = function() {}), b(a).unbind(c, d);
            },
            fireEvent: function(c, d, e, f) {
                var g, h = b.Event(d), i = "detached" + d;
                !Da && e && (delete e.layerX, delete e.layerY), a(h, e), c[d] && (c[i] = c[d], c[d] = null), 
                b.each([ "preventDefault", "stopPropagation" ], function(a, b) {
                    var c = h[b];
                    h[b] = function() {
                        try {
                            c.call(h);
                        } catch (a) {
                            "preventDefault" === b && (g = !0);
                        }
                    };
                }), b(c).trigger(h), c[i] && (c[d] = c[i], c[i] = null), !f || h.isDefaultPrevented() || g || f(h);
            },
            washMouseEvent: function(a) {
                var b = a.originalEvent || a;
                return b.pageX === W && (b.pageX = a.pageX, b.pageY = a.pageY), b;
            },
            animate: function(a, c, d) {
                var e = b(a);
                a.style || (a.style = {}), c.d && (a.toD = c.d, c.d = 1), e.stop(), c.opacity !== W && a.attr && (c.opacity += "px"), 
                e.animate(c, d);
            },
            stop: function(a) {
                b(a).stop();
            }
        };
    }(pa.jQuery);
    var pb = pa.HighchartsAdapter, qb = pb || {};
    pb && pb.init.call(pb, aa);
    var rb = qb.adapterRun, sb = qb.getScript, tb = qb.inArray, ub = qb.each, vb = qb.grep, wb = qb.offset, xb = qb.map, yb = qb.addEvent, zb = qb.removeEvent, Ab = qb.fireEvent, Bb = qb.washMouseEvent, Cb = qb.animate, Db = qb.stop, Eb = {
        enabled: !0,
        x: 0,
        y: 15,
        style: {
            color: "#666",
            cursor: "default",
            fontSize: "11px",
            lineHeight: "14px"
        }
    };
    Z = {
        colors: [ "#2f7ed8", "#0d233a", "#8bbc21", "#910000", "#1aadce", "#492970", "#f28f43", "#77a1e5", "#c42525", "#a6c96a" ],
        symbols: [ "circle", "diamond", "square", "triangle", "triangle-down" ],
        lang: {
            loading: "Loading...",
            months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
            shortMonths: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
            weekdays: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
            decimalPoint: ".",
            numericSymbols: [ "k", "M", "G", "T", "P", "E" ],
            resetZoom: "Reset zoom",
            resetZoomTitle: "Reset zoom level 1:1",
            thousandsSep: ","
        },
        global: {
            useUTC: !0,
            canvasToolsURL: "http://code.highcharts.com/3.0.6/modules/canvas-tools.js",
            VMLRadialGradientURL: "http://code.highcharts.com/3.0.6/gfx/vml-radial-gradient.png"
        },
        chart: {
            borderColor: "#4572A7",
            borderRadius: 5,
            defaultSeriesType: "line",
            ignoreHiddenSeries: !0,
            spacing: [ 10, 10, 15, 10 ],
            style: {
                fontFamily: '"Lucida Grande", "Lucida Sans Unicode", Verdana, Arial, Helvetica, sans-serif',
                fontSize: "12px"
            },
            backgroundColor: "#FFFFFF",
            plotBorderColor: "#C0C0C0",
            resetZoomButton: {
                theme: {
                    zIndex: 20
                },
                position: {
                    align: "right",
                    x: -10,
                    y: 10
                }
            }
        },
        title: {
            text: "Chart title",
            align: "center",
            margin: 15,
            style: {
                color: "#274b6d",
                fontSize: "16px"
            }
        },
        subtitle: {
            text: "",
            align: "center",
            style: {
                color: "#4d759e"
            }
        },
        plotOptions: {
            line: {
                allowPointSelect: !1,
                showCheckbox: !1,
                animation: {
                    duration: 1e3
                },
                events: {},
                lineWidth: 2,
                marker: {
                    enabled: !0,
                    lineWidth: 0,
                    radius: 4,
                    lineColor: "#FFFFFF",
                    states: {
                        hover: {
                            enabled: !0
                        },
                        select: {
                            fillColor: "#FFFFFF",
                            lineColor: "#000000",
                            lineWidth: 2
                        }
                    }
                },
                point: {
                    events: {}
                },
                dataLabels: b(Eb, {
                    align: "center",
                    enabled: !1,
                    formatter: function() {
                        return null === this.y ? "" : s(this.y, -1);
                    },
                    verticalAlign: "bottom",
                    y: 0
                }),
                cropThreshold: 300,
                pointRange: 0,
                showInLegend: !0,
                states: {
                    hover: {
                        marker: {}
                    },
                    select: {
                        marker: {}
                    }
                },
                stickyTracking: !0
            }
        },
        labels: {
            style: {
                position: Ua,
                color: "#3E576F"
            }
        },
        legend: {
            enabled: !0,
            align: "center",
            layout: "horizontal",
            labelFormatter: function() {
                return this.name;
            },
            borderWidth: 1,
            borderColor: "#909090",
            borderRadius: 5,
            navigation: {
                activeColor: "#274b6d",
                inactiveColor: "#CCC"
            },
            shadow: !1,
            itemStyle: {
                cursor: "pointer",
                color: "#274b6d",
                fontSize: "12px"
            },
            itemHoverStyle: {
                color: "#000"
            },
            itemHiddenStyle: {
                color: "#CCC"
            },
            itemCheckboxStyle: {
                position: Ua,
                width: "13px",
                height: "13px"
            },
            symbolWidth: 16,
            symbolPadding: 5,
            verticalAlign: "bottom",
            x: 0,
            y: 0,
            title: {
                style: {
                    fontWeight: "bold"
                }
            }
        },
        loading: {
            labelStyle: {
                fontWeight: "bold",
                position: Va,
                top: "1em"
            },
            style: {
                position: Ua,
                backgroundColor: "white",
                opacity: .5,
                textAlign: "center"
            }
        },
        tooltip: {
            enabled: !0,
            animation: Ja,
            backgroundColor: "rgba(255, 255, 255, .85)",
            borderWidth: 1,
            borderRadius: 3,
            dateTimeLabelFormats: {
                millisecond: "%A, %b %e, %H:%M:%S.%L",
                second: "%A, %b %e, %H:%M:%S",
                minute: "%A, %b %e, %H:%M",
                hour: "%A, %b %e, %H:%M",
                day: "%A, %b %e, %Y",
                week: "Week from %A, %b %e, %Y",
                month: "%B %Y",
                year: "%Y"
            },
            headerFormat: '<span style="font-size: 10px">{point.key}</span><br/>',
            pointFormat: '<span style="color:{series.color}">{series.name}</span>: <b>{point.y}</b><br/>',
            shadow: !0,
            snap: Ha ? 25 : 10,
            style: {
                color: "#333333",
                cursor: "default",
                fontSize: "12px",
                padding: "8px",
                whiteSpace: "nowrap"
            }
        },
        credits: {
            enabled: !0,
            text: "Highcharts.com",
            href: "http://www.highcharts.com",
            position: {
                align: "right",
                x: -10,
                verticalAlign: "bottom",
                y: -5
            },
            style: {
                cursor: "pointer",
                color: "#909090",
                fontSize: "9px"
            }
        }
    };
    var Fb = Z.plotOptions, Gb = Fb.line;
    K();
    var Hb = function(a) {
        function c(a) {
            a && a.stops ? j = xb(a.stops, function(a) {
                return Hb(a[1]);
            }) : (i = /rgba\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]?(?:\.[0-9]+)?)\s*\)/.exec(a), 
            i ? k = [ d(i[1]), d(i[2]), d(i[3]), parseFloat(i[4], 10) ] : (i = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(a), 
            i ? k = [ d(i[1], 16), d(i[2], 16), d(i[3], 16), 1 ] : (i = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(a), 
            i && (k = [ d(i[1]), d(i[2]), d(i[3]), 1 ]))));
        }
        function e(c) {
            var d;
            return j ? (d = b(a), d.stops = [].concat(d.stops), ub(j, function(a, b) {
                d.stops[b] = [ d.stops[b][0], a.get(c) ];
            })) : d = k && !isNaN(k[0]) ? "rgb" === c ? "rgb(" + k[0] + "," + k[1] + "," + k[2] + ")" : "a" === c ? k[3] : "rgba(" + k.join(",") + ")" : a, 
            d;
        }
        function f(a) {
            if (j) ub(j, function(b) {
                b.brighten(a);
            }); else if (h(a) && 0 !== a) {
                var b;
                for (b = 0; b < 3; b++) k[b] += d(255 * a), k[b] < 0 && (k[b] = 0), k[b] > 255 && (k[b] = 255);
            }
            return this;
        }
        function g(a) {
            return k[3] = a, this;
        }
        var i, j, k = [];
        return c(a), {
            get: e,
            brighten: f,
            rgba: k,
            setOpacity: g
        };
    };
    N.prototype = {
        init: function(a, b) {
            var c = this;
            c.element = "span" === b ? q(b) : oa.createElementNS(Ia, b), c.renderer = a, c.attrSetters = {};
        },
        opacity: 1,
        animate: function(a, c, d) {
            var e = o(c, _, !0);
            Db(this), e ? (e = b(e), d && (e.complete = d), Cb(this, a, e)) : (this.attr(a), 
            d && d());
        },
        attr: function(a, b) {
            var c, f, g, h, i, j, k, n, p, q = this, r = q.element, s = r.nodeName.toLowerCase(), t = q.renderer, u = q.attrSetters, v = q.shadows, w = q;
            if (e(a) && l(b) && (c = a, a = {}, a[c] = b), e(a)) c = a, "circle" === s ? c = {
                x: "cx",
                y: "cy"
            }[c] || c : "strokeWidth" === c && (c = "stroke-width"), w = m(r, c) || q[c] || 0, 
            "d" !== c && "visibility" !== c && "fill" !== c && (w = parseFloat(w)); else {
                for (c in a) if (j = !1, f = a[c], g = u[c] && u[c].call(q, f, c), g !== !1) {
                    if (g !== W && (f = g), "d" === c) f && f.join && (f = f.join(" ")), /(NaN| {2}|^$)/.test(f) && (f = "M 0 0"); else if ("x" === c && "text" === s) for (h = 0; h < r.childNodes.length; h++) i = r.childNodes[h], 
                    m(i, "x") === m(r, "x") && m(i, "x", f); else if (!q.rotation || "x" !== c && "y" !== c) if ("fill" === c) f = t.color(f, r, c); else if ("circle" !== s || "x" !== c && "y" !== c) if ("rect" === s && "r" === c) m(r, {
                        rx: f,
                        ry: f
                    }), j = !0; else if ("translateX" === c || "translateY" === c || "rotation" === c || "verticalAlign" === c || "scaleX" === c || "scaleY" === c) p = !0, 
                    j = !0; else if ("stroke" === c) f = t.color(f, r, c); else if ("dashstyle" === c) {
                        if (c = "stroke-dasharray", f = f && f.toLowerCase(), "solid" === f) f = $a; else if (f) {
                            for (f = f.replace("shortdashdotdot", "3,1,1,1,1,1,").replace("shortdashdot", "3,1,1,1").replace("shortdot", "1,1,").replace("shortdash", "3,1,").replace("longdash", "8,3,").replace(/dot/g, "1,3,").replace("dash", "4,3,").replace(/,$/, "").split(","), 
                            h = f.length; h--; ) f[h] = d(f[h]) * o(a["stroke-width"], q["stroke-width"]);
                            f = f.join(",");
                        }
                    } else "width" === c ? f = d(f) : "align" === c ? (c = "text-anchor", f = {
                        left: "start",
                        center: "middle",
                        right: "end"
                    }[f]) : "title" === c && (k = r.getElementsByTagName("title")[0], k || (k = oa.createElementNS(Ia, "title"), 
                    r.appendChild(k)), k.textContent = f); else c = {
                        x: "cx",
                        y: "cy"
                    }[c] || c; else p = !0;
                    if ("strokeWidth" === c && (c = "stroke-width"), "stroke-width" !== c && "stroke" !== c || (q[c] = f, 
                    q.stroke && q["stroke-width"] ? (m(r, "stroke", q.stroke), m(r, "stroke-width", q["stroke-width"]), 
                    q.hasStroke = !0) : "stroke-width" === c && 0 === f && q.hasStroke && (r.removeAttribute("stroke"), 
                    q.hasStroke = !1), j = !0), q.symbolName && /^(x|y|width|height|r|start|end|innerR|anchorX|anchorY)/.test(c) && (n || (q.symbolAttr(a), 
                    n = !0), j = !0), v && /^(width|height|visibility|x|y|d|transform|cx|cy|r)$/.test(c)) for (h = v.length; h--; ) m(v[h], c, "height" === c ? ua(f - (v[h].cutHeight || 0), 0) : f);
                    ("width" === c || "height" === c) && "rect" === s && f < 0 && (f = 0), q[c] = f, 
                    "text" === c ? (f !== q.textStr && delete q.bBox, q.textStr = f, q.added && t.buildText(q)) : j || m(r, c, f);
                }
                p && q.updateTransform();
            }
            return w;
        },
        addClass: function(a) {
            var b = this.element, c = m(b, "class") || "";
            return c.indexOf(a) === -1 && m(b, "class", c + " " + a), this;
        },
        symbolAttr: function(a) {
            var b = this;
            ub([ "x", "y", "r", "start", "end", "width", "height", "innerR", "anchorX", "anchorY" ], function(c) {
                b[c] = o(a[c], b[c]);
            }), b.attr({
                d: b.renderer.symbols[b.symbolName](b.x, b.y, b.width, b.height, b)
            });
        },
        clip: function(a) {
            return this.attr("clip-path", a ? "url(" + this.renderer.url + "#" + a.id + ")" : $a);
        },
        crisp: function(a, b, c, d, e) {
            var f, g, h = this, i = {}, j = {};
            a = a || h.strokeWidth || h.attr && h.attr("stroke-width") || 0, g = ra(a) % 2 / 2, 
            j.x = sa(b || h.x || 0) + g, j.y = sa(c || h.y || 0) + g, j.width = sa((d || h.width || 0) - 2 * g), 
            j.height = sa((e || h.height || 0) - 2 * g), j.strokeWidth = a;
            for (f in j) h[f] !== j[f] && (h[f] = i[f] = j[f]);
            return i;
        },
        css: function(b) {
            var c, d = this, e = d.element, f = b && b.width && "text" === e.nodeName.toLowerCase(), g = "", h = function(a, b) {
                return "-" + b.toLowerCase();
            };
            if (b && b.color && (b.fill = b.color), b = a(d.styles, b), d.styles = b, La && f && delete b.width, 
            Da && !Ja) f && delete b.width, p(d.element, b); else {
                for (c in b) g += c.replace(/([A-Z])/g, h) + ":" + b[c] + ";";
                m(e, "style", g);
            }
            return f && d.added && d.renderer.buildText(d), d;
        },
        on: function(a, b) {
            var c = this, d = c.element;
            return Ma && "click" === a ? (d.ontouchstart = function(a) {
                c.touchEventFired = Date.now(), a.preventDefault(), b.call(d, a);
            }, d.onclick = function(a) {
                (Ba.indexOf("Android") === -1 || Date.now() - (c.touchEventFired || 0) > 1100) && b.call(d, a);
            }) : d["on" + a] = b, this;
        },
        setRadialReference: function(a) {
            return this.element.radialReference = a, this;
        },
        translate: function(a, b) {
            return this.attr({
                translateX: a,
                translateY: b
            });
        },
        invert: function() {
            var a = this;
            return a.inverted = !0, a.updateTransform(), a;
        },
        htmlCss: function(b) {
            var c = this, d = c.element, e = b && "SPAN" === d.tagName && b.width;
            return e && (delete b.width, c.textWidth = e, c.updateTransform()), c.styles = a(c.styles, b), 
            p(c.element, b), c;
        },
        htmlGetBBox: function() {
            var a = this, b = a.element, c = a.bBox;
            return c || ("text" === b.nodeName && (b.style.position = Ua), c = a.bBox = {
                x: b.offsetLeft,
                y: b.offsetTop,
                width: b.offsetWidth,
                height: b.offsetHeight
            }), c;
        },
        htmlUpdateTransform: function() {
            if (!this.added) return void (this.alignOnAdd = !0);
            var a = this, b = a.renderer, c = a.element, e = a.translateX || 0, f = a.translateY || 0, g = a.x || 0, h = a.y || 0, i = a.textAlign || "left", j = {
                left: 0,
                center: .5,
                right: 1
            }[i], k = i && "left" !== i, m = a.shadows;
            if (p(c, {
                marginLeft: e,
                marginTop: f
            }), m && ub(m, function(a) {
                p(a, {
                    marginLeft: e + 1,
                    marginTop: f + 1
                });
            }), a.inverted && ub(c.childNodes, function(a) {
                b.invertChild(a, c);
            }), "SPAN" === c.tagName) {
                var n, q, r, s, t = a.rotation, u = 0, v = 1, w = 0, x = d(a.textWidth), y = a.xCorr || 0, z = a.yCorr || 0, A = [ t, i, c.innerHTML, a.textWidth ].join(",");
                A !== a.cTT && (l(t) && (u = t * Aa, v = xa(u), w = ya(u), a.setSpanRotation(t, w, v)), 
                n = o(a.elemWidth, c.offsetWidth), q = o(a.elemHeight, c.offsetHeight), n > x && /[ \-]/.test(c.textContent || c.innerText) && (p(c, {
                    width: x + Za,
                    display: "block",
                    whiteSpace: "normal"
                }), n = x), r = b.fontMetrics(c.style.fontSize).b, y = v < 0 && -n, z = w < 0 && -q, 
                s = v * w < 0, y += w * r * (s ? 1 - j : j), z -= v * r * (t ? s ? j : 1 - j : 1), 
                k && (y -= n * j * (v < 0 ? -1 : 1), t && (z -= q * j * (w < 0 ? -1 : 1)), p(c, {
                    textAlign: i
                })), a.xCorr = y, a.yCorr = z), p(c, {
                    left: g + y + Za,
                    top: h + z + Za
                }), Fa && (q = c.offsetHeight), a.cTT = A;
            }
        },
        setSpanRotation: function(a) {
            var b = {}, c = Da ? "-ms-transform" : Fa ? "-webkit-transform" : Ga ? "MozTransform" : Ca ? "-o-transform" : "";
            b[c] = b.transform = "rotate(" + a + "deg)", p(this.element, b);
        },
        updateTransform: function() {
            var a, b = this, c = b.translateX || 0, d = b.translateY || 0, e = b.scaleX, f = b.scaleY, g = b.inverted, h = b.rotation;
            g && (c += b.attr("width"), d += b.attr("height")), a = [ "translate(" + c + "," + d + ")" ], 
            g ? a.push("rotate(90) scale(-1,1)") : h && a.push("rotate(" + h + " " + (b.x || 0) + " " + (b.y || 0) + ")"), 
            (l(e) || l(f)) && a.push("scale(" + o(e, 1) + " " + o(f, 1) + ")"), a.length && m(b.element, "transform", a.join(" "));
        },
        toFront: function() {
            var a = this.element;
            return a.parentNode.appendChild(a), this;
        },
        align: function(a, b, c) {
            var d, f, g, h, i, j = {}, l = this.renderer, m = l.alignedObjects;
            return a ? (this.alignOptions = a, this.alignByTranslate = b, c && !e(c) || (this.alignTo = i = c || "renderer", 
            k(m, this), m.push(this), c = null)) : (a = this.alignOptions, b = this.alignByTranslate, 
            i = this.alignTo), c = o(c, l[i], l), d = a.align, f = a.verticalAlign, g = (c.x || 0) + (a.x || 0), 
            h = (c.y || 0) + (a.y || 0), "right" !== d && "center" !== d || (g += (c.width - (a.width || 0)) / {
                right: 1,
                center: 2
            }[d]), j[b ? "translateX" : "x"] = ra(g), "bottom" !== f && "middle" !== f || (h += (c.height - (a.height || 0)) / ({
                bottom: 1,
                middle: 2
            }[f] || 1)), j[b ? "translateY" : "y"] = ra(h), this[this.placed ? "animate" : "attr"](j), 
            this.placed = !0, this.alignAttr = j, this;
        },
        getBBox: function() {
            var b, c, d = this, e = d.bBox, f = d.renderer, g = d.rotation, h = d.element, i = d.styles, j = g * Aa;
            if (!e) {
                if (h.namespaceURI === Ia || f.forExport) {
                    try {
                        e = h.getBBox ? a({}, h.getBBox()) : {
                            width: h.offsetWidth,
                            height: h.offsetHeight
                        };
                    } catch (k) {}
                    (!e || e.width < 0) && (e = {
                        width: 0,
                        height: 0
                    });
                } else e = d.htmlGetBBox();
                f.isSVG && (b = e.width, c = e.height, Da && i && "11px" === i.fontSize && "22.7" === c.toPrecision(3) && (e.height = c = 14), 
                g && (e.width = wa(c * ya(j)) + wa(b * xa(j)), e.height = wa(c * xa(j)) + wa(b * ya(j)))), 
                d.bBox = e;
            }
            return e;
        },
        show: function() {
            return this.attr({
                visibility: Ya
            });
        },
        hide: function() {
            return this.attr({
                visibility: Wa
            });
        },
        fadeOut: function(a) {
            var b = this;
            b.animate({
                opacity: 0
            }, {
                duration: a || 150,
                complete: function() {
                    b.hide();
                }
            });
        },
        add: function(a) {
            var b, c, e, f, g = this.renderer, h = a || g, i = h.element || g.box, j = i.childNodes, k = this.element, n = m(k, "zIndex");
            if (a && (this.parentGroup = a), this.parentInverted = a && a.inverted, void 0 !== this.textStr && g.buildText(this), 
            n && (h.handleZ = !0, n = d(n)), h.handleZ) for (e = 0; e < j.length; e++) if (b = j[e], 
            c = m(b, "zIndex"), b !== k && (d(c) > n || !l(n) && l(c))) {
                i.insertBefore(k, b), f = !0;
                break;
            }
            return f || i.appendChild(k), this.added = !0, Ab(this, "add"), this;
        },
        safeRemoveChild: function(a) {
            var b = a.parentNode;
            b && b.removeChild(a);
        },
        destroy: function() {
            var a, b, c, d = this, e = d.element || {}, f = d.shadows, g = d.renderer.isSVG && "SPAN" === e.nodeName && e.parentNode;
            if (e.onclick = e.onmouseout = e.onmouseover = e.onmousemove = e.point = null, Db(d), 
            d.clipPath && (d.clipPath = d.clipPath.destroy()), d.stops) {
                for (c = 0; c < d.stops.length; c++) d.stops[c] = d.stops[c].destroy();
                d.stops = null;
            }
            for (d.safeRemoveChild(e), f && ub(f, function(a) {
                d.safeRemoveChild(a);
            }); g && 0 === g.childNodes.length; ) a = g.parentNode, d.safeRemoveChild(g), g = a;
            d.alignTo && k(d.renderer.alignedObjects, d);
            for (b in d) delete d[b];
            return null;
        },
        shadow: function(a, b, c) {
            var d, e, f, g, h, i, j = [], k = this.element;
            if (a) {
                for (g = o(a.width, 3), h = (a.opacity || .15) / g, i = this.parentInverted ? "(-1,-1)" : "(" + o(a.offsetX, 1) + ", " + o(a.offsetY, 1) + ")", 
                d = 1; d <= g; d++) e = k.cloneNode(0), f = 2 * g + 1 - 2 * d, m(e, {
                    isShadow: "true",
                    stroke: a.color || "black",
                    "stroke-opacity": h * d,
                    "stroke-width": f,
                    transform: "translate" + i,
                    fill: $a
                }), c && (m(e, "height", ua(m(e, "height") - f, 0)), e.cutHeight = f), b ? b.element.appendChild(e) : k.parentNode.insertBefore(e, k), 
                j.push(e);
                this.shadows = j;
            }
            return this;
        }
    };
    var Ib = function() {
        this.init.apply(this, arguments);
    };
    Ib.prototype = {
        Element: N,
        init: function(a, b, c, d) {
            var e, f, g, h = this, i = location;
            e = h.createElement("svg").attr({
                version: "1.1"
            }), f = e.element, a.appendChild(f), a.innerHTML.indexOf("xmlns") === -1 && m(f, "xmlns", Ia), 
            h.isSVG = !0, h.box = f, h.boxWrapper = e, h.alignedObjects = [], h.url = (Ga || Fa) && oa.getElementsByTagName("base").length ? i.href.replace(/#.*?$/, "").replace(/([\('\)])/g, "\\$1").replace(/ /g, "%20") : "", 
            g = this.createElement("desc").add(), g.element.appendChild(oa.createTextNode("Created with " + Ra + " " + Sa)), 
            h.defs = this.createElement("defs").add(), h.forExport = d, h.gradients = {}, h.setSize(b, c, !1);
            var j, k;
            Ga && a.getBoundingClientRect && (h.subPixelFix = j = function() {
                p(a, {
                    left: 0,
                    top: 0
                }), k = a.getBoundingClientRect(), p(a, {
                    left: ta(k.left) - k.left + Za,
                    top: ta(k.top) - k.top + Za
                });
            }, j(), yb(pa, "resize", j));
        },
        isHidden: function() {
            return !this.boxWrapper.getBBox().width;
        },
        destroy: function() {
            var a = this, b = a.defs;
            return a.box = null, a.boxWrapper = a.boxWrapper.destroy(), F(a.gradients || {}), 
            a.gradients = null, b && (a.defs = b.destroy()), a.subPixelFix && zb(pa, "resize", a.subPixelFix), 
            a.alignedObjects = null, null;
        },
        createElement: function(a) {
            var b = new this.Element();
            return b.init(this, a), b;
        },
        draw: function() {},
        buildText: function(a) {
            for (var b = a.element, c = this, e = c.forExport, f = o(a.textStr, "").toString().replace(/<(b|strong)>/g, '<span style="font-weight:bold">').replace(/<(i|em)>/g, '<span style="font-style:italic">').replace(/<a/g, "<span").replace(/<\/(b|strong|i|em|a)>/g, "</span>").split(/<br.*?>/g), g = b.childNodes, h = /style="([^"]+)"/, i = /href="(http[^"]+)"/, j = m(b, "x"), k = a.styles, l = k && k.width && d(k.width), n = k && k.lineHeight, q = g.length; q--; ) b.removeChild(g[q]);
            l && !a.added && this.box.appendChild(b), "" === f[f.length - 1] && f.pop(), ub(f, function(f, g) {
                var o, q = 0;
                f = f.replace(/<span/g, "|||<span").replace(/<\/span>/g, "</span>|||"), o = f.split("|||"), 
                ub(o, function(f) {
                    if ("" !== f || 1 === o.length) {
                        var r, s = {}, t = oa.createElementNS(Ia, "tspan");
                        if (h.test(f) && (r = f.match(h)[1].replace(/(;| |^)color([ :])/, "$1fill$2"), m(t, "style", r)), 
                        i.test(f) && !e && (m(t, "onclick", 'location.href="' + f.match(i)[1] + '"'), p(t, {
                            cursor: "pointer"
                        })), f = (f.replace(/<(.|\n)*?>/g, "") || " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">"), 
                        " " !== f && (t.appendChild(oa.createTextNode(f)), q ? s.dx = 0 : s.x = j, m(t, s), 
                        !q && g && (!Ja && e && p(t, {
                            display: "block"
                        }), m(t, "dy", n || c.fontMetrics(/px$/.test(t.style.fontSize) ? t.style.fontSize : k.fontSize).h, Fa && t.offsetHeight)), 
                        b.appendChild(t), q++, l)) for (var u, v, w, x = f.replace(/([^\^])-/g, "$1- ").split(" "), y = a._clipHeight, z = [], A = d(n || 16), B = 1; x.length || z.length; ) delete a.bBox, 
                        w = a.getBBox(), v = w.width, u = v > l, u && 1 !== x.length ? (t.removeChild(t.firstChild), 
                        z.unshift(x.pop())) : (x = z, z = [], x.length && (B++, y && B * A > y ? (x = [ "..." ], 
                        a.attr("title", a.textStr)) : (t = oa.createElementNS(Ia, "tspan"), m(t, {
                            dy: A,
                            x: j
                        }), r && m(t, "style", r), b.appendChild(t), v > l && (l = v)))), x.length && t.appendChild(oa.createTextNode(x.join(" ").replace(/- /g, "-")));
                    }
                });
            });
        },
        button: function(c, d, e, f, g, h, i, j) {
            var k, l, m, n, o, p, q = this.label(c, d, e, null, null, null, null, null, "button"), r = 0, s = "style", t = {
                x1: 0,
                y1: 0,
                x2: 0,
                y2: 1
            };
            return g = b({
                "stroke-width": 1,
                stroke: "#CCCCCC",
                fill: {
                    linearGradient: t,
                    stops: [ [ 0, "#FEFEFE" ], [ 1, "#F6F6F6" ] ]
                },
                r: 2,
                padding: 5,
                style: {
                    color: "black"
                }
            }, g), m = g[s], delete g[s], h = b(g, {
                stroke: "#68A",
                fill: {
                    linearGradient: t,
                    stops: [ [ 0, "#FFF" ], [ 1, "#ACF" ] ]
                }
            }, h), n = h[s], delete h[s], i = b(g, {
                stroke: "#68A",
                fill: {
                    linearGradient: t,
                    stops: [ [ 0, "#9BD" ], [ 1, "#CDF" ] ]
                }
            }, i), o = i[s], delete i[s], j = b(g, {
                style: {
                    color: "#CCC"
                }
            }, j), p = j[s], delete j[s], yb(q.element, Da ? "mouseover" : "mouseenter", function() {
                3 !== r && q.attr(h).css(n);
            }), yb(q.element, Da ? "mouseout" : "mouseleave", function() {
                3 !== r && (k = [ g, h, i ][r], l = [ m, n, o ][r], q.attr(k).css(l));
            }), q.setState = function(a) {
                q.state = r = a, a ? 2 === a ? q.attr(i).css(o) : 3 === a && q.attr(j).css(p) : q.attr(g).css(m);
            }, q.on("click", function() {
                3 !== r && f.call(q);
            }).attr(g).css(a({
                cursor: "default"
            }, m));
        },
        crispLine: function(a, b) {
            return a[1] === a[4] && (a[1] = a[4] = ra(a[1]) - b % 2 / 2), a[2] === a[5] && (a[2] = a[5] = ra(a[2]) + b % 2 / 2), 
            a;
        },
        path: function(b) {
            var c = {
                fill: $a
            };
            return g(b) ? c.d = b : f(b) && a(c, b), this.createElement("path").attr(c);
        },
        circle: function(a, b, c) {
            var d = f(a) ? a : {
                x: a,
                y: b,
                r: c
            };
            return this.createElement("circle").attr(d);
        },
        arc: function(a, b, c, d, e, g) {
            var h;
            return f(a) && (b = a.y, c = a.r, d = a.innerR, e = a.start, g = a.end, a = a.x), 
            h = this.symbol("arc", a || 0, b || 0, c || 0, c || 0, {
                innerR: d || 0,
                start: e || 0,
                end: g || 0
            }), h.r = c, h;
        },
        rect: function(a, b, c, d, e, g) {
            e = f(a) ? a.r : e;
            var h = this.createElement("rect").attr({
                rx: e,
                ry: e,
                fill: $a
            });
            return h.attr(f(a) ? a : h.crisp(g, a, b, ua(c, 0), ua(d, 0)));
        },
        setSize: function(a, b, c) {
            var d = this, e = d.alignedObjects, f = e.length;
            for (d.width = a, d.height = b, d.boxWrapper[o(c, !0) ? "animate" : "attr"]({
                width: a,
                height: b
            }); f--; ) e[f].align();
        },
        g: function(a) {
            var b = this.createElement("g");
            return l(a) ? b.attr({
                class: Xa + a
            }) : b;
        },
        image: function(b, c, d, e, f) {
            var g, h = {
                preserveAspectRatio: $a
            };
            return arguments.length > 1 && a(h, {
                x: c,
                y: d,
                width: e,
                height: f
            }), g = this.createElement("image").attr(h), g.element.setAttributeNS ? g.element.setAttributeNS("http://www.w3.org/1999/xlink", "href", b) : g.element.setAttribute("hc-svg-href", b), 
            g;
        },
        symbol: function(b, c, d, e, f, g) {
            var h, i, j, k, l, m = this.symbols[b], n = m && m(ra(c), ra(d), e, f, g), o = /^url\((.*?)\)$/;
            return n ? (h = this.path(n), a(h, {
                symbolName: b,
                x: c,
                y: d,
                width: e,
                height: f
            }), g && a(h, g)) : o.test(b) && (l = function(a, b) {
                a.element && (a.attr({
                    width: b[0],
                    height: b[1]
                }), a.alignByTranslate || a.translate(ra((e - b[0]) / 2), ra((f - b[1]) / 2)));
            }, j = b.match(o)[1], k = Na[j], h = this.image(j).attr({
                x: c,
                y: d
            }), h.isImg = !0, k ? l(h, k) : (h.attr({
                width: 0,
                height: 0
            }), i = q("img", {
                onload: function() {
                    l(h, Na[j] = [ this.width, this.height ]);
                },
                src: j
            }))), h;
        },
        symbols: {
            circle: function(a, b, c, d) {
                var e = .166 * c;
                return [ _a, a + c / 2, b, "C", a + c + e, b, a + c + e, b + d, a + c / 2, b + d, "C", a - e, b + d, a - e, b, a + c / 2, b, "Z" ];
            },
            square: function(a, b, c, d) {
                return [ _a, a, b, ab, a + c, b, a + c, b + d, a, b + d, "Z" ];
            },
            triangle: function(a, b, c, d) {
                return [ _a, a + c / 2, b, ab, a + c, b + d, a, b + d, "Z" ];
            },
            "triangle-down": function(a, b, c, d) {
                return [ _a, a, b, ab, a + c, b, a + c / 2, b + d, "Z" ];
            },
            diamond: function(a, b, c, d) {
                return [ _a, a + c / 2, b, ab, a + c, b + d / 2, a + c / 2, b + d, a, b + d / 2, "Z" ];
            },
            arc: function(a, b, c, d, e) {
                var f = e.start, g = e.r || c || d, h = e.end - .001, i = e.innerR, j = e.open, k = xa(f), l = ya(f), m = xa(h), n = ya(h), o = e.end - f < za ? 0 : 1;
                return [ _a, a + g * k, b + g * l, "A", g, g, 0, o, 1, a + g * m, b + g * n, j ? _a : ab, a + i * m, b + i * n, "A", i, i, 0, o, 0, a + i * k, b + i * l, j ? "" : "Z" ];
            }
        },
        clipRect: function(a, b, c, d) {
            var e, f = Xa + Oa++, g = this.createElement("clipPath").attr({
                id: f
            }).add(this.defs);
            return e = this.rect(a, b, c, d, 0).add(g), e.id = f, e.clipPath = g, e;
        },
        color: function(a, c, d) {
            var e, f, h, i, j, k, n, o, p, q, r, s = this, t = /^rgba/, u = [];
            if (a && a.linearGradient ? f = "linearGradient" : a && a.radialGradient && (f = "radialGradient"), 
            f) {
                h = a[f], i = s.gradients, k = a.stops, p = c.radialReference, g(h) && (a[f] = h = {
                    x1: h[0],
                    y1: h[1],
                    x2: h[2],
                    y2: h[3],
                    gradientUnits: "userSpaceOnUse"
                }), "radialGradient" === f && p && !l(h.gradientUnits) && (h = b(h, {
                    cx: p[0] - p[2] / 2 + h.cx * p[2],
                    cy: p[1] - p[2] / 2 + h.cy * p[2],
                    r: h.r * p[2],
                    gradientUnits: "userSpaceOnUse"
                }));
                for (q in h) "id" !== q && u.push(q, h[q]);
                for (q in k) u.push(k[q]);
                return u = u.join(","), i[u] ? r = i[u].id : (h.id = r = Xa + Oa++, i[u] = j = s.createElement(f).attr(h).add(s.defs), 
                j.stops = [], ub(k, function(a) {
                    var b;
                    t.test(a[1]) ? (e = Hb(a[1]), n = e.get("rgb"), o = e.get("a")) : (n = a[1], o = 1), 
                    b = s.createElement("stop").attr({
                        offset: a[0],
                        "stop-color": n,
                        "stop-opacity": o
                    }).add(j), j.stops.push(b);
                })), "url(" + s.url + "#" + r + ")";
            }
            return t.test(a) ? (e = Hb(a), m(c, d + "-opacity", e.get("a")), e.get("rgb")) : (c.removeAttribute(d + "-opacity"), 
            a);
        },
        text: function(a, b, c, d) {
            var e, f = this, g = Z.chart.style, h = La || !Ja && f.forExport;
            return d && !f.forExport ? f.html(a, b, c) : (b = ra(o(b, 0)), c = ra(o(c, 0)), 
            e = f.createElement("text").attr({
                x: b,
                y: c,
                text: a
            }).css({
                fontFamily: g.fontFamily,
                fontSize: g.fontSize
            }), h && e.css({
                position: Ua
            }), e.x = b, e.y = c, e);
        },
        html: function(b, c, d) {
            var e = Z.chart.style, f = this.createElement("span"), g = f.attrSetters, h = f.element, i = f.renderer;
            return g.text = function(a) {
                return a !== h.innerHTML && delete this.bBox, h.innerHTML = a, !1;
            }, g.x = g.y = g.align = function(a, b) {
                return "align" === b && (b = "textAlign"), f[b] = a, f.htmlUpdateTransform(), !1;
            }, f.attr({
                text: b,
                x: ra(c),
                y: ra(d)
            }).css({
                position: Ua,
                whiteSpace: "nowrap",
                fontFamily: e.fontFamily,
                fontSize: e.fontSize
            }), f.css = f.htmlCss, i.isSVG && (f.add = function(b) {
                var c, d, e = i.box.parentNode, g = [];
                if (b) {
                    if (c = b.div, !c) {
                        for (d = b; d; ) g.push(d), d = d.parentGroup;
                        ub(g.reverse(), function(b) {
                            var d;
                            c = b.div = b.div || q(Ta, {
                                className: m(b.element, "class")
                            }, {
                                position: Ua,
                                left: (b.translateX || 0) + Za,
                                top: (b.translateY || 0) + Za
                            }, c || e), d = c.style, a(b.attrSetters, {
                                translateX: function(a) {
                                    d.left = a + Za;
                                },
                                translateY: function(a) {
                                    d.top = a + Za;
                                },
                                visibility: function(a, b) {
                                    d[b] = a;
                                }
                            });
                        });
                    }
                } else c = e;
                return c.appendChild(h), f.added = !0, f.alignOnAdd && f.htmlUpdateTransform(), 
                f;
            }), f;
        },
        fontMetrics: function(a) {
            a = d(a || 11);
            var b = a < 24 ? a + 4 : ra(1.2 * a), c = ra(.8 * b);
            return {
                h: b,
                b: c
            };
        },
        label: function(c, d, e, f, g, h, i, j, k) {
            function m() {
                var a, c, d = A.element.style;
                r = (void 0 === s || void 0 === t || z.styles.textAlign) && A.getBBox(), z.width = (s || r.width || 0) + 2 * C + D, 
                z.height = (t || r.height || 0) + 2 * C, w = C + y.fontMetrics(d && d.fontSize).b, 
                x && (q || (a = ra(-B * C), c = j ? -w : 0, z.box = q = f ? y.symbol(f, a, c, z.width, z.height) : y.rect(a, c, z.width, z.height, 0, F[nb]), 
                q.add(z)), q.isImg || q.attr(b({
                    width: z.width,
                    height: z.height
                }, F)), F = null);
            }
            function n() {
                var a, b = z.styles, c = b && b.textAlign, d = D + C * (1 - B);
                a = j ? 0 : w, !l(s) || "center" !== c && "right" !== c || (d += {
                    center: .5,
                    right: 1
                }[c] * (s - r.width)), d === A.x && a === A.y || A.attr({
                    x: d,
                    y: a
                }), A.x = d, A.y = a;
            }
            function o(a, b) {
                q ? q.attr(a, b) : F[a] = b;
            }
            function p() {
                A.add(z), z.attr({
                    text: c,
                    x: d,
                    y: e
                }), q && l(g) && z.attr({
                    anchorX: g,
                    anchorY: h
                });
            }
            var q, r, s, t, u, v, w, x, y = this, z = y.g(k), A = y.text("", 0, 0, i).attr({
                zIndex: 1
            }), B = 0, C = 3, D = 0, E = 0, F = {}, G = z.attrSetters;
            yb(z, "add", p), G.width = function(a) {
                return s = a, !1;
            }, G.height = function(a) {
                return t = a, !1;
            }, G.padding = function(a) {
                return l(a) && a !== C && (C = a, n()), !1;
            }, G.paddingLeft = function(a) {
                return l(a) && a !== D && (D = a, n()), !1;
            }, G.align = function(a) {
                return B = {
                    left: 0,
                    center: .5,
                    right: 1
                }[a], !1;
            }, G.text = function(a, b) {
                return A.attr(b, a), m(), n(), !1;
            }, G[nb] = function(a, b) {
                return x = !0, E = a % 2 / 2, o(b, a), !1;
            }, G.stroke = G.fill = G.r = function(a, b) {
                return "fill" === b && (x = !0), o(b, a), !1;
            }, G.anchorX = function(a, b) {
                return g = a, o(b, a + E - u), !1;
            }, G.anchorY = function(a, b) {
                return h = a, o(b, a - v), !1;
            }, G.x = function(a) {
                return z.x = a, a -= B * ((s || r.width) + C), u = ra(a), z.attr("translateX", u), 
                !1;
            }, G.y = function(a) {
                return v = z.y = ra(a), z.attr("translateY", v), !1;
            };
            var H = z.css;
            return a(z, {
                css: function(a) {
                    if (a) {
                        var c = {};
                        a = b(a), ub([ "fontSize", "fontWeight", "fontFamily", "color", "lineHeight", "width", "textDecoration", "textShadow" ], function(b) {
                            a[b] !== W && (c[b] = a[b], delete a[b]);
                        }), A.css(c);
                    }
                    return H.call(z, a);
                },
                getBBox: function() {
                    return {
                        width: r.width + 2 * C,
                        height: r.height + 2 * C,
                        x: r.x - C,
                        y: r.y - C
                    };
                },
                shadow: function(a) {
                    return q && q.shadow(a), z;
                },
                destroy: function() {
                    zb(z, "add", p), zb(z.element, "mouseenter"), zb(z.element, "mouseleave"), A && (A = A.destroy()), 
                    q && (q = q.destroy()), N.prototype.destroy.call(z), z = y = m = n = o = p = null;
                }
            });
        }
    }, X = Ib;
    var Jb, Kb;
    if (!Ja && !La) {
        Highcharts.VMLElement = Kb = {
            init: function(a, b) {
                var c = this, d = [ "<", b, ' filled="f" stroked="f"' ], e = [ "position: ", Ua, ";" ], f = b === Ta;
                ("shape" === b || f) && e.push("left:0;top:0;width:1px;height:1px;"), e.push("visibility: ", f ? Wa : Ya), 
                d.push(' style="', e.join(""), '"/>'), b && (d = f || "span" === b || "img" === b ? d.join("") : a.prepVML(d), 
                c.element = q(d)), c.renderer = a, c.attrSetters = {};
            },
            add: function(a) {
                var b = this, c = b.renderer, d = b.element, e = c.box, f = a && a.inverted, g = a ? a.element || a : e;
                return f && c.invertChild(d, g), g.appendChild(d), b.added = !0, b.alignOnAdd && !b.deferUpdateTransform && b.updateTransform(), 
                Ab(b, "add"), b;
            },
            updateTransform: N.prototype.htmlUpdateTransform,
            setSpanRotation: function(a, b, c) {
                p(this.element, {
                    filter: a ? [ "progid:DXImageTransform.Microsoft.Matrix(M11=", c, ", M12=", -b, ", M21=", b, ", M22=", c, ", sizingMethod='auto expand')" ].join("") : $a
                });
            },
            pathToVML: function(a) {
                for (var b, c = a.length, d = []; c--; ) h(a[c]) ? d[c] = ra(10 * a[c]) - 5 : "Z" === a[c] ? d[c] = "x" : (d[c] = a[c], 
                !a.isArc || "wa" !== a[c] && "at" !== a[c] || (b = "wa" === a[c] ? 1 : -1, d[c + 5] === d[c + 7] && (d[c + 7] -= b), 
                d[c + 6] === d[c + 8] && (d[c + 8] -= b)));
                return d.join(" ") || "x";
            },
            attr: function(a, b) {
                var c, d, f, g, i, j, k = this, n = k.element || {}, o = n.style, p = n.nodeName, r = k.renderer, s = k.symbolName, t = k.shadows, u = k.attrSetters, v = k;
                if (e(a) && l(b) && (c = a, a = {}, a[c] = b), e(a)) c = a, v = "strokeWidth" === c || "stroke-width" === c ? k.strokeweight : k[c]; else for (c in a) if (d = a[c], 
                j = !1, g = u[c] && u[c].call(k, d, c), g !== !1 && null !== d) {
                    if (g !== W && (d = g), s && /^(x|y|r|start|end|width|height|innerR|anchorX|anchorY)/.test(c)) i || (k.symbolAttr(a), 
                    i = !0), j = !0; else if ("d" === c) {
                        if (d = d || [], k.d = d.join(" "), n.path = d = k.pathToVML(d), t) for (f = t.length; f--; ) t[f].path = t[f].cutOff ? this.cutOffPath(d, t[f].cutOff) : d;
                        j = !0;
                    } else if ("visibility" === c) {
                        if (t) for (f = t.length; f--; ) t[f].style[c] = d;
                        "DIV" === p && (d = d === Wa ? "-999em" : 0, Ea || (o[c] = d ? Ya : Wa), c = "top"), 
                        o[c] = d, j = !0;
                    } else if ("zIndex" === c) d && (o[c] = d), j = !0; else if (tb(c, [ "x", "y", "width", "height" ]) !== -1) k[c] = d, 
                    "x" === c || "y" === c ? c = {
                        x: "left",
                        y: "top"
                    }[c] : d = ua(0, d), k.updateClipping ? (k[c] = d, k.updateClipping()) : o[c] = d, 
                    j = !0; else if ("class" === c && "DIV" === p) n.className = d; else if ("stroke" === c) d = r.color(d, n, c), 
                    c = "strokecolor"; else if ("stroke-width" === c || "strokeWidth" === c) n.stroked = !!d, 
                    c = "strokeweight", k[c] = d, h(d) && (d += Za); else if ("dashstyle" === c) {
                        var w = n.getElementsByTagName("stroke")[0] || q(r.prepVML([ "<stroke/>" ]), null, null, n);
                        w[c] = d || "solid", k.dashstyle = d, j = !0;
                    } else "fill" === c ? "SPAN" === p ? o.color = d : "IMG" !== p && (n.filled = d !== $a, 
                    d = r.color(d, n, c, k), c = "fillcolor") : "opacity" === c ? j = !0 : "shape" === p && "rotation" === c ? (k[c] = n.style[c] = d, 
                    n.style.left = -ra(ya(d * Aa) + 1) + Za, n.style.top = ra(xa(d * Aa)) + Za) : "translateX" === c || "translateY" === c || "rotation" === c ? (k[c] = d, 
                    k.updateTransform(), j = !0) : "text" === c && (this.bBox = null, n.innerHTML = d, 
                    j = !0);
                    j || (Ea ? n[c] = d : m(n, c, d));
                }
                return v;
            },
            clip: function(a) {
                var b, c, d = this;
                return a ? (b = a.members, k(b, d), b.push(d), d.destroyClip = function() {
                    k(b, d);
                }, c = a.getCSS(d)) : (d.destroyClip && d.destroyClip(), c = {
                    clip: Ea ? "inherit" : "rect(auto)"
                }), d.css(c);
            },
            css: N.prototype.htmlCss,
            safeRemoveChild: function(a) {
                a.parentNode && G(a);
            },
            destroy: function() {
                return this.destroyClip && this.destroyClip(), N.prototype.destroy.apply(this);
            },
            on: function(a, b) {
                return this.element["on" + a] = function() {
                    var a = pa.event;
                    a.target = a.srcElement, b(a);
                }, this;
            },
            cutOffPath: function(a, b) {
                var c;
                return a = a.split(/[ ,]/), c = a.length, 9 !== c && 11 !== c || (a[c - 4] = a[c - 2] = d(a[c - 2]) - 10 * b), 
                a.join(" ");
            },
            shadow: function(a, b, c) {
                var e, f, g, h, i, j, k, l = [], m = this.element, n = this.renderer, p = m.style, r = m.path;
                if (r && "string" != typeof r.value && (r = "x"), i = r, a) {
                    for (j = o(a.width, 3), k = (a.opacity || .15) / j, e = 1; e <= 3; e++) h = 2 * j + 1 - 2 * e, 
                    c && (i = this.cutOffPath(r.value, h + .5)), g = [ '<shape isShadow="true" strokeweight="', h, '" filled="false" path="', i, '" coordsize="10 10" style="', m.style.cssText, '" />' ], 
                    f = q(n.prepVML(g), null, {
                        left: d(p.left) + o(a.offsetX, 1),
                        top: d(p.top) + o(a.offsetY, 1)
                    }), c && (f.cutOff = h + 1), g = [ '<stroke color="', a.color || "black", '" opacity="', k * e, '"/>' ], 
                    q(n.prepVML(g), null, null, f), b ? b.element.appendChild(f) : m.parentNode.insertBefore(f, m), 
                    l.push(f);
                    this.shadows = l;
                }
                return this;
            }
        }, Kb = r(N, Kb);
        var Lb = {
            Element: Kb,
            isIE8: Ba.indexOf("MSIE 8.0") > -1,
            init: function(a, b, c) {
                var d, e, f = this;
                f.alignedObjects = [], d = f.createElement(Ta), e = d.element, e.style.position = Va, 
                a.appendChild(d.element), f.isVML = !0, f.box = e, f.boxWrapper = d, f.setSize(b, c, !1), 
                oa.namespaces.hcv || (oa.namespaces.add("hcv", "urn:schemas-microsoft-com:vml"), 
                (oa.styleSheets.length ? oa.styleSheets[0] : oa.createStyleSheet()).cssText += "hcv\\:fill, hcv\\:path, hcv\\:shape, hcv\\:stroke{ behavior:url(#default#VML); display: inline-block; } ");
            },
            isHidden: function() {
                return !this.box.offsetWidth;
            },
            clipRect: function(b, c, d, e) {
                var g = this.createElement(), h = f(b);
                return a(g, {
                    members: [],
                    left: (h ? b.x : b) + 1,
                    top: (h ? b.y : c) + 1,
                    width: (h ? b.width : d) - 1,
                    height: (h ? b.height : e) - 1,
                    getCSS: function(b) {
                        var c = b.element, d = c.nodeName, e = "shape" === d, f = b.inverted, g = this, h = g.top - (e ? c.offsetTop : 0), i = g.left, j = i + g.width, k = h + g.height, l = {
                            clip: "rect(" + ra(f ? i : h) + "px," + ra(f ? k : j) + "px," + ra(f ? j : k) + "px," + ra(f ? h : i) + "px)"
                        };
                        return !f && Ea && "DIV" === d && a(l, {
                            width: j + Za,
                            height: k + Za
                        }), l;
                    },
                    updateClipping: function() {
                        ub(g.members, function(a) {
                            a.css(g.getCSS(a));
                        });
                    }
                });
            },
            color: function(a, b, c, d) {
                var e, f, g, h = this, i = /^rgba/, j = $a;
                if (a && a.linearGradient ? g = "gradient" : a && a.radialGradient && (g = "pattern"), 
                g) {
                    var k, l, m, n, o, p, r, s, t, u, v, w, x = a.linearGradient || a.radialGradient, y = "", z = a.stops, A = [], B = function() {
                        f = [ '<fill colors="' + A.join(",") + '" opacity="', s, '" o:opacity2="', r, '" type="', g, '" ', y, 'focus="100%" method="any" />' ], 
                        q(h.prepVML(f), null, null, b);
                    };
                    if (v = z[0], w = z[z.length - 1], v[0] > 0 && z.unshift([ 0, v[1] ]), w[0] < 1 && z.push([ 1, w[1] ]), 
                    ub(z, function(a, b) {
                        i.test(a[1]) ? (e = Hb(a[1]), k = e.get("rgb"), l = e.get("a")) : (k = a[1], l = 1), 
                        A.push(100 * a[0] + "% " + k), b ? (s = l, t = k) : (r = l, u = k);
                    }), "fill" === c) if ("gradient" === g) m = x.x1 || x[0] || 0, n = x.y1 || x[1] || 0, 
                    o = x.x2 || x[2] || 0, p = x.y2 || x[3] || 0, y = 'angle="' + (90 - 180 * qa.atan((p - n) / (o - m)) / za) + '"', 
                    B(); else {
                        var C, D = x.r, E = 2 * D, F = 2 * D, G = x.cx, H = x.cy, I = b.radialReference, J = function() {
                            I && (C = d.getBBox(), G += (I[0] - C.x) / C.width - .5, H += (I[1] - C.y) / C.height - .5, 
                            E *= I[2] / C.width, F *= I[2] / C.height), y = 'src="' + Z.global.VMLRadialGradientURL + '" size="' + E + "," + F + '" origin="0.5,0.5" position="' + G + "," + H + '" color2="' + u + '" ', 
                            B();
                        };
                        d.added ? J() : yb(d, "add", J), j = t;
                    } else j = k;
                } else if (i.test(a) && "IMG" !== b.tagName) e = Hb(a), f = [ "<", c, ' opacity="', e.get("a"), '"/>' ], 
                q(this.prepVML(f), null, null, b), j = e.get("rgb"); else {
                    var K = b.getElementsByTagName(c);
                    K.length && (K[0].opacity = 1, K[0].type = "solid"), j = a;
                }
                return j;
            },
            prepVML: function(a) {
                var b = "display:inline-block;behavior:url(#default#VML);", c = this.isIE8;
                return a = a.join(""), c ? (a = a.replace("/>", ' xmlns="urn:schemas-microsoft-com:vml" />'), 
                a = a.indexOf('style="') === -1 ? a.replace("/>", ' style="' + b + '" />') : a.replace('style="', 'style="' + b)) : a = a.replace("<", "<hcv:"), 
                a;
            },
            text: Ib.prototype.html,
            path: function(b) {
                var c = {
                    coordsize: "10 10"
                };
                return g(b) ? c.d = b : f(b) && a(c, b), this.createElement("shape").attr(c);
            },
            circle: function(a, b, c) {
                var d = this.symbol("circle");
                return f(a) && (c = a.r, b = a.y, a = a.x), d.isCircle = !0, d.r = c, d.attr({
                    x: a,
                    y: b
                });
            },
            g: function(a) {
                var b, c;
                return a && (c = {
                    className: Xa + a,
                    class: Xa + a
                }), b = this.createElement(Ta).attr(c);
            },
            image: function(a, b, c, d, e) {
                var f = this.createElement("img").attr({
                    src: a
                });
                return arguments.length > 1 && f.attr({
                    x: b,
                    y: c,
                    width: d,
                    height: e
                }), f;
            },
            rect: function(a, b, c, d, e, g) {
                var h = this.symbol("rect");
                return h.r = f(a) ? a.r : e, h.attr(f(a) ? a : h.crisp(g, a, b, ua(c, 0), ua(d, 0)));
            },
            invertChild: function(a, b) {
                var c = b.style;
                p(a, {
                    flip: "x",
                    left: d(c.width) - 1,
                    top: d(c.height) - 1,
                    rotation: -90
                });
            },
            symbols: {
                arc: function(a, b, c, d, e) {
                    var f, g = e.start, h = e.end, i = e.r || c || d, j = e.innerR, k = xa(g), l = ya(g), m = xa(h), n = ya(h);
                    return h - g === 0 ? [ "x" ] : (f = [ "wa", a - i, b - i, a + i, b + i, a + i * k, b + i * l, a + i * m, b + i * n ], 
                    e.open && !j && f.push("e", _a, a, b), f.push("at", a - j, b - j, a + j, b + j, a + j * m, b + j * n, a + j * k, b + j * l, "x", "e"), 
                    f.isArc = !0, f);
                },
                circle: function(a, b, c, d, e) {
                    return e && (c = d = 2 * e.r), e && e.isCircle && (a -= c / 2, b -= d / 2), [ "wa", a, b, a + c, b + d, a + c, b + d / 2, a + c, b + d / 2, "e" ];
                },
                rect: function(a, b, c, d, e) {
                    var f, g, h = a + c, i = b + d;
                    return l(e) && e.r ? (g = va(e.r, c, d), f = [ _a, a + g, b, ab, h - g, b, "wa", h - 2 * g, b, h, b + 2 * g, h - g, b, h, b + g, ab, h, i - g, "wa", h - 2 * g, i - 2 * g, h, i, h, i - g, h - g, i, ab, a + g, i, "wa", a, i - 2 * g, a + 2 * g, i, a + g, i, a, i - g, ab, a, b + g, "wa", a, b, a + 2 * g, b + 2 * g, a, b + g, a + g, b, "x", "e" ]) : f = Ib.prototype.symbols.square.apply(0, arguments), 
                    f;
                }
            }
        };
        Highcharts.VMLRenderer = Jb = function() {
            this.init.apply(this, arguments);
        }, Jb.prototype = b(Ib.prototype, Lb), X = Jb;
    }
    var Mb, Nb;
    La && (Highcharts.CanVGRenderer = Mb = function() {
        Ia = "http://www.w3.org/1999/xhtml";
    }, Mb.prototype.symbols = {}, Nb = function() {
        function a() {
            var a, c = b.length;
            for (a = 0; a < c; a++) b[a]();
            b = [];
        }
        var b = [];
        return {
            push: function(c, d) {
                0 === b.length && sb(d, a), b.push(c);
            }
        };
    }(), X = Mb), O.prototype = {
        addLabel: function() {
            var b, c, d, e, f = this, g = f.axis, i = g.options, k = g.chart, m = g.horiz, n = g.categories, p = g.series[0] && g.series[0].names, q = f.pos, r = i.labels, s = g.tickPositions, t = m && n && !r.step && !r.staggerLines && !r.rotation && k.plotWidth / s.length || !m && (k.margin[3] || .33 * k.chartWidth), u = q === s[0], v = q === s[s.length - 1], w = n ? o(n[q], p && p[q], q) : q, x = f.label, y = s.info;
            g.isDatetimeAxis && y && (e = i.dateTimeLabelFormats[y.higherRanks[q] || y.unitName]), 
            f.isFirst = u, f.isLast = v, b = g.labelFormatter.call({
                axis: g,
                chart: k,
                isFirst: u,
                isLast: v,
                dateTimeLabelFormat: e,
                value: g.isLog ? I(j(w)) : w
            }), c = t && {
                width: ua(1, ra(t - 2 * (r.padding || 10))) + Za
            }, c = a(c, r.style), l(x) ? x && x.attr({
                text: b
            }).css(c) : (d = {
                align: g.labelAlign
            }, h(r.rotation) && (d.rotation = r.rotation), t && r.ellipsis && (d._clipHeight = g.len / s.length), 
            f.label = l(b) && r.enabled ? k.renderer.text(b, 0, 0, r.useHTML).attr(d).css(c).add(g.labelGroup) : null);
        },
        getLabelSize: function() {
            var a = this.label, b = this.axis;
            return a ? (this.labelBBox = a.getBBox())[b.horiz ? "height" : "width"] : 0;
        },
        getLabelSides: function() {
            var a = this.labelBBox, b = this.axis, c = b.options, d = c.labels, e = a.width, f = e * {
                left: 0,
                center: .5,
                right: 1
            }[b.labelAlign] - d.x;
            return [ -f, e - f ];
        },
        handleOverflow: function(a, b) {
            var c = !0, d = this.axis, e = d.chart, f = this.isFirst, g = this.isLast, h = b.x, i = d.reversed, j = d.tickPositions;
            if (f || g) {
                var k = this.getLabelSides(), l = k[0], m = k[1], n = e.plotLeft, o = n + d.len, p = d.ticks[j[a + (f ? 1 : -1)]], q = p && p.label.xy && p.label.xy.x + p.getLabelSides()[f ? 0 : 1];
                f && !i || g && i ? h + l < n && (h = n - l, p && h + m > q && (c = !1)) : h + m > o && (h = o - m, 
                p && h + l < q && (c = !1)), b.x = h;
            }
            return c;
        },
        getPosition: function(a, b, c, d) {
            var e = this.axis, f = e.chart, g = d && f.oldChartHeight || f.chartHeight;
            return {
                x: a ? e.translate(b + c, null, null, d) + e.transB : e.left + e.offset + (e.opposite ? (d && f.oldChartWidth || f.chartWidth) - e.right - e.left : 0),
                y: a ? g - e.bottom + e.offset - (e.opposite ? e.height : 0) : g - e.translate(b + c, null, null, d) - e.transB
            };
        },
        getLabelPosition: function(a, b, c, d, e, f, g, h) {
            var i = this.axis, j = i.transA, k = i.reversed, m = i.staggerLines, n = i.chart.renderer.fontMetrics(e.style.fontSize).b, o = e.rotation;
            return a = a + e.x - (f && d ? f * j * (k ? -1 : 1) : 0), b = b + e.y - (f && !d ? f * j * (k ? 1 : -1) : 0), 
            o && 2 === i.side && (b -= n - n * xa(o * Aa)), l(e.y) || o || (b += n - c.getBBox().height / 2), 
            m && (b += g / (h || 1) % m * (i.labelOffset / m)), {
                x: a,
                y: b
            };
        },
        getMarkPath: function(a, b, c, d, e, f) {
            return f.crispLine([ _a, a, b, ab, a + (e ? 0 : -c), b + (e ? c : 0) ], d);
        },
        render: function(a, b, c) {
            var d, e, f, g = this, h = g.axis, i = h.options, j = h.chart, k = j.renderer, l = h.horiz, m = g.type, n = g.label, p = g.pos, q = i.labels, r = g.gridLine, s = m ? m + "Grid" : "grid", t = m ? m + "Tick" : "tick", u = i[s + "LineWidth"], v = i[s + "LineColor"], w = i[s + "LineDashStyle"], x = i[t + "Length"], y = i[t + "Width"] || 0, z = i[t + "Color"], A = i[t + "Position"], B = g.mark, C = q.step, D = !0, E = h.tickmarkOffset, F = g.getPosition(l, p, E, b), G = F.x, H = F.y, I = l && G === h.pos + h.len || !l && H === h.pos ? -1 : 1, J = h.staggerLines;
            this.isActive = !0, u && (d = h.getPlotLinePath(p + E, u * I, b, !0), r === W && (f = {
                stroke: v,
                "stroke-width": u
            }, w && (f.dashstyle = w), m || (f.zIndex = 1), b && (f.opacity = 0), g.gridLine = r = u ? k.path(d).attr(f).add(h.gridGroup) : null), 
            !b && r && d && r[g.isNew ? "attr" : "animate"]({
                d: d,
                opacity: c
            })), y && x && ("inside" === A && (x = -x), h.opposite && (x = -x), e = g.getMarkPath(G, H, x, y * I, l, k), 
            B ? B.animate({
                d: e,
                opacity: c
            }) : g.mark = k.path(e).attr({
                stroke: z,
                "stroke-width": y,
                opacity: c
            }).add(h.axisGroup)), n && !isNaN(G) && (n.xy = F = g.getLabelPosition(G, H, n, l, q, E, a, C), 
            g.isFirst && !g.isLast && !o(i.showFirstLabel, 1) || g.isLast && !g.isFirst && !o(i.showLastLabel, 1) ? D = !1 : J || !l || "justify" !== q.overflow || g.handleOverflow(a, F) || (D = !1), 
            C && a % C && (D = !1), D && !isNaN(F.y) ? (F.opacity = c, n[g.isNew ? "attr" : "animate"](F), 
            g.isNew = !1) : n.attr("y", -9999));
        },
        destroy: function() {
            F(this, this.axis);
        }
    }, P.prototype = {
        render: function() {
            var a, c, d, e, f, g, h, j = this, k = j.axis, m = k.horiz, n = (k.pointRange || 0) / 2, p = j.options, q = p.label, r = j.label, s = p.width, t = p.to, u = p.from, v = l(u) && l(t), w = p.value, x = p.dashStyle, y = j.svgElem, z = [], A = p.color, B = p.zIndex, C = p.events, F = k.chart.renderer;
            if (k.isLog && (u = i(u), t = i(t), w = i(w)), s) z = k.getPlotLinePath(w, s), h = {
                stroke: A,
                "stroke-width": s
            }, x && (h.dashstyle = x); else {
                if (!v) return;
                u = ua(u, k.min - n), t = va(t, k.max + n), z = k.getPlotBandPath(u, t, p), h = {
                    fill: A
                }, p.borderWidth && (h.stroke = p.borderColor, h["stroke-width"] = p.borderWidth);
            }
            if (l(B) && (h.zIndex = B), y) z ? y.animate({
                d: z
            }, null, y.onGetPath) : (y.hide(), y.onGetPath = function() {
                y.show();
            }); else if (z && z.length && (j.svgElem = y = F.path(z).attr(h).add(), C)) {
                a = function(a) {
                    y.on(a, function(b) {
                        C[a].apply(j, [ b ]);
                    });
                };
                for (c in C) a(c);
            }
            return q && l(q.text) && z && z.length && k.width > 0 && k.height > 0 ? (q = b({
                align: m && v && "center",
                x: m ? !v && 4 : 10,
                verticalAlign: !m && v && "middle",
                y: m ? v ? 16 : 10 : v ? 6 : -4,
                rotation: m && !v && 90
            }, q), r || (j.label = r = F.text(q.text, 0, 0, q.useHTML).attr({
                align: q.textAlign || q.align,
                rotation: q.rotation,
                zIndex: B
            }).css(q.style).add()), d = [ z[1], z[4], o(z[6], z[1]) ], e = [ z[2], z[5], o(z[7], z[2]) ], 
            f = D(d), g = D(e), r.align(q, !1, {
                x: f,
                y: g,
                width: E(d) - f,
                height: E(e) - g
            }), r.show()) : r && r.hide(), j;
        },
        destroy: function() {
            k(this.axis.plotLinesAndBands, this), delete this.axis, F(this);
        }
    }, Q.prototype = {
        destroy: function() {
            F(this, this.axis);
        },
        render: function(a) {
            var b = this.options, c = b.format, d = c ? w(c, this) : b.formatter.call(this);
            this.label ? this.label.attr({
                text: d,
                visibility: Wa
            }) : this.label = this.axis.chart.renderer.text(d, 0, 0, b.useHTML).css(b.style).attr({
                align: this.textAlign,
                rotation: b.rotation,
                visibility: Wa
            }).add(a);
        },
        setOffset: function(a, b) {
            var c, d = this, e = d.axis, f = e.chart, g = f.inverted, h = this.isNegative, i = e.translate(this.percent ? 100 : this.total, 0, 0, 0, 1), j = e.translate(0), k = wa(i - j), l = f.xAxis[0].translate(this.x) + a, m = f.plotHeight, n = {
                x: g ? h ? i : i - k : l,
                y: g ? m - l - b : h ? m - i - k : m - i,
                width: g ? k : b,
                height: g ? b : k
            }, o = this.label;
            o && (o.align(this.alignOptions, null, n), c = o.alignAttr, o.attr({
                visibility: this.options.crop === !1 || f.isInsidePlot(c.x, c.y) ? Ja ? "inherit" : Ya : Wa
            }));
        }
    }, R.prototype = {
        defaultOptions: {
            dateTimeLabelFormats: {
                millisecond: "%H:%M:%S.%L",
                second: "%H:%M:%S",
                minute: "%H:%M",
                hour: "%H:%M",
                day: "%e. %b",
                week: "%e. %b",
                month: "%b '%y",
                year: "%Y"
            },
            endOnTick: !1,
            gridLineColor: "#C0C0C0",
            labels: Eb,
            lineColor: "#C0D0E0",
            lineWidth: 1,
            minPadding: .01,
            maxPadding: .01,
            minorGridLineColor: "#E0E0E0",
            minorGridLineWidth: 1,
            minorTickColor: "#A0A0A0",
            minorTickLength: 2,
            minorTickPosition: "outside",
            startOfWeek: 1,
            startOnTick: !1,
            tickColor: "#C0D0E0",
            tickLength: 5,
            tickmarkPlacement: "between",
            tickPixelInterval: 100,
            tickPosition: "outside",
            tickWidth: 1,
            title: {
                align: "middle",
                style: {
                    color: "#4d759e",
                    fontWeight: "bold"
                }
            },
            type: "linear"
        },
        defaultYAxisOptions: {
            endOnTick: !0,
            gridLineWidth: 1,
            tickPixelInterval: 72,
            showLastLabel: !0,
            labels: {
                x: -8,
                y: 3
            },
            lineWidth: 0,
            maxPadding: .05,
            minPadding: .05,
            startOnTick: !0,
            tickWidth: 0,
            title: {
                rotation: 270,
                text: "Values"
            },
            stackLabels: {
                enabled: !1,
                formatter: function() {
                    return s(this.total, -1);
                },
                style: Eb.style
            }
        },
        defaultLeftAxisOptions: {
            labels: {
                x: -8,
                y: null
            },
            title: {
                rotation: 270
            }
        },
        defaultRightAxisOptions: {
            labels: {
                x: 8,
                y: null
            },
            title: {
                rotation: 90
            }
        },
        defaultBottomAxisOptions: {
            labels: {
                x: 0,
                y: 14
            },
            title: {
                rotation: 0
            }
        },
        defaultTopAxisOptions: {
            labels: {
                x: 0,
                y: -5
            },
            title: {
                rotation: 0
            }
        },
        init: function(a, b) {
            var c = b.isX, d = this;
            d.horiz = a.inverted ? !c : c, d.isXAxis = c, d.xOrY = c ? "x" : "y", d.opposite = b.opposite, 
            d.side = d.horiz ? d.opposite ? 0 : 2 : d.opposite ? 1 : 3, d.setOptions(b);
            var e = this.options, f = e.type, g = "datetime" === f;
            d.labelFormatter = e.labels.formatter || d.defaultLabelFormatter, d.userOptions = b, 
            d.minPixelPadding = 0, d.chart = a, d.reversed = e.reversed, d.zoomEnabled = e.zoomEnabled !== !1, 
            d.categories = e.categories || "category" === f, d.isLog = "logarithmic" === f, 
            d.isDatetimeAxis = g, d.isLinked = l(e.linkedTo), d.tickmarkOffset = d.categories && "between" === e.tickmarkPlacement ? .5 : 0, 
            d.ticks = {}, d.minorTicks = {}, d.plotLinesAndBands = [], d.alternateBands = {}, 
            d.len = 0, d.minRange = d.userMinRange = e.minRange || e.maxZoom, d.range = e.range, 
            d.offset = e.offset || 0, d.stacks = {}, d.oldStacks = {}, d.stackExtremes = {}, 
            d.max = null, d.min = null;
            var h, k = d.options.events;
            tb(d, a.axes) === -1 && (a.axes.push(d), a[c ? "xAxis" : "yAxis"].push(d)), d.series = d.series || [], 
            a.inverted && c && d.reversed === W && (d.reversed = !0), d.removePlotBand = d.removePlotBandOrLine, 
            d.removePlotLine = d.removePlotBandOrLine;
            for (h in k) yb(d, h, k[h]);
            d.isLog && (d.val2lin = i, d.lin2val = j);
        },
        setOptions: function(a) {
            this.options = b(this.defaultOptions, this.isXAxis ? {} : this.defaultYAxisOptions, [ this.defaultTopAxisOptions, this.defaultRightAxisOptions, this.defaultBottomAxisOptions, this.defaultLeftAxisOptions ][this.side], b(Z[this.isXAxis ? "xAxis" : "yAxis"], a));
        },
        update: function(c, d) {
            var e = this.chart;
            c = e.options[this.xOrY + "Axis"][this.options.index] = b(this.userOptions, c), 
            this.destroy(!0), this._addedPlotLB = this.userMin = this.userMax = W, this.init(e, a(c, {
                events: W
            })), e.isDirtyBox = !0, o(d, !0) && e.redraw();
        },
        remove: function(a) {
            var b = this.chart, c = this.xOrY + "Axis";
            ub(this.series, function(a) {
                a.remove(!1);
            }), k(b.axes, this), k(b[c], this), b.options[c].splice(this.options.index, 1), 
            ub(b[c], function(a, b) {
                a.options.index = b;
            }), this.destroy(), b.isDirtyBox = !0, o(a, !0) && b.redraw();
        },
        defaultLabelFormatter: function() {
            var a, b, c = this.axis, d = this.value, e = c.categories, f = this.dateTimeLabelFormat, g = Z.lang.numericSymbols, h = g && g.length, i = c.options.labels.format, j = c.isLog ? d : c.tickInterval;
            if (i) b = w(i, this); else if (e) b = d; else if (f) b = $(f, d); else if (h && j >= 1e3) for (;h-- && b === W; ) a = Math.pow(1e3, h + 1), 
            j >= a && null !== g[h] && (b = s(d / a, -1) + g[h]);
            return b === W && (b = d >= 1e3 ? s(d, 0) : s(d, -1)), b;
        },
        getSeriesExtremes: function() {
            var a = this, b = a.chart;
            a.hasVisibleSeries = !1, a.dataMin = a.dataMax = null, a.stackExtremes = {}, a.buildStacks(), 
            ub(a.series, function(c) {
                if (c.visible || !b.options.chart.ignoreHiddenSeries) {
                    var d, e, f, g = c.options, h = g.threshold;
                    a.hasVisibleSeries = !0, a.isLog && h <= 0 && (h = null), a.isXAxis ? (d = c.xData, 
                    d.length && (a.dataMin = va(o(a.dataMin, d[0]), D(d)), a.dataMax = ua(o(a.dataMax, d[0]), E(d)))) : (c.getExtremes(), 
                    f = c.dataMax, e = c.dataMin, l(e) && l(f) && (a.dataMin = va(o(a.dataMin, e), e), 
                    a.dataMax = ua(o(a.dataMax, f), f)), l(h) && (a.dataMin >= h ? (a.dataMin = h, a.ignoreMinPadding = !0) : a.dataMax < h && (a.dataMax = h, 
                    a.ignoreMaxPadding = !0)));
                }
            });
        },
        translate: function(a, b, c, d, e, f) {
            var g, i = this, j = i.len, k = 1, l = 0, m = d ? i.oldTransA : i.transA, n = d ? i.oldMin : i.min, o = i.minPixelPadding, p = (i.options.ordinal || i.isLog && e) && i.lin2val;
            return m || (m = i.transA), c && (k *= -1, l = j), i.reversed && (k *= -1, l -= k * j), 
            b ? (a = a * k + l, a -= o, g = a / m + n, p && (g = i.lin2val(g))) : (p && (a = i.val2lin(a)), 
            "between" === f && (f = .5), g = k * (a - n) * m + l + k * o + (h(f) ? m * f * i.pointRange : 0)), 
            g;
        },
        toPixels: function(a, b) {
            return this.translate(a, !1, !this.horiz, null, !0) + (b ? 0 : this.pos);
        },
        toValue: function(a, b) {
            return this.translate(a - (b ? 0 : this.pos), !0, !this.horiz, null, !0);
        },
        getPlotLinePath: function(a, b, c, d) {
            var e, f, g, h, i, j = this, k = j.chart, l = j.left, m = j.top, n = j.translate(a, null, null, c), o = c && k.oldChartHeight || k.chartHeight, p = c && k.oldChartWidth || k.chartWidth, q = j.transB;
            return e = g = ra(n + q), f = h = ra(o - n - q), isNaN(n) ? i = !0 : j.horiz ? (f = m, 
            h = o - j.bottom, (e < l || e > l + j.width) && (i = !0)) : (e = l, g = p - j.right, 
            (f < m || f > m + j.height) && (i = !0)), i && !d ? null : k.renderer.crispLine([ _a, e, f, ab, g, h ], b || 0);
        },
        getPlotBandPath: function(a, b) {
            var c = this.getPlotLinePath(b), d = this.getPlotLinePath(a);
            return d && c ? d.push(c[4], c[5], c[1], c[2]) : d = null, d;
        },
        getLinearTickPositions: function(a, b, c) {
            var d, e, f = I(sa(b / a) * a), g = I(ta(c / a) * a), h = [];
            for (d = f; d <= g && (h.push(d), d = I(d + a), d !== e); ) e = d;
            return h;
        },
        getLogTickPositions: function(a, b, c, d) {
            var e = this, f = e.options, g = e.len, h = [];
            if (d || (e._minorAutoInterval = null), a >= .5) a = ra(a), h = e.getLinearTickPositions(a, b, c); else if (a >= .08) {
                var k, l, m, n, p, q, r, s = sa(b);
                for (k = a > .3 ? [ 1, 2, 4 ] : a > .15 ? [ 1, 2, 4, 6, 8 ] : [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ], 
                l = s; l < c + 1 && !r; l++) for (n = k.length, m = 0; m < n && !r; m++) p = i(j(l) * k[m]), 
                p > b && (!d || q <= c) && h.push(q), q > c && (r = !0), q = p;
            } else {
                var t = j(b), u = j(c), v = f[d ? "minorTickInterval" : "tickInterval"], w = "auto" === v ? null : v, z = f.tickPixelInterval / (d ? 5 : 1), A = d ? g / e.tickPositions.length : g;
                a = o(w, e._minorAutoInterval, (u - t) * z / (A || 1)), a = y(a, null, x(a)), h = xb(e.getLinearTickPositions(a, t, u), i), 
                d || (e._minorAutoInterval = a / 5);
            }
            return d || (e.tickInterval = a), h;
        },
        getMinorTickPositions: function() {
            var a, b, c, d = this, e = d.options, f = d.tickPositions, g = d.minorTickInterval, h = [];
            if (d.isLog) for (c = f.length, b = 1; b < c; b++) h = h.concat(d.getLogTickPositions(g, f[b - 1], f[b], !0)); else if (d.isDatetimeAxis && "auto" === e.minorTickInterval) h = h.concat(A(z(g), d.min, d.max, e.startOfWeek)), 
            h[0] < d.min && h.shift(); else for (a = d.min + (f[0] - d.min) % g; a <= d.max; a += g) h.push(a);
            return h;
        },
        adjustForMinRange: function() {
            var a, b, c, d, e, f, g, h, i = this, j = i.options, k = i.min, m = i.max, n = i.dataMax - i.dataMin >= i.minRange;
            if (i.isXAxis && i.minRange === W && !i.isLog && (l(j.min) || l(j.max) ? i.minRange = null : (ub(i.series, function(a) {
                for (e = a.xData, f = a.xIncrement ? 1 : e.length - 1, c = f; c > 0; c--) d = e[c] - e[c - 1], 
                (b === W || d < b) && (b = d);
            }), i.minRange = va(5 * b, i.dataMax - i.dataMin))), m - k < i.minRange) {
                var p = i.minRange;
                a = (p - m + k) / 2, g = [ k - a, o(j.min, k - a) ], n && (g[2] = i.dataMin), k = E(g), 
                h = [ k + p, o(j.max, k + p) ], n && (h[2] = i.dataMax), m = D(h), m - k < p && (g[0] = m - p, 
                g[1] = o(j.min, m - p), k = E(g));
            }
            i.min = k, i.max = m;
        },
        setAxisTranslation: function(a) {
            var b, c, d = this, f = d.max - d.min, g = 0, h = 0, i = 0, j = d.linkedParent, k = d.transA;
            d.isXAxis && (j ? (h = j.minPointOffset, i = j.pointRangePadding) : ub(d.series, function(a) {
                var c = a.pointRange, d = a.options.pointPlacement, j = a.closestPointRange;
                c > f && (c = 0), g = ua(g, c), h = ua(h, e(d) ? 0 : c / 2), i = ua(i, "on" === d ? 0 : c), 
                !a.noSharedTooltip && l(j) && (b = l(b) ? va(b, j) : j);
            }), c = d.ordinalSlope && b ? d.ordinalSlope / b : 1, d.minPointOffset = h *= c, 
            d.pointRangePadding = i *= c, d.pointRange = va(g, f), d.closestPointRange = b), 
            a && (d.oldTransA = k), d.translationSlope = d.transA = k = d.len / (f + i || 1), 
            d.transB = d.horiz ? d.left : d.bottom, d.minPixelPadding = k * h;
        },
        setTickPositions: function(a) {
            var b, c, d, e, f = this, g = f.chart, h = f.options, j = f.isLog, k = f.isDatetimeAxis, m = f.isXAxis, n = f.isLinked, p = f.options.tickPositioner, q = h.maxPadding, r = h.minPadding, s = h.tickInterval, t = h.minTickInterval, u = h.tickPixelInterval, v = f.categories;
            if (n ? (f.linkedParent = g[m ? "xAxis" : "yAxis"][h.linkedTo], c = f.linkedParent.getExtremes(), 
            f.min = o(c.min, c.dataMin), f.max = o(c.max, c.dataMax), h.type !== f.linkedParent.options.type && H(11, 1)) : (f.min = o(f.userMin, h.min, f.dataMin), 
            f.max = o(f.userMax, h.max, f.dataMax)), j && (!a && va(f.min, o(f.dataMin, f.min)) <= 0 && H(10, 1), 
            f.min = I(i(f.min)), f.max = I(i(f.max))), f.range && (f.userMin = f.min = ua(f.min, f.max - f.range), 
            f.userMax = f.max, a && (f.range = null)), f.beforePadding && f.beforePadding(), 
            f.adjustForMinRange(), v || f.usePercentage || n || !l(f.min) || !l(f.max) || (b = f.max - f.min, 
            b && (l(h.min) || l(f.userMin) || !r || !(f.dataMin < 0) && f.ignoreMinPadding || (f.min -= b * r), 
            l(h.max) || l(f.userMax) || !q || !(f.dataMax > 0) && f.ignoreMaxPadding || (f.max += b * q))), 
            f.min === f.max || void 0 === f.min || void 0 === f.max ? f.tickInterval = 1 : n && !s && u === f.linkedParent.options.tickPixelInterval ? f.tickInterval = f.linkedParent.tickInterval : (f.tickInterval = o(s, v ? 1 : (f.max - f.min) * u / ua(f.len, u)), 
            !l(s) && f.len < u && !this.isRadial && (e = !0, f.tickInterval /= 4)), m && !a && ub(f.series, function(a) {
                a.processData(f.min !== f.oldMin || f.max !== f.oldMax);
            }), f.setAxisTranslation(!0), f.beforeSetTickPositions && f.beforeSetTickPositions(), 
            f.postProcessTickInterval && (f.tickInterval = f.postProcessTickInterval(f.tickInterval)), 
            f.pointRange && (f.tickInterval = ua(f.pointRange, f.tickInterval)), !s && f.tickInterval < t && (f.tickInterval = t), 
            k || j || s || (f.tickInterval = y(f.tickInterval, null, x(f.tickInterval), h)), 
            f.minorTickInterval = "auto" === h.minorTickInterval && f.tickInterval ? f.tickInterval / 5 : h.minorTickInterval, 
            f.tickPositions = d = h.tickPositions ? [].concat(h.tickPositions) : p && p.apply(f, [ f.min, f.max ]), 
            d || (!f.ordinalPositions && (f.max - f.min) / f.tickInterval > ua(2 * f.len, 200) && H(19, !0), 
            d = k ? (f.getNonLinearTimeTicks || A)(z(f.tickInterval, h.units), f.min, f.max, h.startOfWeek, f.ordinalPositions, f.closestPointRange, !0) : j ? f.getLogTickPositions(f.tickInterval, f.min, f.max) : f.getLinearTickPositions(f.tickInterval, f.min, f.max), 
            e && d.splice(1, d.length - 2), f.tickPositions = d), !n) {
                var w, B = d[0], C = d[d.length - 1], D = f.minPointOffset || 0;
                h.startOnTick ? f.min = B : f.min - D > B && d.shift(), h.endOnTick ? f.max = C : f.max + D < C && d.pop(), 
                1 === d.length && (w = .001, f.min -= w, f.max += w);
            }
        },
        setMaxTicks: function() {
            var a = this.chart, b = a.maxTicks || {}, c = this.tickPositions, d = this._maxTicksKey = [ this.xOrY, this.pos, this.len ].join("-");
            !this.isLinked && !this.isDatetimeAxis && c && c.length > (b[d] || 0) && this.options.alignTicks !== !1 && (b[d] = c.length), 
            a.maxTicks = b;
        },
        adjustTickAmount: function() {
            var a = this, b = a.chart, c = a._maxTicksKey, d = a.tickPositions, e = b.maxTicks;
            if (e && e[c] && !a.isDatetimeAxis && !a.categories && !a.isLinked && a.options.alignTicks !== !1) {
                var f, g = a.tickAmount, h = d.length;
                if (a.tickAmount = f = e[c], h < f) {
                    for (;d.length < f; ) d.push(I(d[d.length - 1] + a.tickInterval));
                    a.transA *= (h - 1) / (f - 1), a.max = d[d.length - 1];
                }
                l(g) && f !== g && (a.isDirty = !0);
            }
        },
        setScale: function() {
            var a, b, c, d, e = this, f = e.stacks;
            if (e.oldMin = e.min, e.oldMax = e.max, e.oldAxisLength = e.len, e.setAxisSize(), 
            d = e.len !== e.oldAxisLength, ub(e.series, function(a) {
                (a.isDirtyData || a.isDirty || a.xAxis.isDirty) && (c = !0);
            }), d || c || e.isLinked || e.forceRedraw || e.userMin !== e.oldUserMin || e.userMax !== e.oldUserMax) {
                if (!e.isXAxis) for (a in f) delete f[a];
                e.forceRedraw = !1, e.getSeriesExtremes(), e.setTickPositions(), e.oldUserMin = e.userMin, 
                e.oldUserMax = e.userMax, e.isDirty || (e.isDirty = d || e.min !== e.oldMin || e.max !== e.oldMax);
            } else if (!e.isXAxis) {
                e.oldStacks && (f = e.stacks = e.oldStacks);
                for (a in f) for (b in f[a]) f[a][b].cum = f[a][b].total;
            }
            e.setMaxTicks();
        },
        setExtremes: function(b, c, d, e, f) {
            var g = this, h = g.chart;
            d = o(d, !0), f = a(f, {
                min: b,
                max: c
            }), Ab(g, "setExtremes", f, function() {
                g.userMin = b, g.userMax = c, g.eventArgs = f, g.isDirtyExtremes = !0, d && h.redraw(e);
            });
        },
        zoom: function(a, b) {
            return this.allowZoomOutside || (l(this.dataMin) && a <= this.dataMin && (a = W), 
            l(this.dataMax) && b >= this.dataMax && (b = W)), this.displayBtn = a !== W || b !== W, 
            this.setExtremes(a, b, !1, W, {
                trigger: "zoom"
            }), !0;
        },
        setAxisSize: function() {
            var a, b, c, d, e = this.chart, f = this.options, g = f.offsetLeft || 0, h = f.offsetRight || 0, i = this.horiz;
            this.left = d = o(f.left, e.plotLeft + g), this.top = c = o(f.top, e.plotTop), this.width = a = o(f.width, e.plotWidth - g + h), 
            this.height = b = o(f.height, e.plotHeight), this.bottom = e.chartHeight - b - c, 
            this.right = e.chartWidth - a - d, this.len = ua(i ? a : b, 0), this.pos = i ? d : c;
        },
        getExtremes: function() {
            var a = this, b = a.isLog;
            return {
                min: b ? I(j(a.min)) : a.min,
                max: b ? I(j(a.max)) : a.max,
                dataMin: a.dataMin,
                dataMax: a.dataMax,
                userMin: a.userMin,
                userMax: a.userMax
            };
        },
        getThreshold: function(a) {
            var b = this, c = b.isLog, d = c ? j(b.min) : b.min, e = c ? j(b.max) : b.max;
            return d > a || null === a ? a = d : e < a && (a = e), b.translate(a, 0, 1, 0, 1);
        },
        addPlotBand: function(a) {
            this.addPlotBandOrLine(a, "plotBands");
        },
        addPlotLine: function(a) {
            this.addPlotBandOrLine(a, "plotLines");
        },
        addPlotBandOrLine: function(a, b) {
            var c = new P(this, a).render(), d = this.userOptions;
            return c && (b && (d[b] = d[b] || [], d[b].push(a)), this.plotLinesAndBands.push(c)), 
            c;
        },
        autoLabelAlign: function(a) {
            var b, c = (o(a, 0) - 90 * this.side + 720) % 360;
            return b = c > 15 && c < 165 ? "right" : c > 195 && c < 345 ? "left" : "center";
        },
        getOffset: function() {
            var a, b, c, d, e, f, g, h, i, j, k, m, n, p = this, q = p.chart, r = q.renderer, s = p.options, t = p.tickPositions, u = p.ticks, v = p.horiz, w = p.side, x = q.inverted ? [ 1, 0, 3, 2 ][w] : w, y = 0, z = 0, A = s.title, B = s.labels, C = 0, D = q.axisOffset, E = q.clipOffset, F = [ -1, 1, 1, -1 ][w], G = 1, H = o(B.maxStaggerLines, 5);
            if (p.hasData = a = p.hasVisibleSeries || l(p.min) && l(p.max) && !!t, p.showAxis = b = a || o(s.showEmpty, !0), 
            p.staggerLines = p.horiz && B.staggerLines, p.axisGroup || (p.gridGroup = r.g("grid").attr({
                zIndex: s.gridZIndex || 1
            }).add(), p.axisGroup = r.g("axis").attr({
                zIndex: s.zIndex || 2
            }).add(), p.labelGroup = r.g("axis-labels").attr({
                zIndex: B.zIndex || 7
            }).add()), a || p.isLinked) {
                if (p.labelAlign = o(B.align || p.autoLabelAlign(B.rotation)), ub(t, function(a) {
                    u[a] ? u[a].addLabel() : u[a] = new O(p, a);
                }), p.horiz && !p.staggerLines && H && !B.rotation) {
                    for (f = p.reversed ? [].concat(t).reverse() : t; G < H; ) {
                        for (g = [], h = !1, e = 0; e < f.length; e++) i = f[e], j = u[i].label && u[i].label.getBBox(), 
                        m = j ? j.width : 0, n = e % G, m && (k = p.translate(i), g[n] !== W && k < g[n] && (h = !0), 
                        g[n] = k + m);
                        if (!h) break;
                        G++;
                    }
                    G > 1 && (p.staggerLines = G);
                }
                ub(t, function(a) {
                    0 !== w && 2 !== w && {
                        1: "left",
                        3: "right"
                    }[w] !== p.labelAlign || (C = ua(u[a].getLabelSize(), C));
                }), p.staggerLines && (C *= p.staggerLines, p.labelOffset = C);
            } else for (d in u) u[d].destroy(), delete u[d];
            A && A.text && A.enabled !== !1 && (p.axisTitle || (p.axisTitle = r.text(A.text, 0, 0, A.useHTML).attr({
                zIndex: 7,
                rotation: A.rotation || 0,
                align: A.textAlign || {
                    low: "left",
                    middle: "center",
                    high: "right"
                }[A.align]
            }).css(A.style).add(p.axisGroup), p.axisTitle.isNew = !0), b && (y = p.axisTitle.getBBox()[v ? "height" : "width"], 
            z = o(A.margin, v ? 5 : 10), c = A.offset), p.axisTitle[b ? "show" : "hide"]()), 
            p.offset = F * o(s.offset, D[w]), p.axisTitleMargin = o(c, C + z + (2 !== w && C && F * s.labels[v ? "y" : "x"])), 
            D[w] = ua(D[w], p.axisTitleMargin + y + F * p.offset), E[x] = ua(E[x], 2 * sa(s.lineWidth / 2));
        },
        getLinePath: function(a) {
            var b = this.chart, c = this.opposite, d = this.offset, e = this.horiz, f = this.left + (c ? this.width : 0) + d, g = b.chartHeight - this.bottom - (c ? this.height : 0) + d;
            return c && (a *= -1), b.renderer.crispLine([ _a, e ? this.left : f, e ? g : this.top, ab, e ? b.chartWidth - this.right : f, e ? g : b.chartHeight - this.bottom ], a);
        },
        getTitlePosition: function() {
            var a = this.horiz, b = this.left, c = this.top, e = this.len, f = this.options.title, g = a ? b : c, h = this.opposite, i = this.offset, j = d(f.style.fontSize || 12), k = {
                low: g + (a ? 0 : e),
                middle: g + e / 2,
                high: g + (a ? e : 0)
            }[f.align], l = (a ? c + this.height : b) + (a ? 1 : -1) * (h ? -1 : 1) * this.axisTitleMargin + (2 === this.side ? j : 0);
            return {
                x: a ? k : l + (h ? this.width : 0) + i + (f.x || 0),
                y: a ? l - (h ? this.height : 0) + i : k + (f.y || 0)
            };
        },
        render: function() {
            var a, b, c, d = this, e = d.chart, f = e.renderer, g = d.options, h = d.isLog, i = d.isLinked, k = d.tickPositions, m = d.axisTitle, n = d.stacks, o = d.ticks, p = d.minorTicks, q = d.alternateBands, r = g.stackLabels, s = g.alternateGridColor, t = d.tickmarkOffset, u = g.lineWidth, v = e.hasRendered, w = v && l(d.oldMin) && !isNaN(d.oldMin), x = d.hasData, y = d.showAxis;
            if (ub([ o, p, q ], function(a) {
                var b;
                for (b in a) a[b].isActive = !1;
            }), (x || i) && (d.minorTickInterval && !d.categories && ub(d.getMinorTickPositions(), function(a) {
                p[a] || (p[a] = new O(d, a, "minor")), w && p[a].isNew && p[a].render(null, !0), 
                p[a].render(null, !1, 1);
            }), k.length && (ub(k.slice(1).concat([ k[0] ]), function(a, b) {
                b = b === k.length - 1 ? 0 : b + 1, (!i || a >= d.min && a <= d.max) && (o[a] || (o[a] = new O(d, a)), 
                w && o[a].isNew && o[a].render(b, !0), o[a].render(b, !1, 1));
            }), t && 0 === d.min && (o[-1] || (o[-1] = new O(d, (-1), null, (!0))), o[-1].render(-1))), 
            s && ub(k, function(a, e) {
                e % 2 === 0 && a < d.max && (q[a] || (q[a] = new P(d)), b = a + t, c = k[e + 1] !== W ? k[e + 1] + t : d.max, 
                q[a].options = {
                    from: h ? j(b) : b,
                    to: h ? j(c) : c,
                    color: s
                }, q[a].render(), q[a].isActive = !0);
            }), d._addedPlotLB || (ub((g.plotLines || []).concat(g.plotBands || []), function(a) {
                d.addPlotBandOrLine(a);
            }), d._addedPlotLB = !0)), ub([ o, p, q ], function(a) {
                var b, c, d = [], f = _ ? _.duration || 500 : 0, g = function() {
                    for (c = d.length; c--; ) a[d[c]] && !a[d[c]].isActive && (a[d[c]].destroy(), delete a[d[c]]);
                };
                for (b in a) a[b].isActive || (a[b].render(b, !1, 0), a[b].isActive = !1, d.push(b));
                a !== q && e.hasRendered && f ? f && setTimeout(g, f) : g();
            }), u && (a = d.getLinePath(u), d.axisLine ? d.axisLine.animate({
                d: a
            }) : d.axisLine = f.path(a).attr({
                stroke: g.lineColor,
                "stroke-width": u,
                zIndex: 7
            }).add(d.axisGroup), d.axisLine[y ? "show" : "hide"]()), m && y && (m[m.isNew ? "attr" : "animate"](d.getTitlePosition()), 
            m.isNew = !1), r && r.enabled) {
                var z, A, B, C = d.stackTotalGroup;
                C || (d.stackTotalGroup = C = f.g("stack-labels").attr({
                    visibility: Ya,
                    zIndex: 6
                }).add()), C.translate(e.plotLeft, e.plotTop);
                for (z in n) {
                    A = n[z];
                    for (B in A) A[B].render(C);
                }
            }
            d.isDirty = !1;
        },
        removePlotBandOrLine: function(a) {
            for (var b = this.plotLinesAndBands, c = this.options, d = this.userOptions, e = b.length; e--; ) b[e].id === a && b[e].destroy();
            ub([ c.plotLines || [], d.plotLines || [], c.plotBands || [], d.plotBands || [] ], function(b) {
                for (e = b.length; e--; ) b[e].id === a && k(b, b[e]);
            });
        },
        setTitle: function(a, b) {
            this.update({
                title: a
            }, b);
        },
        redraw: function() {
            var a = this, b = a.chart, c = b.pointer;
            c.reset && c.reset(!0), a.render(), ub(a.plotLinesAndBands, function(a) {
                a.render();
            }), ub(a.series, function(a) {
                a.isDirty = !0;
            });
        },
        buildStacks: function() {
            var a = this.series, b = a.length;
            if (!this.isXAxis) {
                for (;b--; ) a[b].setStackedPoints();
                if (this.usePercentage) for (b = 0; b < a.length; b++) a[b].setPercentStacks();
            }
        },
        setCategories: function(a, b) {
            this.update({
                categories: a
            }, b);
        },
        destroy: function(a) {
            var b, c, d = this, e = d.stacks, f = d.plotLinesAndBands;
            a || zb(d);
            for (b in e) F(e[b]), e[b] = null;
            for (ub([ d.ticks, d.minorTicks, d.alternateBands ], function(a) {
                F(a);
            }), c = f.length; c--; ) f[c].destroy();
            ub([ "stackTotalGroup", "axisLine", "axisGroup", "gridGroup", "labelGroup", "axisTitle" ], function(a) {
                d[a] && (d[a] = d[a].destroy());
            });
        }
    }, S.prototype = {
        init: function(a, b) {
            var c = b.borderWidth, e = b.style, f = d(e.padding);
            this.chart = a, this.options = b, this.crosshairs = [], this.now = {
                x: 0,
                y: 0
            }, this.isHidden = !0, this.label = a.renderer.label("", 0, 0, b.shape, null, null, b.useHTML, null, "tooltip").attr({
                padding: f,
                fill: b.backgroundColor,
                "stroke-width": c,
                r: b.borderRadius,
                zIndex: 8
            }).css(e).css({
                padding: 0
            }).add().attr({
                y: -999
            }), La || this.label.shadow(b.shadow), this.shared = b.shared;
        },
        destroy: function() {
            ub(this.crosshairs, function(a) {
                a && a.destroy();
            }), this.label && (this.label = this.label.destroy()), clearTimeout(this.hideTimer), 
            clearTimeout(this.tooltipTimeout);
        },
        move: function(b, c, d, e) {
            var f = this, g = f.now, h = f.options.animation !== !1 && !f.isHidden;
            a(g, {
                x: h ? (2 * g.x + b) / 3 : b,
                y: h ? (g.y + c) / 2 : c,
                anchorX: h ? (2 * g.anchorX + d) / 3 : d,
                anchorY: h ? (g.anchorY + e) / 2 : e
            }), f.label.attr(g), h && (wa(b - g.x) > 1 || wa(c - g.y) > 1) && (clearTimeout(this.tooltipTimeout), 
            this.tooltipTimeout = setTimeout(function() {
                f && f.move(b, c, d, e);
            }, 32));
        },
        hide: function() {
            var a, b = this;
            clearTimeout(this.hideTimer), this.isHidden || (a = this.chart.hoverPoints, this.hideTimer = setTimeout(function() {
                b.label.fadeOut(), b.isHidden = !0;
            }, o(this.options.hideDelay, 500)), a && ub(a, function(a) {
                a.setState();
            }), this.chart.hoverPoints = null);
        },
        hideCrosshairs: function() {
            ub(this.crosshairs, function(a) {
                a && a.hide();
            });
        },
        getAnchor: function(a, b) {
            var c, d, e = this.chart, f = e.inverted, g = e.plotTop, h = 0, i = 0;
            return a = n(a), c = a[0].tooltipPos, this.followPointer && b && (b.chartX === W && (b = e.pointer.normalize(b)), 
            c = [ b.chartX - e.plotLeft, b.chartY - g ]), c || (ub(a, function(a) {
                d = a.series.yAxis, h += a.plotX, i += (a.plotLow ? (a.plotLow + a.plotHigh) / 2 : a.plotY) + (!f && d ? d.top - g : 0);
            }), h /= a.length, i /= a.length, c = [ f ? e.plotWidth - i : h, this.shared && !f && a.length > 1 && b ? b.chartY - g : f ? e.plotHeight - h : i ]), 
            xb(c, ra);
        },
        getPosition: function(a, b, c) {
            var d, e = this.chart, f = e.plotLeft, g = e.plotTop, h = e.plotWidth, i = e.plotHeight, j = o(this.options.distance, 12), k = c.plotX, l = c.plotY, m = k + f + (e.inverted ? j : -a - j), n = l - b + g + 15;
            return m < 7 && (m = f + ua(k, 0) + j), m + a > f + h && (m -= m + a - (f + h), 
            n = l - b + g - j, d = !0), n < g + 5 && (n = g + 5, d && l >= n && l <= n + b && (n = l + g + j)), 
            n + b > g + i && (n = ua(g, g + i - b - j)), {
                x: m,
                y: n
            };
        },
        defaultFormatter: function(a) {
            var b, c = this.points || n(this), d = c[0].series;
            return b = [ d.tooltipHeaderFormatter(c[0]) ], ub(c, function(a) {
                d = a.series, b.push(d.tooltipFormatter && d.tooltipFormatter(a) || a.point.tooltipFormatter(d.tooltipOptions.pointFormat));
            }), b.push(a.options.footerFormat || ""), b.join("");
        },
        refresh: function(a, b) {
            var c, d, e, f, g, h, j = this, k = j.chart, l = j.label, m = j.options, p = {}, q = [], r = m.formatter || j.defaultFormatter, s = k.hoverPoints, t = m.crosshairs, u = j.shared;
            if (clearTimeout(this.hideTimer), j.followPointer = n(a)[0].series.tooltipOptions.followPointer, 
            e = j.getAnchor(a, b), c = e[0], d = e[1], !u || a.series && a.series.noSharedTooltip ? p = a.getLabelConfig() : (k.hoverPoints = a, 
            s && ub(s, function(a) {
                a.setState();
            }), ub(a, function(a) {
                a.setState(db), q.push(a.getLabelConfig());
            }), p = {
                x: a[0].category,
                y: a[0].y
            }, p.points = q, a = a[0]), f = r.call(p, j), h = a.series, f === !1 ? this.hide() : (j.isHidden && (Db(l), 
            l.attr("opacity", 1).show()), l.attr({
                text: f
            }), g = m.borderColor || a.color || h.color || "#606060", l.attr({
                stroke: g
            }), j.updatePosition({
                plotX: c,
                plotY: d
            }), this.isHidden = !1), t) {
                t = n(t);
                for (var v, w, x, y, z, A = t.length; A--; ) z = a.series, x = z[A ? "yAxis" : "xAxis"], 
                t[A] && x && (y = A ? o(a.stackY, a.y) : a.x, x.isLog && (y = i(y)), 1 === A && z.modifyValue && (y = z.modifyValue(y)), 
                v = x.getPlotLinePath(y, 1), j.crosshairs[A] ? j.crosshairs[A].attr({
                    d: v,
                    visibility: Ya
                }) : (w = {
                    "stroke-width": t[A].width || 1,
                    stroke: t[A].color || "#C0C0C0",
                    zIndex: t[A].zIndex || 2
                }, t[A].dashStyle && (w.dashstyle = t[A].dashStyle), j.crosshairs[A] = k.renderer.path(v).attr(w).add()));
            }
            Ab(k, "tooltipRefresh", {
                text: f,
                x: c + k.plotLeft,
                y: d + k.plotTop,
                borderColor: g
            });
        },
        updatePosition: function(a) {
            var b = this.chart, c = this.label, d = (this.options.positioner || this.getPosition).call(this, c.width, c.height, a);
            this.move(ra(d.x), ra(d.y), a.plotX + b.plotLeft, a.plotY + b.plotTop);
        }
    }, T.prototype = {
        init: function(a, b) {
            var c, d, e = b.chart, f = e.events, g = La ? "" : e.zoomType, h = a.inverted;
            this.options = b, this.chart = a, this.zoomX = c = /x/.test(g), this.zoomY = d = /y/.test(g), 
            this.zoomHor = c && !h || d && h, this.zoomVert = d && !h || c && h, this.runChartClick = f && !!f.click, 
            this.pinchDown = [], this.lastValidTouch = {}, b.tooltip.enabled && (a.tooltip = new S(a, b.tooltip)), 
            this.setDOMEvents();
        },
        normalize: function(b, c) {
            var d, e, f;
            return b = b || pa.event, b.target || (b.target = b.srcElement), b = Bb(b), f = b.touches ? b.touches.item(0) : b, 
            c || (this.chartPosition = c = wb(this.chart.container)), f.pageX === W ? (d = ua(b.x, b.clientX - c.left), 
            e = b.y) : (d = f.pageX - c.left, e = f.pageY - c.top), a(b, {
                chartX: ra(d),
                chartY: ra(e)
            });
        },
        getCoordinates: function(a) {
            var b = {
                xAxis: [],
                yAxis: []
            };
            return ub(this.chart.axes, function(c) {
                b[c.isXAxis ? "xAxis" : "yAxis"].push({
                    axis: c,
                    value: c.toValue(a[c.horiz ? "chartX" : "chartY"])
                });
            }), b;
        },
        getIndex: function(a) {
            var b = this.chart;
            return b.inverted ? b.plotHeight + b.plotTop - a.chartY : a.chartX - b.plotLeft;
        },
        runPointActions: function(a) {
            var b, c, d, e, f, g = this, h = g.chart, i = h.series, j = h.tooltip, k = h.hoverPoint, l = h.hoverSeries, m = h.chartWidth, n = g.getIndex(a);
            if (j && g.options.tooltip.shared && (!l || !l.noSharedTooltip)) {
                for (c = [], d = i.length, e = 0; e < d; e++) i[e].visible && i[e].options.enableMouseTracking !== !1 && !i[e].noSharedTooltip && i[e].tooltipPoints.length && (b = i[e].tooltipPoints[n], 
                b && b.series && (b._dist = wa(n - b.clientX), m = va(m, b._dist), c.push(b)));
                for (d = c.length; d--; ) c[d]._dist > m && c.splice(d, 1);
                c.length && c[0].clientX !== g.hoverX && (j.refresh(c, a), g.hoverX = c[0].clientX);
            }
            l && l.tracker ? (b = l.tooltipPoints[n], b && b !== k && b.onMouseOver(a)) : j && j.followPointer && !j.isHidden && (f = j.getAnchor([ {} ], a), 
            j.updatePosition({
                plotX: f[0],
                plotY: f[1]
            }));
        },
        reset: function(a) {
            var b = this, c = b.chart, d = c.hoverSeries, e = c.hoverPoint, f = c.tooltip, g = f && f.shared ? c.hoverPoints : e;
            a = a && f && g, a && n(g)[0].plotX === W && (a = !1), a ? f.refresh(g) : (e && e.onMouseOut(), 
            d && d.onMouseOut(), f && (f.hide(), f.hideCrosshairs()), b.hoverX = null);
        },
        scaleGroups: function(a, b) {
            var c, d = this.chart;
            ub(d.series, function(e) {
                c = a || e.getPlotBox(), e.xAxis && e.xAxis.zoomEnabled && (e.group.attr(c), e.markerGroup && (e.markerGroup.attr(c), 
                e.markerGroup.clip(b ? d.clipRect : null)), e.dataLabelsGroup && e.dataLabelsGroup.attr(c));
            }), d.clipRect.attr(b || d.clipBox);
        },
        pinchTranslateDirection: function(a, b, c, d, e, f, g) {
            var h, i, j, k, l, m, n = this.chart, o = a ? "x" : "y", p = a ? "X" : "Y", q = "chart" + p, r = a ? "width" : "height", s = n["plot" + (a ? "Left" : "Top")], t = 1, u = n.inverted, v = n.bounds[a ? "h" : "v"], w = 1 === b.length, x = b[0][q], y = c[0][q], z = !w && b[1][q], A = !w && c[1][q], B = function() {
                !w && wa(x - z) > 20 && (t = wa(y - A) / wa(x - z)), j = (s - y) / t + x, h = n["plot" + (a ? "Width" : "Height")] / t;
            };
            B(), i = j, i < v.min ? (i = v.min, k = !0) : i + h > v.max && (i = v.max - h, k = !0), 
            k ? (y -= .8 * (y - g[o][0]), w || (A -= .8 * (A - g[o][1])), B()) : g[o] = [ y, A ], 
            u || (f[o] = j - s, f[r] = h), m = u ? a ? "scaleY" : "scaleX" : "scale" + p, l = u ? 1 / t : t, 
            e[r] = h, e[o] = i, d[m] = t, d["translate" + p] = l * s + (y - l * x);
        },
        pinch: function(b) {
            var c = this, d = c.chart, e = c.pinchDown, f = d.tooltip && d.tooltip.options.followTouchMove, g = b.touches, h = g.length, i = c.lastValidTouch, j = c.zoomHor || c.pinchHor, k = c.zoomVert || c.pinchVert, l = j || k, m = c.selectionMarker, n = {}, o = 1 === h && (c.inClass(b.target, Xa + "tracker") && d.runTrackerClick || d.runChartClick), p = {};
            !l && !f || o || b.preventDefault(), xb(g, function(a) {
                return c.normalize(a);
            }), "touchstart" === b.type ? (ub(g, function(a, b) {
                e[b] = {
                    chartX: a.chartX,
                    chartY: a.chartY
                };
            }), i.x = [ e[0].chartX, e[1] && e[1].chartX ], i.y = [ e[0].chartY, e[1] && e[1].chartY ], 
            ub(d.axes, function(a) {
                if (a.zoomEnabled) {
                    var b = d.bounds[a.horiz ? "h" : "v"], c = a.minPixelPadding, e = a.toPixels(a.dataMin), f = a.toPixels(a.dataMax), g = va(e, f), h = ua(e, f);
                    b.min = va(a.pos, g - c), b.max = ua(a.pos + a.len, h + c);
                }
            })) : e.length && (m || (c.selectionMarker = m = a({
                destroy: Pa
            }, d.plotBox)), j && c.pinchTranslateDirection(!0, e, g, n, m, p, i), k && c.pinchTranslateDirection(!1, e, g, n, m, p, i), 
            c.hasPinched = l, c.scaleGroups(n, p), !l && f && 1 === h && this.runPointActions(c.normalize(b)));
        },
        dragStart: function(a) {
            var b = this.chart;
            b.mouseIsDown = a.type, b.cancelClick = !1, b.mouseDownX = this.mouseDownX = a.chartX, 
            b.mouseDownY = this.mouseDownY = a.chartY;
        },
        drag: function(a) {
            var b, c, d = this.chart, e = d.options.chart, f = a.chartX, g = a.chartY, h = this.zoomHor, i = this.zoomVert, j = d.plotLeft, k = d.plotTop, l = d.plotWidth, m = d.plotHeight, n = this.mouseDownX, o = this.mouseDownY;
            f < j ? f = j : f > j + l && (f = j + l), g < k ? g = k : g > k + m && (g = k + m), 
            this.hasDragged = Math.sqrt(Math.pow(n - f, 2) + Math.pow(o - g, 2)), this.hasDragged > 10 && (b = d.isInsidePlot(n - j, o - k), 
            d.hasCartesianSeries && (this.zoomX || this.zoomY) && b && (this.selectionMarker || (this.selectionMarker = d.renderer.rect(j, k, h ? 1 : l, i ? 1 : m, 0).attr({
                fill: e.selectionMarkerFill || "rgba(69,114,167,0.25)",
                zIndex: 7
            }).add())), this.selectionMarker && h && (c = f - n, this.selectionMarker.attr({
                width: wa(c),
                x: (c > 0 ? 0 : c) + n
            })), this.selectionMarker && i && (c = g - o, this.selectionMarker.attr({
                height: wa(c),
                y: (c > 0 ? 0 : c) + o
            })), b && !this.selectionMarker && e.panning && d.pan(a, e.panning));
        },
        drop: function(b) {
            var c = this.chart, d = this.hasPinched;
            if (this.selectionMarker) {
                var e, f = {
                    xAxis: [],
                    yAxis: [],
                    originalEvent: b.originalEvent || b
                }, g = this.selectionMarker, h = g.x, i = g.y;
                (this.hasDragged || d) && (ub(c.axes, function(a) {
                    if (a.zoomEnabled) {
                        var b = a.horiz, c = a.toValue(b ? h : i), d = a.toValue(b ? h + g.width : i + g.height);
                        isNaN(c) || isNaN(d) || (f[a.xOrY + "Axis"].push({
                            axis: a,
                            min: va(c, d),
                            max: ua(c, d)
                        }), e = !0);
                    }
                }), e && Ab(c, "selection", f, function(b) {
                    c.zoom(a(b, d ? {
                        animation: !1
                    } : null));
                })), this.selectionMarker = this.selectionMarker.destroy(), d && this.scaleGroups();
            }
            c && (p(c.container, {
                cursor: c._cursor
            }), c.cancelClick = this.hasDragged > 10, c.mouseIsDown = this.hasDragged = this.hasPinched = !1, 
            this.pinchDown = []);
        },
        onContainerMouseDown: function(a) {
            a = this.normalize(a), a.preventDefault && a.preventDefault(), this.dragStart(a);
        },
        onDocumentMouseUp: function(a) {
            this.drop(a);
        },
        onDocumentMouseMove: function(a) {
            var b = this.chart, c = this.chartPosition, d = b.hoverSeries;
            a = this.normalize(a, c), c && d && !this.inClass(a.target, "highcharts-tracker") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) && this.reset();
        },
        onContainerMouseLeave: function() {
            this.reset(), this.chartPosition = null;
        },
        onContainerMouseMove: function(a) {
            var b = this.chart;
            a = this.normalize(a), a.returnValue = !1, "mousedown" === b.mouseIsDown && this.drag(a), 
            !this.inClass(a.target, "highcharts-tracker") && !b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) || b.openMenu || this.runPointActions(a);
        },
        inClass: function(a, b) {
            for (var c; a; ) {
                if (c = m(a, "class")) {
                    if (c.indexOf(b) !== -1) return !0;
                    if (c.indexOf(Xa + "container") !== -1) return !1;
                }
                a = a.parentNode;
            }
        },
        onTrackerMouseOut: function(a) {
            var b = this.chart.hoverSeries;
            !b || b.options.stickyTracking || this.inClass(a.toElement || a.relatedTarget, Xa + "tooltip") || b.onMouseOut();
        },
        onContainerClick: function(b) {
            var c, d, e, f = this.chart, g = f.hoverPoint, h = f.plotLeft, i = f.plotTop, j = f.inverted;
            b = this.normalize(b), b.cancelBubble = !0, f.cancelClick || (g && this.inClass(b.target, Xa + "tracker") ? (c = this.chartPosition, 
            d = g.plotX, e = g.plotY, a(g, {
                pageX: c.left + h + (j ? f.plotWidth - e : d),
                pageY: c.top + i + (j ? f.plotHeight - d : e)
            }), Ab(g.series, "click", a(b, {
                point: g
            })), f.hoverPoint && g.firePointEvent("click", b)) : (a(b, this.getCoordinates(b)), 
            f.isInsidePlot(b.chartX - h, b.chartY - i) && Ab(f, "click", b)));
        },
        onContainerTouchStart: function(a) {
            var b = this.chart;
            1 === a.touches.length ? (a = this.normalize(a), b.isInsidePlot(a.chartX - b.plotLeft, a.chartY - b.plotTop) ? (this.runPointActions(a), 
            this.pinch(a)) : this.reset()) : 2 === a.touches.length && this.pinch(a);
        },
        onContainerTouchMove: function(a) {
            1 !== a.touches.length && 2 !== a.touches.length || this.pinch(a);
        },
        onDocumentTouchEnd: function(a) {
            this.drop(a);
        },
        setDOMEvents: function() {
            var a, b = this, c = b.chart.container;
            this._events = a = [ [ c, "onmousedown", "onContainerMouseDown" ], [ c, "onmousemove", "onContainerMouseMove" ], [ c, "onclick", "onContainerClick" ], [ c, "mouseleave", "onContainerMouseLeave" ], [ oa, "mousemove", "onDocumentMouseMove" ], [ oa, "mouseup", "onDocumentMouseUp" ] ], 
            Ma && a.push([ c, "ontouchstart", "onContainerTouchStart" ], [ c, "ontouchmove", "onContainerTouchMove" ], [ oa, "touchend", "onDocumentTouchEnd" ]), 
            ub(a, function(a) {
                b["_" + a[2]] = function(c) {
                    b[a[2]](c);
                }, 0 === a[1].indexOf("on") ? a[0][a[1]] = b["_" + a[2]] : yb(a[0], a[1], b["_" + a[2]]);
            });
        },
        destroy: function() {
            var a = this;
            ub(a._events, function(b) {
                0 === b[1].indexOf("on") ? b[0][b[1]] = null : zb(b[0], b[1], a["_" + b[2]]);
            }), delete a._events, clearInterval(a.tooltipTimeout);
        }
    }, U.prototype = {
        init: function(a, c) {
            var e = this, f = c.itemStyle, g = o(c.padding, 8), h = c.itemMarginTop || 0;
            this.options = c, c.enabled && (e.baseline = d(f.fontSize) + 3 + h, e.itemStyle = f, 
            e.itemHiddenStyle = b(f, c.itemHiddenStyle), e.itemMarginTop = h, e.padding = g, 
            e.initialItemX = g, e.initialItemY = g - 5, e.maxItemWidth = 0, e.chart = a, e.itemHeight = 0, 
            e.lastLineHeight = 0, e.render(), yb(e.chart, "endResize", function() {
                e.positionCheckboxes();
            }));
        },
        colorizeItem: function(a, b) {
            var c, d, e = this, f = e.options, g = a.legendItem, h = a.legendLine, i = a.legendSymbol, j = e.itemHiddenStyle.color, k = b ? f.itemStyle.color : j, l = b ? a.color : j, m = a.options && a.options.marker, n = {
                stroke: l,
                fill: l
            };
            if (g && g.css({
                fill: k,
                color: k
            }), h && h.attr({
                stroke: l
            }), i) {
                if (m && i.isMarker) {
                    m = a.convertAttribs(m);
                    for (c in m) d = m[c], d !== W && (n[c] = d);
                }
                i.attr(n);
            }
        },
        positionItem: function(a) {
            var b = this, c = b.options, d = c.symbolPadding, e = !c.rtl, f = a._legendItemPos, g = f[0], h = f[1], i = a.checkbox;
            a.legendGroup && a.legendGroup.translate(e ? g : b.legendWidth - g - 2 * d - 4, h), 
            i && (i.x = g, i.y = h);
        },
        destroyItem: function(a) {
            var b = a.checkbox;
            ub([ "legendItem", "legendLine", "legendSymbol", "legendGroup" ], function(b) {
                a[b] && (a[b] = a[b].destroy());
            }), b && G(a.checkbox);
        },
        destroy: function() {
            var a = this, b = a.group, c = a.box;
            c && (a.box = c.destroy()), b && (a.group = b.destroy());
        },
        positionCheckboxes: function(a) {
            var b, c = this.group.alignAttr, d = this.clipHeight || this.legendHeight;
            c && (b = c.translateY, ub(this.allItems, function(e) {
                var f, g = e.checkbox;
                g && (f = b + g.y + (a || 0) + 3, p(g, {
                    left: c.translateX + e.legendItemWidth + g.x - 20 + Za,
                    top: f + Za,
                    display: f > b - 6 && f < b + d - 6 ? "" : $a
                }));
            }));
        },
        renderTitle: function() {
            var a, b = this.options, c = this.padding, d = b.title, e = 0;
            d.text && (this.title || (this.title = this.chart.renderer.label(d.text, c - 3, c - 4, null, null, null, null, null, "legend-title").attr({
                zIndex: 1
            }).css(d.style).add(this.group)), a = this.title.getBBox(), e = a.height, this.offsetWidth = a.width, 
            this.contentGroup.attr({
                translateY: e
            })), this.titleHeight = e;
        },
        renderItem: function(a) {
            var c, d, e, f = this, g = f.chart, h = g.renderer, i = f.options, j = "horizontal" === i.layout, k = i.symbolWidth, l = i.symbolPadding, m = f.itemStyle, n = f.itemHiddenStyle, p = f.padding, r = j ? o(i.itemDistance, 8) : 0, s = !i.rtl, t = i.width, u = i.itemMarginBottom || 0, v = f.itemMarginTop, x = f.initialItemX, y = a.legendItem, z = a.series || a, A = z.options, B = A.showCheckbox, C = i.useHTML;
            y || (a.legendGroup = h.g("legend-item").attr({
                zIndex: 1
            }).add(f.scrollGroup), z.drawLegendSymbol(f, a), a.legendItem = y = h.text(i.labelFormat ? w(i.labelFormat, a) : i.labelFormatter.call(a), s ? k + l : -l, f.baseline, C).css(b(a.visible ? m : n)).attr({
                align: s ? "left" : "right",
                zIndex: 2
            }).add(a.legendGroup), (C ? y : a.legendGroup).on("mouseover", function() {
                a.setState(db), y.css(f.options.itemHoverStyle);
            }).on("mouseout", function() {
                y.css(a.visible ? m : n), a.setState();
            }).on("click", function(b) {
                var c = "legendItemClick", d = function() {
                    a.setVisible();
                };
                b = {
                    browserEvent: b
                }, a.firePointEvent ? a.firePointEvent(c, b, d) : Ab(a, c, b, d);
            }), f.colorizeItem(a, a.visible), A && B && (a.checkbox = q("input", {
                type: "checkbox",
                checked: a.selected,
                defaultChecked: a.selected
            }, i.itemCheckboxStyle, g.container), yb(a.checkbox, "click", function(b) {
                var c = b.target;
                Ab(a, "checkboxClick", {
                    checked: c.checked
                }, function() {
                    a.select();
                });
            }))), d = y.getBBox(), e = a.legendItemWidth = i.itemWidth || k + l + d.width + r + (B ? 20 : 0), 
            f.itemHeight = c = d.height, j && f.itemX - x + e > (t || g.chartWidth - 2 * p - x) && (f.itemX = x, 
            f.itemY += v + f.lastLineHeight + u, f.lastLineHeight = 0), f.maxItemWidth = ua(f.maxItemWidth, e), 
            f.lastItemY = v + f.itemY + u, f.lastLineHeight = ua(c, f.lastLineHeight), a._legendItemPos = [ f.itemX, f.itemY ], 
            j ? f.itemX += e : (f.itemY += v + c + u, f.lastLineHeight = c), f.offsetWidth = t || ua((j ? f.itemX - x - r : e) + p, f.offsetWidth);
        },
        render: function() {
            var b, c, d, e, f = this, g = f.chart, h = g.renderer, i = f.group, j = f.box, k = f.options, m = f.padding, n = k.borderWidth, o = k.backgroundColor;
            f.itemX = f.initialItemX, f.itemY = f.initialItemY, f.offsetWidth = 0, f.lastItemY = 0, 
            i || (f.group = i = h.g("legend").attr({
                zIndex: 7
            }).add(), f.contentGroup = h.g().attr({
                zIndex: 1
            }).add(i), f.scrollGroup = h.g().add(f.contentGroup)), f.renderTitle(), b = [], 
            ub(g.series, function(a) {
                var c = a.options;
                c.showInLegend && !l(c.linkedTo) && (b = b.concat(a.legendItems || ("point" === c.legendType ? a.data : a)));
            }), C(b, function(a, b) {
                return (a.options && a.options.legendIndex || 0) - (b.options && b.options.legendIndex || 0);
            }), k.reversed && b.reverse(), f.allItems = b, f.display = c = !!b.length, ub(b, function(a) {
                f.renderItem(a);
            }), d = k.width || f.offsetWidth, e = f.lastItemY + f.lastLineHeight + f.titleHeight, 
            e = f.handleOverflow(e), (n || o) && (d += m, e += m, j ? d > 0 && e > 0 && (j[j.isNew ? "attr" : "animate"](j.crisp(null, null, null, d, e)), 
            j.isNew = !1) : (f.box = j = h.rect(0, 0, d, e, k.borderRadius, n || 0).attr({
                stroke: k.borderColor,
                "stroke-width": n || 0,
                fill: o || $a
            }).add(i).shadow(k.shadow), j.isNew = !0), j[c ? "show" : "hide"]()), f.legendWidth = d, 
            f.legendHeight = e, ub(b, function(a) {
                f.positionItem(a);
            }), c && i.align(a({
                width: d,
                height: e
            }, k), !0, "spacingBox"), g.isResizing || this.positionCheckboxes();
        },
        handleOverflow: function(a) {
            var b, c, d = this, e = this.chart, f = e.renderer, g = this.options, h = g.y, i = "top" === g.verticalAlign, j = e.spacingBox.height + (i ? -h : h) - this.padding, k = g.maxHeight, l = this.clipRect, m = g.navigation, n = o(m.animation, !0), p = m.arrowSize || 12, q = this.nav;
            return "horizontal" === g.layout && (j /= 2), k && (j = va(j, k)), a > j && !g.useHTML ? (this.clipHeight = c = j - 20 - this.titleHeight, 
            this.pageCount = b = ta(a / c), this.currentPage = o(this.currentPage, 1), this.fullHeight = a, 
            l || (l = d.clipRect = f.clipRect(0, 0, 9999, 0), d.contentGroup.clip(l)), l.attr({
                height: c
            }), q || (this.nav = q = f.g().attr({
                zIndex: 1
            }).add(this.group), this.up = f.symbol("triangle", 0, 0, p, p).on("click", function() {
                d.scroll(-1, n);
            }).add(q), this.pager = f.text("", 15, 10).css(m.style).add(q), this.down = f.symbol("triangle-down", 0, 0, p, p).on("click", function() {
                d.scroll(1, n);
            }).add(q)), d.scroll(0), a = j) : q && (l.attr({
                height: e.chartHeight
            }), q.hide(), this.scrollGroup.attr({
                translateY: 1
            }), this.clipHeight = 0), a;
        },
        scroll: function(a, b) {
            var c, d = this.pageCount, e = this.currentPage + a, f = this.clipHeight, g = this.options.navigation, h = g.activeColor, i = g.inactiveColor, j = this.pager, k = this.padding;
            e > d && (e = d), e > 0 && (b !== W && J(b, this.chart), this.nav.attr({
                translateX: k,
                translateY: f + 7 + this.titleHeight,
                visibility: Ya
            }), this.up.attr({
                fill: 1 === e ? i : h
            }).css({
                cursor: 1 === e ? "default" : "pointer"
            }), j.attr({
                text: e + "/" + this.pageCount
            }), this.down.attr({
                x: 18 + this.pager.getBBox().width,
                fill: e === d ? i : h
            }).css({
                cursor: e === d ? "default" : "pointer"
            }), c = -va(f * (e - 1), this.fullHeight - f + k) + 1, this.scrollGroup.animate({
                translateY: c
            }), j.attr({
                text: e + "/" + d
            }), this.currentPage = e, this.positionCheckboxes(c));
        }
    }, /Trident.*?11\.0/.test(Ba) && u(U.prototype, "positionItem", function(a, b) {
        var c = this;
        setTimeout(function() {
            a.call(c, b);
        });
    }), V.prototype = {
        init: function(a, c) {
            var d, e = a.series;
            a.series = null, d = b(Z, a), d.series = a.series = e;
            var f = d.chart;
            this.margin = this.splashArray("margin", f), this.spacing = this.splashArray("spacing", f);
            var g = f.events;
            this.bounds = {
                h: {},
                v: {}
            }, this.callback = c, this.isResizing = 0, this.options = d, this.axes = [], this.series = [], 
            this.hasCartesianSeries = f.showAxes;
            var h, i = this;
            if (i.index = Qa.length, Qa.push(i), f.reflow !== !1 && yb(i, "load", function() {
                i.initReflow();
            }), g) for (h in g) yb(i, h, g[h]);
            i.xAxis = [], i.yAxis = [], i.animation = !La && o(f.animation, !0), i.pointCount = 0, 
            i.counters = new B(), i.firstRender();
        },
        initSeries: function(a) {
            var b, c = this, d = c.options.chart, e = a.type || d.type || d.defaultSeriesType, f = ob[e];
            return f || H(17, !0), b = new f(), b.init(this, a), b;
        },
        addSeries: function(a, b, c) {
            var d, e = this;
            return a && (b = o(b, !0), Ab(e, "addSeries", {
                options: a
            }, function() {
                d = e.initSeries(a), e.isDirtyLegend = !0, e.linkSeries(), b && e.redraw(c);
            })), d;
        },
        addAxis: function(a, c, d, e) {
            var f, g = c ? "xAxis" : "yAxis", h = this.options;
            f = new R(this, b(a, {
                index: this[g].length,
                isX: c
            })), h[g] = n(h[g] || {}), h[g].push(a), o(d, !0) && this.redraw(e);
        },
        isInsidePlot: function(a, b, c) {
            var d = c ? b : a, e = c ? a : b;
            return d >= 0 && d <= this.plotWidth && e >= 0 && e <= this.plotHeight;
        },
        adjustTickAmounts: function() {
            this.options.chart.alignTicks !== !1 && ub(this.axes, function(a) {
                a.adjustTickAmount();
            }), this.maxTicks = null;
        },
        redraw: function(b) {
            var c, d, e, f = this, g = f.axes, h = f.series, i = f.pointer, j = f.legend, k = f.isDirtyLegend, l = f.isDirtyBox, m = h.length, n = m, o = f.renderer, p = o.isHidden(), q = [];
            for (J(b, f), p && f.cloneRenderTo(), f.layOutTitles(); n--; ) if (e = h[n], e.options.stacking && (c = !0, 
            e.isDirty)) {
                d = !0;
                break;
            }
            if (d) for (n = m; n--; ) e = h[n], e.options.stacking && (e.isDirty = !0);
            ub(h, function(a) {
                a.isDirty && "point" === a.options.legendType && (k = !0);
            }), k && j.options.enabled && (j.render(), f.isDirtyLegend = !1), c && f.getStacks(), 
            f.hasCartesianSeries && (f.isResizing || (f.maxTicks = null, ub(g, function(a) {
                a.setScale();
            })), f.adjustTickAmounts(), f.getMargins(), ub(g, function(a) {
                a.isDirty && (l = !0);
            }), ub(g, function(b) {
                b.isDirtyExtremes && (b.isDirtyExtremes = !1, q.push(function() {
                    Ab(b, "afterSetExtremes", a(b.eventArgs, b.getExtremes())), delete b.eventArgs;
                })), (l || c) && b.redraw();
            })), l && f.drawChartBox(), ub(h, function(a) {
                a.isDirty && a.visible && (!a.isCartesian || a.xAxis) && a.redraw();
            }), i && i.reset && i.reset(!0), o.draw(), Ab(f, "redraw"), p && f.cloneRenderTo(!0), 
            ub(q, function(a) {
                a.call();
            });
        },
        showLoading: function(b) {
            var c = this, d = c.options, e = c.loadingDiv, f = d.loading;
            e || (c.loadingDiv = e = q(Ta, {
                className: Xa + "loading"
            }, a(f.style, {
                zIndex: 10,
                display: $a
            }), c.container), c.loadingSpan = q("span", null, f.labelStyle, e)), c.loadingSpan.innerHTML = b || d.lang.loading, 
            c.loadingShown || (p(e, {
                opacity: 0,
                display: "",
                left: c.plotLeft + Za,
                top: c.plotTop + Za,
                width: c.plotWidth + Za,
                height: c.plotHeight + Za
            }), Cb(e, {
                opacity: f.style.opacity
            }, {
                duration: f.showDuration || 0
            }), c.loadingShown = !0);
        },
        hideLoading: function() {
            var a = this.options, b = this.loadingDiv;
            b && Cb(b, {
                opacity: 0
            }, {
                duration: a.loading.hideDuration || 100,
                complete: function() {
                    p(b, {
                        display: $a
                    });
                }
            }), this.loadingShown = !1;
        },
        get: function(a) {
            var b, c, d, e = this, f = e.axes, g = e.series;
            for (b = 0; b < f.length; b++) if (f[b].options.id === a) return f[b];
            for (b = 0; b < g.length; b++) if (g[b].options.id === a) return g[b];
            for (b = 0; b < g.length; b++) for (d = g[b].points || [], c = 0; c < d.length; c++) if (d[c].id === a) return d[c];
            return null;
        },
        getAxes: function() {
            var a, b, c = this, d = this.options, e = d.xAxis = n(d.xAxis || {}), f = d.yAxis = n(d.yAxis || {});
            ub(e, function(a, b) {
                a.index = b, a.isX = !0;
            }), ub(f, function(a, b) {
                a.index = b;
            }), a = e.concat(f), ub(a, function(a) {
                b = new R(c, a);
            }), c.adjustTickAmounts();
        },
        getSelectedPoints: function() {
            var a = [];
            return ub(this.series, function(b) {
                a = a.concat(vb(b.points || [], function(a) {
                    return a.selected;
                }));
            }), a;
        },
        getSelectedSeries: function() {
            return vb(this.series, function(a) {
                return a.selected;
            });
        },
        getStacks: function() {
            var a = this;
            ub(a.yAxis, function(a) {
                a.stacks && a.hasVisibleSeries && (a.oldStacks = a.stacks);
            }), ub(a.series, function(b) {
                !b.options.stacking || b.visible !== !0 && a.options.chart.ignoreHiddenSeries !== !1 || (b.stackKey = b.type + o(b.options.stack, ""));
            });
        },
        showResetZoom: function() {
            var a = this, b = Z.lang, c = a.options.chart.resetZoomButton, d = c.theme, e = d.states, f = "chart" === c.relativeTo ? null : "plotBox";
            this.resetZoomButton = a.renderer.button(b.resetZoom, null, null, function() {
                a.zoomOut();
            }, d, e && e.hover).attr({
                align: c.position.align,
                title: b.resetZoomTitle
            }).add().align(c.position, !1, f);
        },
        zoomOut: function() {
            var a = this;
            Ab(a, "selection", {
                resetSelection: !0
            }, function() {
                a.zoom();
            });
        },
        zoom: function(a) {
            var b, c, d = this, e = d.pointer, g = !1;
            !a || a.resetSelection ? ub(d.axes, function(a) {
                b = a.zoom();
            }) : ub(a.xAxis.concat(a.yAxis), function(a) {
                var c = a.axis, d = c.isXAxis;
                (e[d ? "zoomX" : "zoomY"] || e[d ? "pinchX" : "pinchY"]) && (b = c.zoom(a.min, a.max), 
                c.displayBtn && (g = !0));
            }), c = d.resetZoomButton, g && !c ? d.showResetZoom() : !g && f(c) && (d.resetZoomButton = c.destroy()), 
            b && d.redraw(o(d.options.chart.animation, a && a.animation, d.pointCount < 100));
        },
        pan: function(a, b) {
            var c, d = this, e = d.hoverPoints;
            e && ub(e, function(a) {
                a.setState();
            }), ub("xy" === b ? [ 1, 0 ] : [ 1 ], function(b) {
                var e = a[b ? "chartX" : "chartY"], f = d[b ? "xAxis" : "yAxis"][0], g = d[b ? "mouseDownX" : "mouseDownY"], h = (f.pointRange || 0) / 2, i = f.getExtremes(), j = f.toValue(g - e, !0) + h, k = f.toValue(g + d[b ? "plotWidth" : "plotHeight"] - e, !0) - h;
                f.series.length && j > va(i.dataMin, i.min) && k < ua(i.dataMax, i.max) && (f.setExtremes(j, k, !1, !1, {
                    trigger: "pan"
                }), c = !0), d[b ? "mouseDownX" : "mouseDownY"] = e;
            }), c && d.redraw(!1), p(d.container, {
                cursor: "move"
            });
        },
        setTitle: function(a, c) {
            var d, e, f = this, g = f.options;
            d = g.title = b(g.title, a), e = g.subtitle = b(g.subtitle, c), ub([ [ "title", a, d ], [ "subtitle", c, e ] ], function(a) {
                var b = a[0], c = f[b], d = a[1], e = a[2];
                c && d && (f[b] = c = c.destroy()), e && e.text && !c && (f[b] = f.renderer.text(e.text, 0, 0, e.useHTML).attr({
                    align: e.align,
                    class: Xa + b,
                    zIndex: e.zIndex || 4
                }).css(e.style).add());
            }), f.layOutTitles();
        },
        layOutTitles: function() {
            var b = 0, c = this.title, d = this.subtitle, e = this.options, f = e.title, g = e.subtitle, h = this.spacingBox.width - 44;
            c && (c.css({
                width: (f.width || h) + Za
            }).align(a({
                y: 15
            }, f), !1, "spacingBox"), f.floating || f.verticalAlign || (b = c.getBBox().height, 
            b >= 18 && b <= 25 && (b = 15))), d && (d.css({
                width: (g.width || h) + Za
            }).align(a({
                y: b + f.margin
            }, g), !1, "spacingBox"), g.floating || g.verticalAlign || (b = ta(b + d.getBBox().height))), 
            this.titleOffset = b;
        },
        getChartSize: function() {
            var a = this, b = a.options.chart, c = a.renderToClone || a.renderTo;
            a.containerWidth = rb(c, "width"), a.containerHeight = rb(c, "height"), a.chartWidth = ua(0, b.width || a.containerWidth || 600), 
            a.chartHeight = ua(0, o(b.height, a.containerHeight > 19 ? a.containerHeight : 400));
        },
        cloneRenderTo: function(a) {
            var b = this.renderToClone, c = this.container;
            a ? b && (this.renderTo.appendChild(c), G(b), delete this.renderToClone) : (c && c.parentNode === this.renderTo && this.renderTo.removeChild(c), 
            this.renderToClone = b = this.renderTo.cloneNode(0), p(b, {
                position: Ua,
                top: "-9999px",
                display: "block"
            }), oa.body.appendChild(b), c && b.appendChild(c));
        },
        getContainer: function() {
            var b, c, f, g, h, i, j = this, k = j.options.chart, l = "data-highcharts-chart";
            j.renderTo = g = k.renderTo, i = Xa + Oa++, e(g) && (j.renderTo = g = oa.getElementById(g)), 
            g || H(13, !0), h = d(m(g, l)), !isNaN(h) && Qa[h] && Qa[h].destroy(), m(g, l, j.index), 
            g.innerHTML = "", g.offsetWidth || j.cloneRenderTo(), j.getChartSize(), c = j.chartWidth, 
            f = j.chartHeight, j.container = b = q(Ta, {
                className: Xa + "container" + (k.className ? " " + k.className : ""),
                id: i
            }, a({
                position: Va,
                overflow: Wa,
                width: c + Za,
                height: f + Za,
                textAlign: "left",
                lineHeight: "normal",
                zIndex: 0,
                "-webkit-tap-highlight-color": "rgba(0,0,0,0)"
            }, k.style), j.renderToClone || g), j._cursor = b.style.cursor, j.renderer = k.forExport ? new Ib(b, c, f, (!0)) : new X(b, c, f), 
            La && j.renderer.create(j, b, c, f);
        },
        getMargins: function() {
            var a, b = this, c = b.spacing, d = b.legend, e = b.margin, f = b.options.legend, g = o(f.margin, 10), h = f.x, i = f.y, j = f.align, k = f.verticalAlign, m = b.titleOffset;
            b.resetMargins(), a = b.axisOffset, m && !l(e[0]) && (b.plotTop = ua(b.plotTop, m + b.options.title.margin + c[0])), 
            d.display && !f.floating && ("right" === j ? l(e[1]) || (b.marginRight = ua(b.marginRight, d.legendWidth - h + g + c[1])) : "left" === j ? l(e[3]) || (b.plotLeft = ua(b.plotLeft, d.legendWidth + h + g + c[3])) : "top" === k ? l(e[0]) || (b.plotTop = ua(b.plotTop, d.legendHeight + i + g + c[0])) : "bottom" === k && (l(e[2]) || (b.marginBottom = ua(b.marginBottom, d.legendHeight - i + g + c[2])))), 
            b.extraBottomMargin && (b.marginBottom += b.extraBottomMargin), b.extraTopMargin && (b.plotTop += b.extraTopMargin), 
            b.hasCartesianSeries && ub(b.axes, function(a) {
                a.getOffset();
            }), l(e[3]) || (b.plotLeft += a[3]), l(e[0]) || (b.plotTop += a[0]), l(e[2]) || (b.marginBottom += a[2]), 
            l(e[1]) || (b.marginRight += a[1]), b.setChartSize();
        },
        initReflow: function() {
            function a(a) {
                var f = d.width || rb(e, "width"), g = d.height || rb(e, "height"), h = a ? a.target : pa;
                c.hasUserSize || !f || !g || h !== pa && h !== oa || (f === c.containerWidth && g === c.containerHeight || (clearTimeout(b), 
                c.reflowTimeout = b = setTimeout(function() {
                    c.container && (c.setSize(f, g, !1), c.hasUserSize = null);
                }, 100)), c.containerWidth = f, c.containerHeight = g);
            }
            var b, c = this, d = c.options.chart, e = c.renderTo;
            c.reflow = a, yb(pa, "resize", a), yb(c, "destroy", function() {
                zb(pa, "resize", a);
            });
        },
        setSize: function(a, b, c) {
            var d, e, f, g = this;
            g.isResizing += 1, f = function() {
                g && Ab(g, "endResize", null, function() {
                    g.isResizing -= 1;
                });
            }, J(c, g), g.oldChartHeight = g.chartHeight, g.oldChartWidth = g.chartWidth, l(a) && (g.chartWidth = d = ua(0, ra(a)), 
            g.hasUserSize = !!d), l(b) && (g.chartHeight = e = ua(0, ra(b))), p(g.container, {
                width: d + Za,
                height: e + Za
            }), g.setChartSize(!0), g.renderer.setSize(d, e, c), g.maxTicks = null, ub(g.axes, function(a) {
                a.isDirty = !0, a.setScale();
            }), ub(g.series, function(a) {
                a.isDirty = !0;
            }), g.isDirtyLegend = !0, g.isDirtyBox = !0, g.getMargins(), g.redraw(c), g.oldChartHeight = null, 
            Ab(g, "resize"), _ === !1 ? f() : setTimeout(f, _ && _.duration || 500);
        },
        setChartSize: function(a) {
            var b, c, d, e, f, g, h, i = this, j = i.inverted, k = i.renderer, l = i.chartWidth, m = i.chartHeight, n = i.options.chart, o = i.spacing, p = i.clipOffset;
            i.plotLeft = d = ra(i.plotLeft), i.plotTop = e = ra(i.plotTop), i.plotWidth = f = ua(0, ra(l - d - i.marginRight)), 
            i.plotHeight = g = ua(0, ra(m - e - i.marginBottom)), i.plotSizeX = j ? g : f, i.plotSizeY = j ? f : g, 
            i.plotBorderWidth = n.plotBorderWidth || 0, i.spacingBox = k.spacingBox = {
                x: o[3],
                y: o[0],
                width: l - o[3] - o[1],
                height: m - o[0] - o[2]
            }, i.plotBox = k.plotBox = {
                x: d,
                y: e,
                width: f,
                height: g
            }, h = 2 * sa(i.plotBorderWidth / 2), b = ta(ua(h, p[3]) / 2), c = ta(ua(h, p[0]) / 2), 
            i.clipBox = {
                x: b,
                y: c,
                width: sa(i.plotSizeX - ua(h, p[1]) / 2 - b),
                height: sa(i.plotSizeY - ua(h, p[2]) / 2 - c)
            }, a || ub(i.axes, function(a) {
                a.setAxisSize(), a.setAxisTranslation();
            });
        },
        resetMargins: function() {
            var a = this, b = a.spacing, c = a.margin;
            a.plotTop = o(c[0], b[0]), a.marginRight = o(c[1], b[1]), a.marginBottom = o(c[2], b[2]), 
            a.plotLeft = o(c[3], b[3]), a.axisOffset = [ 0, 0, 0, 0 ], a.clipOffset = [ 0, 0, 0, 0 ];
        },
        drawChartBox: function() {
            var a, b, c = this, d = c.options.chart, e = c.renderer, f = c.chartWidth, g = c.chartHeight, h = c.chartBackground, i = c.plotBackground, j = c.plotBorder, k = c.plotBGImage, l = d.borderWidth || 0, m = d.backgroundColor, n = d.plotBackgroundColor, o = d.plotBackgroundImage, p = d.plotBorderWidth || 0, q = c.plotLeft, r = c.plotTop, s = c.plotWidth, t = c.plotHeight, u = c.plotBox, v = c.clipRect, w = c.clipBox;
            a = l + (d.shadow ? 8 : 0), (l || m) && (h ? h.animate(h.crisp(null, null, null, f - a, g - a)) : (b = {
                fill: m || $a
            }, l && (b.stroke = d.borderColor, b["stroke-width"] = l), c.chartBackground = e.rect(a / 2, a / 2, f - a, g - a, d.borderRadius, l).attr(b).add().shadow(d.shadow))), 
            n && (i ? i.animate(u) : c.plotBackground = e.rect(q, r, s, t, 0).attr({
                fill: n
            }).add().shadow(d.plotShadow)), o && (k ? k.animate(u) : c.plotBGImage = e.image(o, q, r, s, t).add()), 
            v ? v.animate({
                width: w.width,
                height: w.height
            }) : c.clipRect = e.clipRect(w), p && (j ? j.animate(j.crisp(null, q, r, s, t)) : c.plotBorder = e.rect(q, r, s, t, 0, -p).attr({
                stroke: d.plotBorderColor,
                "stroke-width": p,
                zIndex: 1
            }).add()), c.isDirtyBox = !1;
        },
        propFromSeries: function() {
            var a, b, c, d = this, e = d.options.chart, f = d.options.series;
            ub([ "inverted", "angular", "polar" ], function(g) {
                for (a = ob[e.type || e.defaultSeriesType], c = d[g] || e[g] || a && a.prototype[g], 
                b = f && f.length; !c && b--; ) a = ob[f[b].type], a && a.prototype[g] && (c = !0);
                d[g] = c;
            });
        },
        linkSeries: function() {
            var a = this, b = a.series;
            ub(b, function(a) {
                a.linkedSeries.length = 0;
            }), ub(b, function(b) {
                var c = b.options.linkedTo;
                e(c) && (c = ":previous" === c ? a.series[b.index - 1] : a.get(c), c && (c.linkedSeries.push(b), 
                b.linkedParent = c));
            });
        },
        render: function() {
            var b, c = this, e = c.axes, f = c.renderer, g = c.options, h = g.labels, i = g.credits;
            c.setTitle(), c.legend = new U(c, g.legend), c.getStacks(), ub(e, function(a) {
                a.setScale();
            }), c.getMargins(), c.maxTicks = null, ub(e, function(a) {
                a.setTickPositions(!0), a.setMaxTicks();
            }), c.adjustTickAmounts(), c.getMargins(), c.drawChartBox(), c.hasCartesianSeries && ub(e, function(a) {
                a.render();
            }), c.seriesGroup || (c.seriesGroup = f.g("series-group").attr({
                zIndex: 3
            }).add()), ub(c.series, function(a) {
                a.translate(), a.setTooltipPoints(), a.render();
            }), h.items && ub(h.items, function(b) {
                var e = a(h.style, b.style), g = d(e.left) + c.plotLeft, i = d(e.top) + c.plotTop + 12;
                delete e.left, delete e.top, f.text(b.html, g, i).attr({
                    zIndex: 2
                }).css(e).add();
            }), i.enabled && !c.credits && (b = i.href, c.credits = f.text(i.text, 0, 0).on("click", function() {
                b && (location.href = b);
            }).attr({
                align: i.position.align,
                zIndex: 8
            }).css(i.style).add().align(i.position)), c.hasRendered = !0;
        },
        destroy: function() {
            var a, b = this, c = b.axes, d = b.series, e = b.container, f = e && e.parentNode;
            for (Ab(b, "destroy"), Qa[b.index] = W, b.renderTo.removeAttribute("data-highcharts-chart"), 
            zb(b), a = c.length; a--; ) c[a] = c[a].destroy();
            for (a = d.length; a--; ) d[a] = d[a].destroy();
            ub([ "title", "subtitle", "chartBackground", "plotBackground", "plotBGImage", "plotBorder", "seriesGroup", "clipRect", "credits", "pointer", "scroller", "rangeSelector", "legend", "resetZoomButton", "tooltip", "renderer" ], function(a) {
                var c = b[a];
                c && c.destroy && (b[a] = c.destroy());
            }), e && (e.innerHTML = "", zb(e), f && G(e));
            for (a in b) delete b[a];
        },
        isReadyToRender: function() {
            var a = this;
            return !(!Ja && pa == pa.top && "complete" !== oa.readyState || La && !pa.canvg) || (La ? Nb.push(function() {
                a.firstRender();
            }, a.options.global.canvasToolsURL) : oa.attachEvent("onreadystatechange", function() {
                oa.detachEvent("onreadystatechange", a.firstRender), "complete" === oa.readyState && a.firstRender();
            }), !1);
        },
        firstRender: function() {
            var a = this, b = a.options, c = a.callback;
            a.isReadyToRender() && (a.getContainer(), Ab(a, "init"), a.resetMargins(), a.setChartSize(), 
            a.propFromSeries(), a.getAxes(), ub(b.series || [], function(b) {
                a.initSeries(b);
            }), a.linkSeries(), Ab(a, "beforeRender"), a.pointer = new T(a, b), a.render(), 
            a.renderer.draw(), c && c.apply(a, [ a ]), ub(a.callbacks, function(b) {
                b.apply(a, [ a ]);
            }), a.cloneRenderTo(!0), Ab(a, "load"));
        },
        splashArray: function(a, b) {
            var c = b[a], d = f(c) ? c : [ c, c, c, c ];
            return [ o(b[a + "Top"], d[0]), o(b[a + "Right"], d[1]), o(b[a + "Bottom"], d[2]), o(b[a + "Left"], d[3]) ];
        }
    }, V.prototype.callbacks = [];
    var Ob = function() {};
    Ob.prototype = {
        init: function(a, b, c) {
            var d, e = this;
            return e.series = a, e.applyOptions(b, c), e.pointAttr = {}, a.options.colorByPoint && (d = a.options.colors || a.chart.options.colors, 
            e.color = e.color || d[a.colorCounter++], a.colorCounter === d.length && (a.colorCounter = 0)), 
            a.chart.pointCount++, e;
        },
        applyOptions: function(b, c) {
            var d = this, e = d.series, f = e.pointValKey;
            return b = Ob.prototype.optionsToObject.call(this, b), a(d, b), d.options = d.options ? a(d.options, b) : b, 
            f && (d.y = d[f]), d.x === W && e && (d.x = c === W ? e.autoIncrement() : c), d;
        },
        optionsToObject: function(a) {
            var b, c, d = this.series, e = d.pointArrayMap || [ "y" ], f = e.length, h = 0, i = 0;
            if ("number" == typeof a || null === a) b = {
                y: a
            }; else if (g(a)) for (b = {}, a.length > f && (c = typeof a[0], "string" === c ? b.name = a[0] : "number" === c && (b.x = a[0]), 
            h++); i < f; ) b[e[i++]] = a[h++]; else "object" == typeof a && (b = a, a.dataLabels && (d._hasPointLabels = !0), 
            a.marker && (d._hasPointMarkers = !0));
            return b;
        },
        destroy: function() {
            var a, b = this, c = b.series, d = c.chart, e = d.hoverPoints;
            d.pointCount--, e && (b.setState(), k(e, b), e.length || (d.hoverPoints = null)), 
            b === d.hoverPoint && b.onMouseOut(), (b.graphic || b.dataLabel) && (zb(b), b.destroyElements()), 
            b.legendItem && d.legend.destroyItem(b);
            for (a in b) b[a] = null;
        },
        destroyElements: function() {
            for (var a, b = this, c = [ "graphic", "dataLabel", "dataLabelUpper", "group", "connector", "shadowGroup" ], d = 6; d--; ) a = c[d], 
            b[a] && (b[a] = b[a].destroy());
        },
        getLabelConfig: function() {
            var a = this;
            return {
                x: a.category,
                y: a.y,
                key: a.name || a.category,
                series: a.series,
                point: a,
                percentage: a.percentage,
                total: a.total || a.stackTotal
            };
        },
        select: function(a, b) {
            var c = this, d = c.series, e = d.chart;
            a = o(a, !c.selected), c.firePointEvent(a ? "select" : "unselect", {
                accumulate: b
            }, function() {
                c.selected = c.options.selected = a, d.options.data[tb(c, d.data)] = c.options, 
                c.setState(a && eb), b || ub(e.getSelectedPoints(), function(a) {
                    a.selected && a !== c && (a.selected = a.options.selected = !1, d.options.data[tb(a, d.data)] = a.options, 
                    a.setState(cb), a.firePointEvent("unselect"));
                });
            });
        },
        onMouseOver: function(a) {
            var b = this, c = b.series, d = c.chart, e = d.tooltip, f = d.hoverPoint;
            f && f !== b && f.onMouseOut(), b.firePointEvent("mouseOver"), !e || e.shared && !c.noSharedTooltip || e.refresh(b, a), 
            b.setState(db), d.hoverPoint = b;
        },
        onMouseOut: function() {
            var a = this.series.chart, b = a.hoverPoints;
            b && tb(this, b) !== -1 || (this.firePointEvent("mouseOut"), this.setState(), a.hoverPoint = null);
        },
        tooltipFormatter: function(a) {
            var b = this.series, c = b.tooltipOptions, d = o(c.valueDecimals, ""), e = c.valuePrefix || "", f = c.valueSuffix || "";
            return ub(b.pointArrayMap || [ "y" ], function(b) {
                b = "{point." + b, (e || f) && (a = a.replace(b + "}", e + b + "}" + f)), a = a.replace(b + "}", b + ":,." + d + "f}");
            }), w(a, {
                point: this,
                series: this.series
            });
        },
        update: function(a, b, c) {
            var d, e = this, g = e.series, h = e.graphic, i = g.data, j = g.chart, k = g.options;
            b = o(b, !0), e.firePointEvent("update", {
                options: a
            }, function() {
                e.applyOptions(a), f(a) && (g.getAttribs(), h && (a.marker && a.marker.symbol ? e.graphic = h.destroy() : h.attr(e.pointAttr[e.state || ""]))), 
                d = tb(e, i), g.xData[d] = e.x, g.yData[d] = g.toYData ? g.toYData(e) : e.y, g.zData[d] = e.z, 
                k.data[d] = e.options, g.isDirty = g.isDirtyData = !0, !g.fixedBox && g.hasCartesianSeries && (j.isDirtyBox = !0), 
                "point" === k.legendType && j.legend.destroyItem(e), b && j.redraw(c);
            });
        },
        remove: function(a, b) {
            var c, d = this, e = d.series, f = e.points, g = e.chart, h = e.data;
            J(b, g), a = o(a, !0), d.firePointEvent("remove", null, function() {
                c = tb(d, h), h.length === f.length && f.splice(c, 1), h.splice(c, 1), e.options.data.splice(c, 1), 
                e.xData.splice(c, 1), e.yData.splice(c, 1), e.zData.splice(c, 1), d.destroy(), e.isDirty = !0, 
                e.isDirtyData = !0, a && g.redraw();
            });
        },
        firePointEvent: function(a, b, c) {
            var d = this, e = this.series, f = e.options;
            (f.point.events[a] || d.options && d.options.events && d.options.events[a]) && this.importEvents(), 
            "click" === a && f.allowPointSelect && (c = function(a) {
                d.select(null, a.ctrlKey || a.metaKey || a.shiftKey);
            }), Ab(this, a, b, c);
        },
        importEvents: function() {
            if (!this.hasImportedEvents) {
                var a, c = this, d = b(c.series.options.point, c.options), e = d.events;
                c.events = e;
                for (a in e) yb(c, a, e[a]);
                this.hasImportedEvents = !0;
            }
        },
        setState: function(a) {
            var c, d, e = this, f = e.plotX, g = e.plotY, h = e.series, i = h.options.states, j = Fb[h.type].marker && h.options.marker, k = j && !j.enabled, l = j && j.states[a], m = l && l.enabled === !1, n = h.stateMarkerGraphic, o = e.marker || {}, p = h.chart, q = e.pointAttr;
            a = a || cb, a === e.state || e.selected && a !== eb || i[a] && i[a].enabled === !1 || a && (m || k && !l.enabled) || (e.graphic ? (c = j && e.graphic.symbolName && q[a].r, 
            e.graphic.attr(b(q[a], c ? {
                x: f - c,
                y: g - c,
                width: 2 * c,
                height: 2 * c
            } : {}))) : (a && l && (c = l.radius, d = o.symbol || h.symbol, n && n.currentSymbol !== d && (n = n.destroy()), 
            n ? n.attr({
                x: f - c,
                y: g - c
            }) : (h.stateMarkerGraphic = n = p.renderer.symbol(d, f - c, g - c, 2 * c, 2 * c).attr(q[a]).add(h.markerGroup), 
            n.currentSymbol = d)), n && n[a && p.isInsidePlot(f, g) ? "show" : "hide"]()), e.state = a);
        }
    };
    var Pb = function() {};
    Pb.prototype = {
        isCartesian: !0,
        type: "line",
        pointClass: Ob,
        sorted: !0,
        requireSorting: !0,
        pointAttrToOptions: {
            stroke: "lineColor",
            "stroke-width": "lineWidth",
            fill: "fillColor",
            r: "radius"
        },
        colorCounter: 0,
        init: function(b, c) {
            var d, e, f = this, g = b.series;
            f.chart = b, f.options = c = f.setOptions(c), f.linkedSeries = [], f.bindAxes(), 
            a(f, {
                name: c.name,
                state: cb,
                pointAttr: {},
                visible: c.visible !== !1,
                selected: c.selected === !0
            }), La && (c.animation = !1), e = c.events;
            for (d in e) yb(f, d, e[d]);
            (e && e.click || c.point && c.point.events && c.point.events.click || c.allowPointSelect) && (b.runTrackerClick = !0), 
            f.getColor(), f.getSymbol(), f.setData(c.data, !1), f.isCartesian && (b.hasCartesianSeries = !0), 
            g.push(f), f._i = g.length - 1, C(g, function(a, b) {
                return o(a.options.index, a._i) - o(b.options.index, a._i);
            }), ub(g, function(a, b) {
                a.index = b, a.name = a.name || "Series " + (b + 1);
            });
        },
        bindAxes: function() {
            var a, b = this, c = b.options, d = b.chart;
            b.isCartesian && ub([ "xAxis", "yAxis" ], function(e) {
                ub(d[e], function(d) {
                    a = d.options, (c[e] === a.index || c[e] !== W && c[e] === a.id || c[e] === W && 0 === a.index) && (d.series.push(b), 
                    b[e] = d, d.isDirty = !0);
                }), b[e] || H(18, !0);
            });
        },
        autoIncrement: function() {
            var a = this, b = a.options, c = a.xIncrement;
            return c = o(c, b.pointStart, 0), a.pointInterval = o(a.pointInterval, b.pointInterval, 1), 
            a.xIncrement = c + a.pointInterval, c;
        },
        getSegments: function() {
            var a, b = this, c = -1, d = [], e = b.points, f = e.length;
            if (f) if (b.options.connectNulls) {
                for (a = f; a--; ) null === e[a].y && e.splice(a, 1);
                e.length && (d = [ e ]);
            } else ub(e, function(a, b) {
                null === a.y ? (b > c + 1 && d.push(e.slice(c + 1, b)), c = b) : b === f - 1 && d.push(e.slice(c + 1, b + 1));
            });
            b.segments = d;
        },
        setOptions: function(a) {
            var c, d = this.chart, e = d.options, f = e.plotOptions, g = f[this.type];
            return this.userOptions = a, c = b(g, f.series, a), this.tooltipOptions = b(e.tooltip, c.tooltip), 
            null === g.marker && delete c.marker, c;
        },
        getColor: function() {
            var a, b, c = this.options, d = this.userOptions, e = this.chart.options.colors, f = this.chart.counters;
            a = c.color || Fb[this.type].color, a || c.colorByPoint || (l(d._colorIndex) ? b = d._colorIndex : (d._colorIndex = f.color, 
            b = f.color++), a = e[b]), this.color = a, f.wrapColor(e.length);
        },
        getSymbol: function() {
            var a, b = this, c = b.userOptions, d = b.options.marker, e = b.chart, f = e.options.symbols, g = e.counters;
            b.symbol = d.symbol, b.symbol || (l(c._symbolIndex) ? a = c._symbolIndex : (c._symbolIndex = g.symbol, 
            a = g.symbol++), b.symbol = f[a]), /^url/.test(b.symbol) && (d.radius = 0), g.wrapSymbol(f.length);
        },
        drawLegendSymbol: function(a) {
            var b, c, d, e = this.options, f = e.marker, g = a.options, h = g.symbolWidth, i = this.chart.renderer, j = this.legendGroup, k = a.baseline - ra(.3 * i.fontMetrics(g.itemStyle.fontSize).b);
            e.lineWidth && (d = {
                "stroke-width": e.lineWidth
            }, e.dashStyle && (d.dashstyle = e.dashStyle), this.legendLine = i.path([ _a, 0, k, ab, h, k ]).attr(d).add(j)), 
            f && f.enabled && (b = f.radius, this.legendSymbol = c = i.symbol(this.symbol, h / 2 - b, k - b, 2 * b, 2 * b).add(j), 
            c.isMarker = !0);
        },
        addPoint: function(a, b, c, d) {
            var e, f, g, h, i = this, j = i.options, k = i.data, l = i.graph, m = i.area, n = i.chart, p = i.xData, q = i.yData, r = i.zData, s = i.names, t = l && l.shift || 0, u = j.data;
            if (J(d, n), c && ub([ l, m, i.graphNeg, i.areaNeg ], function(a) {
                a && (a.shift = t + 1);
            }), m && (m.isArea = !0), b = o(b, !0), e = {
                series: i
            }, i.pointClass.prototype.applyOptions.apply(e, [ a ]), g = e.x, h = p.length, i.requireSorting && g < p[h - 1]) for (f = !0; h && p[h - 1] > g; ) h--;
            p.splice(h, 0, g), q.splice(h, 0, i.toYData ? i.toYData(e) : e.y), r.splice(h, 0, e.z), 
            s && (s[g] = e.name), u.splice(h, 0, a), f && (i.data.splice(h, 0, null), i.processData()), 
            "point" === j.legendType && i.generatePoints(), c && (k[0] && k[0].remove ? k[0].remove(!1) : (k.shift(), 
            p.shift(), q.shift(), r.shift(), u.shift())), i.isDirty = !0, i.isDirtyData = !0, 
            b && (i.getAttribs(), n.redraw());
        },
        setData: function(a, b) {
            var c, d = this, f = d.points, i = d.options, j = d.chart, k = null, l = d.xAxis, m = l && l.categories && !l.categories.length ? [] : null;
            d.xIncrement = null, d.pointRange = l && l.categories ? 1 : i.pointRange, d.colorCounter = 0;
            var n, p = [], q = [], r = [], s = a ? a.length : [], t = o(i.turboThreshold, 1e3), u = d.pointArrayMap, v = u && u.length, w = !!d.toYData;
            if (t && s > t) {
                for (c = 0; null === k && c < s; ) k = a[c], c++;
                if (h(k)) {
                    var x = o(i.pointStart, 0), y = o(i.pointInterval, 1);
                    for (c = 0; c < s; c++) p[c] = x, q[c] = a[c], x += y;
                    d.xIncrement = x;
                } else if (g(k)) if (v) for (c = 0; c < s; c++) n = a[c], p[c] = n[0], q[c] = n.slice(1, v + 1); else for (c = 0; c < s; c++) n = a[c], 
                p[c] = n[0], q[c] = n[1]; else H(12);
            } else for (c = 0; c < s; c++) a[c] !== W && (n = {
                series: d
            }, d.pointClass.prototype.applyOptions.apply(n, [ a[c] ]), p[c] = n.x, q[c] = w ? d.toYData(n) : n.y, 
            r[c] = n.z, m && n.name && (m[n.x] = n.name));
            for (e(q[0]) && H(14, !0), d.data = [], d.options.data = a, d.xData = p, d.yData = q, 
            d.zData = r, d.names = m, c = f && f.length || 0; c--; ) f[c] && f[c].destroy && f[c].destroy();
            l && (l.minRange = l.userMinRange), d.isDirty = d.isDirtyData = j.isDirtyBox = !0, 
            o(b, !0) && j.redraw(!1);
        },
        remove: function(a, b) {
            var c = this, d = c.chart;
            a = o(a, !0), c.isRemoving || (c.isRemoving = !0, Ab(c, "remove", null, function() {
                c.destroy(), d.isDirtyLegend = d.isDirtyBox = !0, d.linkSeries(), a && d.redraw(b);
            })), c.isRemoving = !1;
        },
        processData: function(a) {
            var b, c, d, e, f, g = this, h = g.xData, i = g.yData, j = h.length, k = 0, l = g.xAxis, m = g.options, n = m.cropThreshold, o = g.isCartesian;
            if (o && !g.isDirty && !l.isDirty && !g.yAxis.isDirty && !a) return !1;
            if (o && g.sorted && (!n || j > n || g.forceCrop)) {
                var p = l.min, q = l.max;
                h[j - 1] < p || h[0] > q ? (h = [], i = []) : (h[0] < p || h[j - 1] > q) && (b = this.cropData(g.xData, g.yData, p, q), 
                h = b.xData, i = b.yData, k = b.start, c = !0);
            }
            for (f = h.length - 1; f >= 0; f--) d = h[f] - h[f - 1], d > 0 && (e === W || d < e) ? e = d : d < 0 && g.requireSorting && H(15);
            g.cropped = c, g.cropStart = k, g.processedXData = h, g.processedYData = i, null === m.pointRange && (g.pointRange = e || 1), 
            g.closestPointRange = e;
        },
        cropData: function(a, b, c, d) {
            var e, f = a.length, g = 0, h = f, i = o(this.cropShoulder, 1);
            for (e = 0; e < f; e++) if (a[e] >= c) {
                g = ua(0, e - i);
                break;
            }
            for (;e < f; e++) if (a[e] > d) {
                h = e + i;
                break;
            }
            return {
                xData: a.slice(g, h),
                yData: b.slice(g, h),
                start: g,
                end: h
            };
        },
        generatePoints: function() {
            var a, b, c, d, e = this, f = e.options, g = f.data, h = e.data, i = e.processedXData, j = e.processedYData, k = e.pointClass, l = i.length, m = e.cropStart || 0, o = e.hasGroupedData, p = [];
            if (!h && !o) {
                var q = [];
                q.length = g.length, h = e.data = q;
            }
            for (d = 0; d < l; d++) b = m + d, o ? p[d] = new k().init(e, [ i[d] ].concat(n(j[d]))) : (h[b] ? c = h[b] : g[b] !== W && (h[b] = c = new k().init(e, g[b], i[d])), 
            p[d] = c);
            if (h && (l !== (a = h.length) || o)) for (d = 0; d < a; d++) d !== m || o || (d += l), 
            h[d] && (h[d].destroyElements(), h[d].plotX = W);
            e.data = h, e.points = p;
        },
        setStackedPoints: function() {
            if (this.options.stacking && (this.visible === !0 || this.chart.options.chart.ignoreHiddenSeries === !1)) {
                var a, b, c, d, e, f, g, h = this, i = h.processedXData, j = h.processedYData, k = [], l = j.length, m = h.options, n = m.threshold, o = m.stack, p = m.stacking, q = h.stackKey, r = "-" + q, s = h.negStacks, t = h.yAxis, u = t.stacks, v = t.oldStacks;
                for (e = 0; e < l; e++) f = i[e], g = j[e], a = s && g < n, d = a ? r : q, u[d] || (u[d] = {}), 
                u[d][f] || (v[d] && v[d][f] ? (u[d][f] = v[d][f], u[d][f].total = null) : u[d][f] = new Q(t, t.options.stackLabels, a, f, o, p)), 
                b = u[d][f], b.points[h.index] = [ b.cum || 0 ], "percent" === p ? (c = a ? q : r, 
                s && u[c] && u[c][f] ? (c = u[c][f], b.total = c.total = ua(c.total, b.total) + wa(g) || 0) : b.total += wa(g) || 0) : b.total += g || 0, 
                b.cum = (b.cum || 0) + (g || 0), b.points[h.index].push(b.cum), k[e] = b.cum;
                "percent" === p && (t.usePercentage = !0), this.stackedYData = k, t.oldStacks = {};
            }
        },
        setPercentStacks: function() {
            var a = this, b = a.stackKey, c = a.yAxis.stacks;
            ub([ b, "-" + b ], function(b) {
                for (var d, e, f, g, h = a.xData.length; h--; ) d = a.xData[h], e = c[b] && c[b][d], 
                f = e && e.points[a.index], f && (g = e.total ? 100 / e.total : 0, f[0] = I(f[0] * g), 
                f[1] = I(f[1] * g), a.stackedYData[h] = f[1]);
            });
        },
        getExtremes: function() {
            var a, b, c, d, e, f, g, h, i = this.xAxis, j = this.yAxis, k = this.processedXData, l = this.stackedYData || this.processedYData, m = l.length, n = [], p = 0, q = i.getExtremes(), r = q.min, s = q.max;
            for (g = 0; g < m; g++) if (e = k[g], f = l[g], a = null !== f && f !== W && (!j.isLog || f.length || f > 0), 
            b = this.getExtremesFromAll || this.cropped || (k[g + 1] || e) >= r && (k[g - 1] || e) <= s, 
            a && b) if (h = f.length) for (;h--; ) null !== f[h] && (n[p++] = f[h]); else n[p++] = f;
            this.dataMin = o(c, D(n)), this.dataMax = o(d, E(n));
        },
        translate: function() {
            this.processedXData || this.processData(), this.generatePoints();
            var a, b = this, c = b.options, d = c.stacking, e = b.xAxis, f = e.categories, g = b.yAxis, i = b.points, j = i.length, k = !!b.modifyValue, m = c.pointPlacement, n = "between" === m || h(m), p = c.threshold;
            for (a = 0; a < j; a++) {
                var q, r, s = i[a], t = s.x, u = s.y, v = s.low, w = g.stacks[(b.negStacks && u < p ? "-" : "") + b.stackKey];
                g.isLog && u <= 0 && (s.y = u = null), s.plotX = e.translate(t, 0, 0, 0, 1, m, "flags" === this.type), 
                d && b.visible && w && w[t] && (q = w[t], r = q.points[b.index], v = r[0], u = r[1], 
                0 === v && (v = o(p, g.min)), g.isLog && v <= 0 && (v = null), s.percentage = "percent" === d && u, 
                s.total = s.stackTotal = q.total, s.stackY = u, q.setOffset(b.pointXOffset || 0, b.barW || 0)), 
                s.yBottom = l(v) ? g.translate(v, 0, 1, 0, 1) : null, k && (u = b.modifyValue(u, s)), 
                s.plotY = "number" == typeof u && u !== 1 / 0 ? g.translate(u, 0, 1, 0, 1) : W, 
                s.clientX = n ? e.translate(t, 0, 0, 0, 1) : s.plotX, s.negative = s.y < (p || 0), 
                s.category = f && f[s.x] !== W ? f[s.x] : s.x;
            }
            b.getSegments();
        },
        setTooltipPoints: function(a) {
            var b, c, d, e, f, g, h, i = this, j = [], k = i.xAxis, l = k && k.getExtremes(), m = k ? k.tooltipLen || k.len : i.chart.plotSizeX, n = [];
            if (i.options.enableMouseTracking !== !1) {
                for (a && (i.tooltipPoints = null), ub(i.segments || i.points, function(a) {
                    j = j.concat(a);
                }), k && k.reversed && (j = j.reverse()), i.orderTooltipPoints && i.orderTooltipPoints(j), 
                b = j.length, h = 0; h < b; h++) if (e = j[h], f = e.x, f >= l.min && f <= l.max) for (g = j[h + 1], 
                c = d === W ? 0 : d + 1, d = j[h + 1] ? va(ua(0, sa((e.clientX + (g ? g.wrappedClientX || g.clientX : m)) / 2)), m) : m; c >= 0 && c <= d; ) n[c++] = e;
                i.tooltipPoints = n;
            }
        },
        tooltipHeaderFormatter: function(a) {
            var b, c = this, d = c.tooltipOptions, e = d.xDateFormat, f = d.dateTimeLabelFormats, g = c.xAxis, i = g && "datetime" === g.options.type, j = d.headerFormat, k = g && g.closestPointRange;
            if (i && !e) if (k) {
                for (b in ba) if (ba[b] >= k) {
                    e = f[b];
                    break;
                }
            } else e = f.day;
            return i && e && h(a.key) && (j = j.replace("{point.key}", "{point.key:" + e + "}")), 
            w(j, {
                point: a,
                series: c
            });
        },
        onMouseOver: function() {
            var a = this, b = a.chart, c = b.hoverSeries;
            c && c !== a && c.onMouseOut(), a.options.events.mouseOver && Ab(a, "mouseOver"), 
            a.setState(db), b.hoverSeries = a;
        },
        onMouseOut: function() {
            var a = this, b = a.options, c = a.chart, d = c.tooltip, e = c.hoverPoint;
            e && e.onMouseOut(), a && b.events.mouseOut && Ab(a, "mouseOut"), !d || b.stickyTracking || d.shared && !a.noSharedTooltip || d.hide(), 
            a.setState(), c.hoverSeries = null;
        },
        animate: function(b) {
            var c, d, e, g = this, h = g.chart, i = h.renderer, j = g.options.animation, k = h.clipBox, l = h.inverted;
            j && !f(j) && (j = Fb[g.type].animation), e = "_sharedClip" + j.duration + j.easing, 
            b ? (c = h[e], d = h[e + "m"], c || (h[e] = c = i.clipRect(a(k, {
                width: 0
            })), h[e + "m"] = d = i.clipRect(-99, l ? -h.plotLeft : -h.plotTop, 99, l ? h.chartWidth : h.chartHeight)), 
            g.group.clip(c), g.markerGroup.clip(d), g.sharedClipKey = e) : (c = h[e], c && (c.animate({
                width: h.plotSizeX
            }, j), h[e + "m"].animate({
                width: h.plotSizeX + 99
            }, j)), g.animate = null, g.animationTimeout = setTimeout(function() {
                g.afterAnimate();
            }, j.duration));
        },
        afterAnimate: function() {
            var a = this.chart, b = this.sharedClipKey, c = this.group;
            c && this.options.clip !== !1 && (c.clip(a.clipRect), this.markerGroup.clip()), 
            setTimeout(function() {
                b && a[b] && (a[b] = a[b].destroy(), a[b + "m"] = a[b + "m"].destroy());
            }, 100);
        },
        drawPoints: function() {
            var b, c, d, e, f, g, h, i, j, k, l, m, n = this, p = n.points, q = n.chart, r = n.options, s = r.marker, t = n.markerGroup;
            if (s.enabled || n._hasPointMarkers) for (e = p.length; e--; ) f = p[e], c = sa(f.plotX), 
            d = f.plotY, j = f.graphic, k = f.marker || {}, l = s.enabled && k.enabled === W || k.enabled, 
            m = q.isInsidePlot(ra(c), d, q.inverted), l && d !== W && !isNaN(d) && null !== f.y ? (b = f.pointAttr[f.selected ? eb : cb], 
            g = b.r, h = o(k.symbol, n.symbol), i = 0 === h.indexOf("url"), j ? j.attr({
                visibility: m ? Ja ? "inherit" : Ya : Wa
            }).animate(a({
                x: c - g,
                y: d - g
            }, j.symbolName ? {
                width: 2 * g,
                height: 2 * g
            } : {})) : m && (g > 0 || i) && (f.graphic = j = q.renderer.symbol(h, c - g, d - g, 2 * g, 2 * g).attr(b).add(t))) : j && (f.graphic = j.destroy());
        },
        convertAttribs: function(a, b, c, d) {
            var e, f, g = this.pointAttrToOptions, h = {};
            a = a || {}, b = b || {}, c = c || {}, d = d || {};
            for (e in g) f = g[e], h[e] = o(a[f], b[e], c[e], d[e]);
            return h;
        },
        getAttribs: function() {
            var b, c, d, e, f, g, h = this, i = h.options, j = Fb[h.type].marker ? i.marker : i, k = j.states, m = k[db], n = h.color, o = {
                stroke: n,
                fill: n
            }, p = h.points || [], q = [], r = h.pointAttrToOptions, s = i.negativeColor, t = j.lineColor;
            for (i.marker ? (m.radius = m.radius || j.radius + 2, m.lineWidth = m.lineWidth || j.lineWidth + 1) : m.color = m.color || Hb(m.color || n).brighten(m.brightness).get(), 
            q[cb] = h.convertAttribs(j, o), ub([ db, eb ], function(a) {
                q[a] = h.convertAttribs(k[a], q[cb]);
            }), h.pointAttr = q, c = p.length; c--; ) {
                if (d = p[c], j = d.options && d.options.marker || d.options, j && j.enabled === !1 && (j.radius = 0), 
                d.negative && s && (d.color = d.fillColor = s), f = i.colorByPoint || d.color, d.options) for (g in r) l(j[r[g]]) && (f = !0);
                f ? (j = j || {}, e = [], k = j.states || {}, b = k[db] = k[db] || {}, i.marker || (b.color = Hb(b.color || d.color).brighten(b.brightness || m.brightness).get()), 
                e[cb] = h.convertAttribs(a({
                    color: d.color,
                    fillColor: d.color,
                    lineColor: null === t ? d.color : W
                }, j), q[cb]), e[db] = h.convertAttribs(k[db], q[db], e[cb]), e[eb] = h.convertAttribs(k[eb], q[eb], e[cb])) : e = q, 
                d.pointAttr = e;
            }
        },
        update: function(c, d) {
            var e, f = this.chart, g = this.userOptions, h = this.type, i = ob[h].prototype;
            c = b(g, {
                animation: !1,
                index: this.index,
                pointStart: this.xData[0]
            }, {
                data: this.options.data
            }, c), this.remove(!1);
            for (e in i) i.hasOwnProperty(e) && (this[e] = W);
            a(this, ob[c.type || h].prototype), this.init(f, c), o(d, !0) && f.redraw(!1);
        },
        destroy: function() {
            var a, b, c, d, e, f = this, g = f.chart, h = /AppleWebKit\/533/.test(Ba), i = f.data || [];
            for (Ab(f, "destroy"), zb(f), ub([ "xAxis", "yAxis" ], function(a) {
                e = f[a], e && (k(e.series, f), e.isDirty = e.forceRedraw = !0, e.stacks = {});
            }), f.legendItem && f.chart.legend.destroyItem(f), b = i.length; b--; ) c = i[b], 
            c && c.destroy && c.destroy();
            f.points = null, clearTimeout(f.animationTimeout), ub([ "area", "graph", "dataLabelsGroup", "group", "markerGroup", "tracker", "graphNeg", "areaNeg", "posClip", "negClip" ], function(b) {
                f[b] && (a = h && "group" === b ? "hide" : "destroy", f[b][a]());
            }), g.hoverSeries === f && (g.hoverSeries = null), k(g.series, f);
            for (d in f) delete f[d];
        },
        drawDataLabels: function() {
            var a, c, d, e, f = this, g = f.options, h = g.dataLabels, i = f.points;
            (h.enabled || f._hasPointLabels) && (f.dlProcessOptions && f.dlProcessOptions(h), 
            e = f.plotGroup("dataLabelsGroup", "data-labels", f.visible ? Ya : Wa, h.zIndex || 6), 
            c = h, ub(i, function(g) {
                var i, j, k, m, n, p = g.dataLabel, q = g.connector, r = !0;
                if (a = g.options && g.options.dataLabels, i = o(a && a.enabled, c.enabled), p && !i) g.dataLabel = p.destroy(); else if (i) {
                    if (h = b(c, a), n = h.rotation, j = g.getLabelConfig(), d = h.format ? w(h.format, j) : h.formatter.call(j, h), 
                    h.style.color = o(h.color, h.style.color, f.color, "black"), p) l(d) ? (p.attr({
                        text: d
                    }), r = !1) : (g.dataLabel = p = p.destroy(), q && (g.connector = q.destroy())); else if (l(d)) {
                        k = {
                            fill: h.backgroundColor,
                            stroke: h.borderColor,
                            "stroke-width": h.borderWidth,
                            r: h.borderRadius || 0,
                            rotation: n,
                            padding: h.padding,
                            zIndex: 1
                        };
                        for (m in k) k[m] === W && delete k[m];
                        p = g.dataLabel = f.chart.renderer[n ? "text" : "label"](d, 0, -999, null, null, null, h.useHTML).attr(k).css(h.style).add(e).shadow(h.shadow);
                    }
                    p && f.alignDataLabel(g, p, h, null, r);
                }
            }));
        },
        alignDataLabel: function(b, c, d, e, f) {
            var g, h = this.chart, i = h.inverted, j = o(b.plotX, -999), k = o(b.plotY, -999), l = c.getBBox(), m = this.visible && h.isInsidePlot(b.plotX, b.plotY, i);
            m && (e = a({
                x: i ? h.plotWidth - k : j,
                y: ra(i ? h.plotHeight - j : k),
                width: 0,
                height: 0
            }, e), a(d, {
                width: l.width,
                height: l.height
            }), d.rotation ? (g = {
                align: d.align,
                x: e.x + d.x + e.width / 2,
                y: e.y + d.y + e.height / 2
            }, c[f ? "attr" : "animate"](g)) : (c.align(d, null, e), g = c.alignAttr, "justify" === o(d.overflow, "justify") ? this.justifyDataLabel(c, d, g, l, e, f) : o(d.crop, !0) && (m = h.isInsidePlot(g.x, g.y) && h.isInsidePlot(g.x + l.width, g.y + l.height)))), 
            m || c.attr({
                y: -999
            });
        },
        justifyDataLabel: function(a, b, c, d, e, f) {
            var g, h, i = this.chart, j = b.align, k = b.verticalAlign;
            g = c.x, g < 0 && ("right" === j ? b.align = "left" : b.x = -g, h = !0), g = c.x + d.width, 
            g > i.plotWidth && ("left" === j ? b.align = "right" : b.x = i.plotWidth - g, h = !0), 
            g = c.y, g < 0 && ("bottom" === k ? b.verticalAlign = "top" : b.y = -g, h = !0), 
            g = c.y + d.height, g > i.plotHeight && ("top" === k ? b.verticalAlign = "bottom" : b.y = i.plotHeight - g, 
            h = !0), h && (a.placed = !f, a.align(b, null, e));
        },
        getSegmentPath: function(a) {
            var b = this, c = [], d = b.options.step;
            return ub(a, function(e, f) {
                var g, h = e.plotX, i = e.plotY;
                b.getPointSpline ? c.push.apply(c, b.getPointSpline(a, e, f)) : (c.push(f ? ab : _a), 
                d && f && (g = a[f - 1], "right" === d ? c.push(g.plotX, i) : "center" === d ? c.push((g.plotX + h) / 2, g.plotY, (g.plotX + h) / 2, i) : c.push(h, g.plotY)), 
                c.push(e.plotX, e.plotY));
            }), c;
        },
        getGraphPath: function() {
            var a, b = this, c = [], d = [];
            return ub(b.segments, function(e) {
                a = b.getSegmentPath(e), e.length > 1 ? c = c.concat(a) : d.push(e[0]);
            }), b.singlePoints = d, b.graphPath = c, c;
        },
        drawGraph: function() {
            var a = this, b = this.options, c = [ [ "graph", b.lineColor || this.color ] ], d = b.lineWidth, e = b.dashStyle, f = this.getGraphPath(), g = b.negativeColor;
            g && c.push([ "graphNeg", g ]), ub(c, function(c, g) {
                var h, i = c[0], j = a[i];
                j ? (Db(j), j.animate({
                    d: f
                })) : d && f.length && (h = {
                    stroke: c[1],
                    "stroke-width": d,
                    zIndex: 1
                }, e ? h.dashstyle = e : h["stroke-linecap"] = h["stroke-linejoin"] = "round", a[i] = a.chart.renderer.path(f).attr(h).add(a.group).shadow(!g && b.shadow));
            });
        },
        clipNeg: function() {
            var a, b, c, d, e, f = this.options, g = this.chart, h = g.renderer, i = f.negativeColor || f.negativeFillColor, j = this.graph, k = this.area, l = this.posClip, m = this.negClip, n = g.chartWidth, o = g.chartHeight, p = ua(n, o), q = this.yAxis;
            i && (j || k) && (a = ra(q.toPixels(f.threshold || 0, !0)), d = {
                x: 0,
                y: 0,
                width: p,
                height: a
            }, e = {
                x: 0,
                y: a,
                width: p,
                height: p
            }, g.inverted && (d.height = e.y = g.plotWidth - a, h.isVML && (d = {
                x: g.plotWidth - a - g.plotLeft,
                y: 0,
                width: n,
                height: o
            }, e = {
                x: a + g.plotLeft - n,
                y: 0,
                width: g.plotLeft + a,
                height: n
            })), q.reversed ? (b = e, c = d) : (b = d, c = e), l ? (l.animate(b), m.animate(c)) : (this.posClip = l = h.clipRect(b), 
            this.negClip = m = h.clipRect(c), j && this.graphNeg && (j.clip(l), this.graphNeg.clip(m)), 
            k && (k.clip(l), this.areaNeg.clip(m))));
        },
        invertGroups: function() {
            function a() {
                var a = {
                    width: b.yAxis.len,
                    height: b.xAxis.len
                };
                ub([ "group", "markerGroup" ], function(c) {
                    b[c] && b[c].attr(a).invert();
                });
            }
            var b = this, c = b.chart;
            b.xAxis && (yb(c, "resize", a), yb(b, "destroy", function() {
                zb(c, "resize", a);
            }), a(), b.invertGroups = a);
        },
        plotGroup: function(a, b, c, d, e) {
            var f = this[a], g = !f;
            return g && (this[a] = f = this.chart.renderer.g(b).attr({
                visibility: c,
                zIndex: d || .1
            }).add(e)), f[g ? "attr" : "animate"](this.getPlotBox()), f;
        },
        getPlotBox: function() {
            return {
                translateX: this.xAxis ? this.xAxis.left : this.chart.plotLeft,
                translateY: this.yAxis ? this.yAxis.top : this.chart.plotTop,
                scaleX: 1,
                scaleY: 1
            };
        },
        render: function() {
            var a, b = this, c = b.chart, d = b.options, e = d.animation, f = e && !!b.animate && c.renderer.isSVG, g = b.visible ? Ya : Wa, h = d.zIndex, i = b.hasRendered, j = c.seriesGroup;
            a = b.plotGroup("group", "series", g, h, j), b.markerGroup = b.plotGroup("markerGroup", "markers", g, h, j), 
            f && b.animate(!0), b.getAttribs(), a.inverted = !!b.isCartesian && c.inverted, 
            b.drawGraph && (b.drawGraph(), b.clipNeg()), b.drawDataLabels(), b.drawPoints(), 
            b.options.enableMouseTracking !== !1 && b.drawTracker(), c.inverted && b.invertGroups(), 
            d.clip === !1 || b.sharedClipKey || i || a.clip(c.clipRect), f ? b.animate() : i || b.afterAnimate(), 
            b.isDirty = b.isDirtyData = !1, b.hasRendered = !0;
        },
        redraw: function() {
            var a = this, b = a.chart, c = a.isDirtyData, d = a.group, e = a.xAxis, f = a.yAxis;
            d && (b.inverted && d.attr({
                width: b.plotWidth,
                height: b.plotHeight
            }), d.animate({
                translateX: o(e && e.left, b.plotLeft),
                translateY: o(f && f.top, b.plotTop)
            })), a.translate(), a.setTooltipPoints(!0), a.render(), c && Ab(a, "updatedData");
        },
        setState: function(a) {
            var b, c = this, d = c.options, e = c.graph, f = c.graphNeg, g = d.states, h = d.lineWidth;
            if (a = a || cb, c.state !== a) {
                if (c.state = a, g[a] && g[a].enabled === !1) return;
                a && (h = g[a].lineWidth || h + 1), e && !e.dashstyle && (b = {
                    "stroke-width": h
                }, e.attr(b), f && f.attr(b));
            }
        },
        setVisible: function(a, b) {
            var c, d = this, e = d.chart, f = d.legendItem, g = e.options.chart.ignoreHiddenSeries, h = d.visible;
            d.visible = a = d.userOptions.visible = a === W ? !h : a, c = a ? "show" : "hide", 
            ub([ "group", "dataLabelsGroup", "markerGroup", "tracker" ], function(a) {
                d[a] && d[a][c]();
            }), e.hoverSeries === d && d.onMouseOut(), f && e.legend.colorizeItem(d, a), d.isDirty = !0, 
            d.options.stacking && ub(e.series, function(a) {
                a.options.stacking && a.visible && (a.isDirty = !0);
            }), ub(d.linkedSeries, function(b) {
                b.setVisible(a, !1);
            }), g && (e.isDirtyBox = !0), b !== !1 && e.redraw(), Ab(d, c);
        },
        show: function() {
            this.setVisible(!0);
        },
        hide: function() {
            this.setVisible(!1);
        },
        select: function(a) {
            var b = this;
            b.selected = a = a === W ? !b.selected : a, b.checkbox && (b.checkbox.checked = a), 
            Ab(b, a ? "select" : "unselect");
        },
        drawTracker: function() {
            var a, b, c = this, d = c.options, e = d.trackByArea, f = [].concat(e ? c.areaPath : c.graphPath), g = f.length, h = c.chart, i = h.pointer, j = h.renderer, k = h.options.tooltip.snap, l = c.tracker, m = d.cursor, n = m && {
                cursor: m
            }, o = c.singlePoints, p = function() {
                h.hoverSeries !== c && c.onMouseOver();
            };
            if (g && !e) for (b = g + 1; b--; ) f[b] === _a && f.splice(b + 1, 0, f[b + 1] - k, f[b + 2], ab), 
            (b && f[b] === _a || b === g) && f.splice(b, 0, ab, f[b - 2] + k, f[b - 1]);
            for (b = 0; b < o.length; b++) a = o[b], f.push(_a, a.plotX - k, a.plotY, ab, a.plotX + k, a.plotY);
            l ? l.attr({
                d: f
            }) : (c.tracker = j.path(f).attr({
                "stroke-linejoin": "round",
                visibility: c.visible ? Ya : Wa,
                stroke: bb,
                fill: e ? bb : $a,
                "stroke-width": d.lineWidth + (e ? 0 : 2 * k),
                zIndex: 2
            }).add(c.group), ub([ c.tracker, c.markerGroup ], function(a) {
                a.addClass(Xa + "tracker").on("mouseover", p).on("mouseout", function(a) {
                    i.onTrackerMouseOut(a);
                }).css(n), Ma && a.on("touchstart", p);
            }));
        }
    };
    var Qb = r(Pb);
    ob.line = Qb, Fb.area = b(Gb, {
        threshold: 0
    });
    var Rb = r(Pb, {
        type: "area",
        getSegments: function() {
            var a, b, c, d, e, f = [], g = [], h = [], i = this.xAxis, j = this.yAxis, k = j.stacks[this.stackKey], l = {}, m = this.points, n = this.options.connectNulls;
            if (this.options.stacking && !this.cropped) {
                for (d = 0; d < m.length; d++) l[m[d].x] = m[d];
                for (e in k) h.push(+e);
                h.sort(function(a, b) {
                    return a - b;
                }), ub(h, function(d) {
                    (!n || l[d] && null !== l[d].y) && (l[d] ? g.push(l[d]) : (a = i.translate(d), c = k[d].percent ? k[d].total ? 100 * k[d].cum / k[d].total : 0 : k[d].cum, 
                    b = j.toPixels(c, !0), g.push({
                        y: null,
                        plotX: a,
                        clientX: a,
                        plotY: b,
                        yBottom: b,
                        onMouseOver: Pa
                    })));
                }), g.length && f.push(g);
            } else Pb.prototype.getSegments.call(this), f = this.segments;
            this.segments = f;
        },
        getSegmentPath: function(a) {
            var b, c, d = Pb.prototype.getSegmentPath.call(this, a), e = [].concat(d), f = this.options, g = d.length, h = this.yAxis.getThreshold(f.threshold);
            if (3 === g && e.push(ab, d[1], d[2]), f.stacking && !this.closedStacks) for (b = a.length - 1; b >= 0; b--) c = o(a[b].yBottom, h), 
            b < a.length - 1 && f.step && e.push(a[b + 1].plotX, c), e.push(a[b].plotX, c); else this.closeSegment(e, a, h);
            return this.areaPath = this.areaPath.concat(e), d;
        },
        closeSegment: function(a, b, c) {
            a.push(ab, b[b.length - 1].plotX, c, ab, b[0].plotX, c);
        },
        drawGraph: function() {
            this.areaPath = [], Pb.prototype.drawGraph.apply(this);
            var a = this, b = this.areaPath, c = this.options, d = c.negativeColor, e = c.negativeFillColor, f = [ [ "area", this.color, c.fillColor ] ];
            (d || e) && f.push([ "areaNeg", d, e ]), ub(f, function(d) {
                var e = d[0], f = a[e];
                f ? f.animate({
                    d: b
                }) : a[e] = a.chart.renderer.path(b).attr({
                    fill: o(d[2], Hb(d[1]).setOpacity(o(c.fillOpacity, .75)).get()),
                    zIndex: 0
                }).add(a.group);
            });
        },
        drawLegendSymbol: function(a, b) {
            b.legendSymbol = this.chart.renderer.rect(0, a.baseline - 11, a.options.symbolWidth, 12, 2).attr({
                zIndex: 3
            }).add(b.legendGroup);
        }
    });
    ob.area = Rb, Fb.spline = b(Gb);
    var Sb = r(Pb, {
        type: "spline",
        getPointSpline: function(a, b, c) {
            var d, e, f, g, h, i = 1.5, j = i + 1, k = b.plotX, l = b.plotY, m = a[c - 1], n = a[c + 1];
            if (m && n) {
                var o, p = m.plotX, q = m.plotY, r = n.plotX, s = n.plotY;
                d = (i * k + p) / j, e = (i * l + q) / j, f = (i * k + r) / j, g = (i * l + s) / j, 
                o = (g - e) * (f - k) / (f - d) + l - g, e += o, g += o, e > q && e > l ? (e = ua(q, l), 
                g = 2 * l - e) : e < q && e < l && (e = va(q, l), g = 2 * l - e), g > s && g > l ? (g = ua(s, l), 
                e = 2 * l - g) : g < s && g < l && (g = va(s, l), e = 2 * l - g), b.rightContX = f, 
                b.rightContY = g;
            }
            return c ? (h = [ "C", m.rightContX || m.plotX, m.rightContY || m.plotY, d || k, e || l, k, l ], 
            m.rightContX = m.rightContY = null) : h = [ _a, k, l ], h;
        }
    });
    ob.spline = Sb, Fb.areaspline = b(Fb.area);
    var Tb = Rb.prototype, Ub = r(Sb, {
        type: "areaspline",
        closedStacks: !0,
        getSegmentPath: Tb.getSegmentPath,
        closeSegment: Tb.closeSegment,
        drawGraph: Tb.drawGraph,
        drawLegendSymbol: Tb.drawLegendSymbol
    });
    ob.areaspline = Ub, Fb.column = b(Gb, {
        borderColor: "#FFFFFF",
        borderWidth: 1,
        borderRadius: 0,
        groupPadding: .2,
        marker: null,
        pointPadding: .1,
        minPointLength: 0,
        cropThreshold: 50,
        pointRange: null,
        states: {
            hover: {
                brightness: .1,
                shadow: !1
            },
            select: {
                color: "#C0C0C0",
                borderColor: "#000000",
                shadow: !1
            }
        },
        dataLabels: {
            align: null,
            verticalAlign: null,
            y: null
        },
        stickyTracking: !1,
        threshold: 0
    });
    var Vb = r(Pb, {
        type: "column",
        pointAttrToOptions: {
            stroke: "borderColor",
            "stroke-width": "borderWidth",
            fill: "color",
            r: "borderRadius"
        },
        cropShoulder: 0,
        trackerGroups: [ "group", "dataLabelsGroup" ],
        negStacks: !0,
        init: function() {
            Pb.prototype.init.apply(this, arguments);
            var a = this, b = a.chart;
            b.hasRendered && ub(b.series, function(b) {
                b.type === a.type && (b.isDirty = !0);
            });
        },
        getColumnMetrics: function() {
            var a, b, c = this, d = c.options, e = c.xAxis, f = c.yAxis, g = e.reversed, h = {}, i = 0;
            d.grouping === !1 ? i = 1 : ub(c.chart.series, function(d) {
                var e = d.options, g = d.yAxis;
                d.type === c.type && d.visible && f.len === g.len && f.pos === g.pos && (e.stacking ? (a = d.stackKey, 
                h[a] === W && (h[a] = i++), b = h[a]) : e.grouping !== !1 && (b = i++), d.columnIndex = b);
            });
            var j = va(wa(e.transA) * (e.ordinalSlope || d.pointRange || e.closestPointRange || 1), e.len), k = j * d.groupPadding, m = j - 2 * k, n = m / i, p = d.pointWidth, q = l(p) ? (n - p) / 2 : n * d.pointPadding, r = o(p, n - 2 * q), s = (g ? i - (c.columnIndex || 0) : c.columnIndex) || 0, t = q + (k + s * n - j / 2) * (g ? -1 : 1);
            return c.columnMetrics = {
                width: r,
                offset: t
            };
        },
        translate: function() {
            var a = this, b = a.chart, c = a.options, d = c.borderWidth, e = a.yAxis, f = c.threshold, g = a.translatedThreshold = e.getThreshold(f), h = o(c.minPointLength, 5), i = a.getColumnMetrics(), j = i.width, k = a.barW = ta(ua(j, 1 + 2 * d)), l = a.pointXOffset = i.offset, m = -(d % 2 ? .5 : 0), n = d % 2 ? .5 : 1;
            b.renderer.isVML && b.inverted && (n += 1), Pb.prototype.translate.apply(a), ub(a.points, function(a) {
                var b, c, d, f, i = o(a.yBottom, g), p = va(ua(-999 - i, a.plotY), e.len + 999 + i), q = a.plotX + l, r = k, s = va(p, i), t = ua(p, i) - s;
                wa(t) < h && h && (t = h, s = ra(wa(s - g) > h ? i - h : g - (e.translate(a.y, 0, 1, 0, 1) <= g ? h : 0))), 
                a.barX = q, a.pointWidth = j, f = wa(q) < .5, b = ra(q + r) + m, q = ra(q) + m, 
                r = b - q, d = wa(s) < .5, c = ra(s + t) + n, s = ra(s) + n, t = c - s, f && (q += 1, 
                r -= 1), d && (s -= 1, t += 1), a.shapeType = "rect", a.shapeArgs = {
                    x: q,
                    y: s,
                    width: r,
                    height: t
                };
            });
        },
        getSymbol: Pa,
        drawLegendSymbol: Rb.prototype.drawLegendSymbol,
        drawGraph: Pa,
        drawPoints: function() {
            var a, c = this, d = c.options, e = c.chart.renderer;
            ub(c.points, function(f) {
                var g = f.plotY, h = f.graphic;
                g === W || isNaN(g) || null === f.y ? h && (f.graphic = h.destroy()) : (a = f.shapeArgs, 
                h ? (Db(h), h.animate(b(a))) : f.graphic = h = e[f.shapeType](a).attr(f.pointAttr[f.selected ? eb : cb]).add(c.group).shadow(d.shadow, null, d.stacking && !d.borderRadius));
            });
        },
        drawTracker: function() {
            var a = this, b = a.chart, c = b.pointer, d = a.options.cursor, e = d && {
                cursor: d
            }, f = function(c) {
                var d, e = c.target;
                for (b.hoverSeries !== a && a.onMouseOver(); e && !d; ) d = e.point, e = e.parentNode;
                d !== W && d !== b.hoverPoint && d.onMouseOver(c);
            };
            ub(a.points, function(a) {
                a.graphic && (a.graphic.element.point = a), a.dataLabel && (a.dataLabel.element.point = a);
            }), a._hasTracking || (ub(a.trackerGroups, function(b) {
                a[b] && (a[b].addClass(Xa + "tracker").on("mouseover", f).on("mouseout", function(a) {
                    c.onTrackerMouseOut(a);
                }).css(e), Ma && a[b].on("touchstart", f));
            }), a._hasTracking = !0);
        },
        alignDataLabel: function(a, c, d, e, f) {
            var g = this.chart, h = g.inverted, i = a.dlBox || a.shapeArgs, j = a.below || a.plotY > o(this.translatedThreshold, g.plotSizeY), k = o(d.inside, !!this.options.stacking);
            i && (e = b(i), h && (e = {
                x: g.plotWidth - e.y - e.height,
                y: g.plotHeight - e.x - e.width,
                width: e.height,
                height: e.width
            }), k || (h ? (e.x += j ? 0 : e.width, e.width = 0) : (e.y += j ? e.height : 0, 
            e.height = 0))), d.align = o(d.align, !h || k ? "center" : j ? "right" : "left"), 
            d.verticalAlign = o(d.verticalAlign, h || k ? "middle" : j ? "top" : "bottom"), 
            Pb.prototype.alignDataLabel.call(this, a, c, d, e, f);
        },
        animate: function(a) {
            var b, c = this, d = this.yAxis, e = c.options, f = this.chart.inverted, g = {};
            Ja && (a ? (g.scaleY = .001, b = va(d.pos + d.len, ua(d.pos, d.toPixels(e.threshold))), 
            f ? g.translateX = b - d.len : g.translateY = b, c.group.attr(g)) : (g.scaleY = 1, 
            g[f ? "translateX" : "translateY"] = d.pos, c.group.animate(g, c.options.animation), 
            c.animate = null));
        },
        remove: function() {
            var a = this, b = a.chart;
            b.hasRendered && ub(b.series, function(b) {
                b.type === a.type && (b.isDirty = !0);
            }), Pb.prototype.remove.apply(a, arguments);
        }
    });
    ob.column = Vb, Fb.bar = b(Fb.column);
    var Wb = r(Vb, {
        type: "bar",
        inverted: !0
    });
    ob.bar = Wb, Fb.scatter = b(Gb, {
        lineWidth: 0,
        tooltip: {
            headerFormat: '<span style="font-size: 10px; color:{series.color}">{series.name}</span><br/>',
            pointFormat: "x: <b>{point.x}</b><br/>y: <b>{point.y}</b><br/>",
            followPointer: !0
        },
        stickyTracking: !1
    });
    var Xb = r(Pb, {
        type: "scatter",
        sorted: !1,
        requireSorting: !1,
        noSharedTooltip: !0,
        trackerGroups: [ "markerGroup" ],
        drawTracker: Vb.prototype.drawTracker,
        setTooltipPoints: Pa
    });
    ob.scatter = Xb, Fb.pie = b(Gb, {
        borderColor: "#FFFFFF",
        borderWidth: 1,
        center: [ null, null ],
        clip: !1,
        colorByPoint: !0,
        dataLabels: {
            distance: 30,
            enabled: !0,
            formatter: function() {
                return this.point.name;
            }
        },
        ignoreHiddenPoint: !0,
        legendType: "point",
        marker: null,
        size: null,
        showInLegend: !1,
        slicedOffset: 10,
        states: {
            hover: {
                brightness: .1,
                shadow: !1
            }
        },
        stickyTracking: !1,
        tooltip: {
            followPointer: !0
        }
    });
    var Yb = r(Ob, {
        init: function() {
            Ob.prototype.init.apply(this, arguments);
            var b, c = this;
            return c.y < 0 && (c.y = null), a(c, {
                visible: c.visible !== !1,
                name: o(c.name, "Slice")
            }), b = function(a) {
                c.slice("select" === a.type);
            }, yb(c, "select", b), yb(c, "unselect", b), c;
        },
        setVisible: function(a) {
            var b, c = this, d = c.series, e = d.chart;
            c.visible = c.options.visible = a = a === W ? !c.visible : a, d.options.data[tb(c, d.data)] = c.options, 
            b = a ? "show" : "hide", ub([ "graphic", "dataLabel", "connector", "shadowGroup" ], function(a) {
                c[a] && c[a][b]();
            }), c.legendItem && e.legend.colorizeItem(c, a), !d.isDirty && d.options.ignoreHiddenPoint && (d.isDirty = !0, 
            e.redraw());
        },
        slice: function(a, b, c) {
            var d, e = this, f = e.series, g = f.chart;
            J(c, g), b = o(b, !0), e.sliced = e.options.sliced = a = l(a) ? a : !e.sliced, f.options.data[tb(e, f.data)] = e.options, 
            d = a ? e.slicedTranslation : {
                translateX: 0,
                translateY: 0
            }, e.graphic.animate(d), e.shadowGroup && e.shadowGroup.animate(d);
        }
    }), Zb = {
        type: "pie",
        isCartesian: !1,
        pointClass: Yb,
        requireSorting: !1,
        noSharedTooltip: !0,
        trackerGroups: [ "group", "dataLabelsGroup" ],
        pointAttrToOptions: {
            stroke: "borderColor",
            "stroke-width": "borderWidth",
            fill: "color"
        },
        getColor: Pa,
        animate: function(a) {
            var b = this, c = b.points, d = b.startAngleRad;
            a || (ub(c, function(a) {
                var c = a.graphic, e = a.shapeArgs;
                c && (c.attr({
                    r: b.center[3] / 2,
                    start: d,
                    end: d
                }), c.animate({
                    r: e.r,
                    start: e.start,
                    end: e.end
                }, b.options.animation));
            }), b.animate = null);
        },
        setData: function(a, b) {
            Pb.prototype.setData.call(this, a, !1), this.processData(), this.generatePoints(), 
            o(b, !0) && this.chart.redraw();
        },
        generatePoints: function() {
            var a, b, c, d, e = 0, f = this.options.ignoreHiddenPoint;
            for (Pb.prototype.generatePoints.call(this), b = this.points, c = b.length, a = 0; a < c; a++) d = b[a], 
            e += f && !d.visible ? 0 : d.y;
            for (this.total = e, a = 0; a < c; a++) d = b[a], d.percentage = e > 0 ? d.y / e * 100 : 0, 
            d.total = e;
        },
        getCenter: function() {
            var a, b, c = this.options, e = this.chart, f = 2 * (c.slicedOffset || 0), g = e.plotWidth - 2 * f, h = e.plotHeight - 2 * f, i = c.center, j = [ o(i[0], "50%"), o(i[1], "50%"), c.size || "100%", c.innerSize || 0 ], k = va(g, h);
            return xb(j, function(c, e) {
                return b = /%$/.test(c), a = e < 2 || 2 === e && b, (b ? [ g, h, k, k ][e] * d(c) / 100 : c) + (a ? f : 0);
            });
        },
        translate: function(a) {
            this.generatePoints();
            var b, c, d, e, f, g, h, i = this, j = 0, k = 1e3, l = i.options, m = l.slicedOffset, n = m + l.borderWidth, o = l.startAngle || 0, p = i.startAngleRad = za / 180 * (o - 90), q = i.endAngleRad = za / 180 * ((l.endAngle || o + 360) - 90), r = q - p, s = i.points, t = l.dataLabels.distance, u = l.ignoreHiddenPoint, v = s.length;
            for (a || (i.center = a = i.getCenter()), i.getX = function(b, c) {
                return d = qa.asin((b - a[1]) / (a[2] / 2 + t)), a[0] + (c ? -1 : 1) * (xa(d) * (a[2] / 2 + t));
            }, g = 0; g < v; g++) h = s[g], b = p + j * r, u && !h.visible || (j += h.percentage / 100), 
            c = p + j * r, h.shapeType = "arc", h.shapeArgs = {
                x: a[0],
                y: a[1],
                r: a[2] / 2,
                innerR: a[3] / 2,
                start: ra(b * k) / k,
                end: ra(c * k) / k
            }, d = (c + b) / 2, d > .75 * r && (d -= 2 * za), h.slicedTranslation = {
                translateX: ra(xa(d) * m),
                translateY: ra(ya(d) * m)
            }, e = xa(d) * a[2] / 2, f = ya(d) * a[2] / 2, h.tooltipPos = [ a[0] + .7 * e, a[1] + .7 * f ], 
            h.half = d < -za / 2 || d > za / 2 ? 1 : 0, h.angle = d, n = va(n, t / 2), h.labelPos = [ a[0] + e + xa(d) * t, a[1] + f + ya(d) * t, a[0] + e + xa(d) * n, a[1] + f + ya(d) * n, a[0] + e, a[1] + f, t < 0 ? "center" : h.half ? "right" : "left", d ];
        },
        setTooltipPoints: Pa,
        drawGraph: null,
        drawPoints: function() {
            var b, c, d, e, f = this, g = f.chart, h = g.renderer, i = f.options.shadow;
            i && !f.shadowGroup && (f.shadowGroup = h.g("shadow").add(f.group)), ub(f.points, function(g) {
                c = g.graphic, e = g.shapeArgs, d = g.shadowGroup, i && !d && (d = g.shadowGroup = h.g("shadow").add(f.shadowGroup)), 
                b = g.sliced ? g.slicedTranslation : {
                    translateX: 0,
                    translateY: 0
                }, d && d.attr(b), c ? c.animate(a(e, b)) : g.graphic = c = h.arc(e).setRadialReference(f.center).attr(g.pointAttr[g.selected ? eb : cb]).attr({
                    "stroke-linejoin": "round"
                }).attr(b).add(f.group).shadow(i, d), g.visible === !1 && g.setVisible(!1);
            });
        },
        sortByAngle: function(a, b) {
            a.sort(function(a, c) {
                return void 0 !== a.angle && (c.angle - a.angle) * b;
            });
        },
        drawDataLabels: function() {
            var a, b, c, d, e, f, g, h, i, j, k, l, m, n = this, p = n.data, q = n.chart, r = n.options.dataLabels, s = o(r.connectorPadding, 10), t = o(r.connectorWidth, 1), u = q.plotWidth, v = q.plotHeight, w = o(r.softConnector, !0), x = r.distance, y = n.center, z = y[2] / 2, A = y[1], B = x > 0, C = [ [], [] ], D = [ 0, 0, 0, 0 ], F = function(a, b) {
                return b.y - a.y;
            };
            if (n.visible && (r.enabled || n._hasPointLabels)) {
                for (Pb.prototype.drawDataLabels.apply(n), ub(p, function(a) {
                    a.dataLabel && C[a.half].push(a);
                }), l = 0; !g && p[l]; ) g = p[l] && p[l].dataLabel && (p[l].dataLabel.getBBox().height || 21), 
                l++;
                for (l = 2; l--; ) {
                    var G, H, I, J = [], K = [], L = C[l], M = L.length;
                    if (n.sortByAngle(L, l - .5), x > 0) {
                        for (H = A - z - x; H <= A + z + x; H += g) J.push(H);
                        if (G = J.length, M > G) {
                            for (k = [].concat(L), k.sort(F), m = M; m--; ) k[m].rank = m;
                            for (m = M; m--; ) L[m].rank >= G && L.splice(m, 1);
                            M = L.length;
                        }
                        for (m = 0; m < M; m++) {
                            a = L[m], f = a.labelPos;
                            var N, O, P = 9999;
                            for (O = 0; O < G; O++) N = wa(J[O] - f[1]), N < P && (P = N, I = O);
                            if (I < m && null !== J[m]) I = m; else if (G < M - m + I && null !== J[m]) for (I = G - M + m; null === J[I]; ) I++; else for (;null === J[I]; ) I++;
                            K.push({
                                i: I,
                                y: J[I]
                            }), J[I] = null;
                        }
                        K.sort(F);
                    }
                    for (m = 0; m < M; m++) {
                        var Q, R;
                        a = L[m], f = a.labelPos, d = a.dataLabel, j = a.visible === !1 ? Wa : Ya, R = f[1], 
                        x > 0 ? (Q = K.pop(), I = Q.i, i = Q.y, (R > i && null !== J[I + 1] || R < i && null !== J[I - 1]) && (i = R)) : i = R, 
                        h = r.justify ? y[0] + (l ? -1 : 1) * (z + x) : n.getX(0 === I || I === J.length - 1 ? R : i, l), 
                        d._attr = {
                            visibility: j,
                            align: f[6]
                        }, d._pos = {
                            x: h + r.x + ({
                                left: s,
                                right: -s
                            }[f[6]] || 0),
                            y: i + r.y - 10
                        }, d.connX = h, d.connY = i, null === this.options.size && (e = d.width, h - e < s ? D[3] = ua(ra(e - h + s), D[3]) : h + e > u - s && (D[1] = ua(ra(h + e - u + s), D[1])), 
                        i - g / 2 < 0 ? D[0] = ua(ra(-i + g / 2), D[0]) : i + g / 2 > v && (D[2] = ua(ra(i + g / 2 - v), D[2])));
                    }
                }
                (0 === E(D) || this.verifyDataLabelOverflow(D)) && (this.placeDataLabels(), B && t && ub(this.points, function(a) {
                    b = a.connector, f = a.labelPos, d = a.dataLabel, d && d._pos ? (j = d._attr.visibility, 
                    h = d.connX, i = d.connY, c = w ? [ _a, h + ("left" === f[6] ? 5 : -5), i, "C", h, i, 2 * f[2] - f[4], 2 * f[3] - f[5], f[2], f[3], ab, f[4], f[5] ] : [ _a, h + ("left" === f[6] ? 5 : -5), i, ab, f[2], f[3], ab, f[4], f[5] ], 
                    b ? (b.animate({
                        d: c
                    }), b.attr("visibility", j)) : a.connector = b = n.chart.renderer.path(c).attr({
                        "stroke-width": t,
                        stroke: r.connectorColor || a.color || "#606060",
                        visibility: j
                    }).add(n.group)) : b && (a.connector = b.destroy());
                }));
            }
        },
        verifyDataLabelOverflow: function(a) {
            var b, c = this.center, d = this.options, e = d.center, f = d.minSize || 80, g = f;
            return null !== e[0] ? g = ua(c[2] - ua(a[1], a[3]), f) : (g = ua(c[2] - a[1] - a[3], f), 
            c[0] += (a[3] - a[1]) / 2), null !== e[1] ? g = ua(va(g, c[2] - ua(a[0], a[2])), f) : (g = ua(va(g, c[2] - a[0] - a[2]), f), 
            c[1] += (a[0] - a[2]) / 2), g < c[2] ? (c[2] = g, this.translate(c), ub(this.points, function(a) {
                a.dataLabel && (a.dataLabel._pos = null);
            }), this.drawDataLabels()) : b = !0, b;
        },
        placeDataLabels: function() {
            ub(this.points, function(a) {
                var b, c = a.dataLabel;
                c && (b = c._pos, b ? (c.attr(c._attr), c[c.moved ? "animate" : "attr"](b), c.moved = !0) : c && c.attr({
                    y: -999
                }));
            });
        },
        alignDataLabel: Pa,
        drawTracker: Vb.prototype.drawTracker,
        drawLegendSymbol: Rb.prototype.drawLegendSymbol,
        getSymbol: Pa
    };
    Zb = r(Pb, Zb), ob.pie = Zb, a(Highcharts, {
        Axis: R,
        Chart: V,
        Color: Hb,
        Legend: U,
        Pointer: T,
        Point: Ob,
        Tick: O,
        Tooltip: S,
        Renderer: X,
        Series: Pb,
        SVGElement: N,
        SVGRenderer: Ib,
        arrayMin: D,
        arrayMax: E,
        charts: Qa,
        dateFormat: $,
        format: w,
        pathAnim: aa,
        getOptions: M,
        hasBidiBug: Ka,
        isTouchDevice: Ha,
        numberFormat: s,
        seriesTypes: ob,
        setOptions: L,
        addEvent: yb,
        removeEvent: zb,
        createElement: q,
        discardElement: G,
        css: p,
        each: ub,
        extend: a,
        map: xb,
        merge: b,
        pick: o,
        splat: n,
        extendClass: r,
        pInt: d,
        wrap: u,
        svg: Ja,
        canvas: La,
        vml: !Ja && !La,
        product: Ra,
        version: Sa
    });
}();
//# sourceMappingURL=highcharts.min.js.map
/*! 康美网络医院 最后修改于： 2016-10-20 */